(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@tanstack/query-core/build/modern/queryObserver.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/queryObserver.ts
__turbopack_context__.s([
    "QueryObserver",
    ()=>QueryObserver
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$focusManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/focusManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/notifyManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$query$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/query.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/subscribable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$thenable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/thenable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/timeoutManager.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
var QueryObserver = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subscribable"] {
    constructor(client, options){
        super();
        this.options = options;
        this.#client = client;
        this.#selectError = null;
        this.#currentThenable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$thenable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pendingThenable"])();
        this.bindMethods();
        this.setOptions(options);
    }
    #client;
    #currentQuery = void 0;
    #currentQueryInitialState = void 0;
    #currentResult = void 0;
    #currentResultState;
    #currentResultOptions;
    #currentThenable;
    #selectError;
    #selectFn;
    #selectResult;
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    #lastQueryWithDefinedData;
    #staleTimeoutId;
    #refetchIntervalId;
    #currentRefetchInterval;
    #trackedProps = /* @__PURE__ */ new Set();
    bindMethods() {
        this.refetch = this.refetch.bind(this);
    }
    onSubscribe() {
        if (this.listeners.size === 1) {
            this.#currentQuery.addObserver(this);
            if (shouldFetchOnMount(this.#currentQuery, this.options)) {
                this.#executeFetch();
            } else {
                this.updateResult();
            }
            this.#updateTimers();
        }
    }
    onUnsubscribe() {
        if (!this.hasListeners()) {
            this.destroy();
        }
    }
    shouldFetchOnReconnect() {
        return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnReconnect);
    }
    shouldFetchOnWindowFocus() {
        return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnWindowFocus);
    }
    destroy() {
        this.listeners = /* @__PURE__ */ new Set();
        this.#clearStaleTimeout();
        this.#clearRefetchInterval();
        this.#currentQuery.removeObserver(this);
    }
    setOptions(options) {
        const prevOptions = this.options;
        const prevQuery = this.#currentQuery;
        this.options = this.#client.defaultQueryOptions(options);
        if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(this.options.enabled, this.#currentQuery) !== "boolean") {
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        }
        this.#updateQuery();
        this.#currentQuery.setOptions(this.options);
        if (prevOptions._defaulted && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowEqualObjects"])(this.options, prevOptions)) {
            this.#client.getQueryCache().notify({
                type: "observerOptionsUpdated",
                query: this.#currentQuery,
                observer: this
            });
        }
        const mounted = this.hasListeners();
        if (mounted && shouldFetchOptionally(this.#currentQuery, prevQuery, this.options, prevOptions)) {
            this.#executeFetch();
        }
        this.updateResult();
        if (mounted && (this.#currentQuery !== prevQuery || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(this.options.enabled, this.#currentQuery) !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(prevOptions.enabled, this.#currentQuery) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveStaleTime"])(this.options.staleTime, this.#currentQuery) !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveStaleTime"])(prevOptions.staleTime, this.#currentQuery))) {
            this.#updateStaleTimeout();
        }
        const nextRefetchInterval = this.#computeRefetchInterval();
        if (mounted && (this.#currentQuery !== prevQuery || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(this.options.enabled, this.#currentQuery) !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {
            this.#updateRefetchInterval(nextRefetchInterval);
        }
    }
    getOptimisticResult(options) {
        const query = this.#client.getQueryCache().build(this.#client, options);
        const result = this.createResult(query, options);
        if (shouldAssignObserverCurrentProperties(this, result)) {
            this.#currentResult = result;
            this.#currentResultOptions = this.options;
            this.#currentResultState = this.#currentQuery.state;
        }
        return result;
    }
    getCurrentResult() {
        return this.#currentResult;
    }
    trackResult(result, onPropTracked) {
        return new Proxy(result, {
            get: (target, key)=>{
                this.trackProp(key);
                onPropTracked?.(key);
                if (key === "promise") {
                    this.trackProp("data");
                    if (!this.options.experimental_prefetchInRender && this.#currentThenable.status === "pending") {
                        this.#currentThenable.reject(new Error("experimental_prefetchInRender feature flag is not enabled"));
                    }
                }
                return Reflect.get(target, key);
            }
        });
    }
    trackProp(key) {
        this.#trackedProps.add(key);
    }
    getCurrentQuery() {
        return this.#currentQuery;
    }
    refetch({ ...options } = {}) {
        return this.fetch({
            ...options
        });
    }
    fetchOptimistic(options) {
        const defaultedOptions = this.#client.defaultQueryOptions(options);
        const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);
        return query.fetch().then(()=>this.createResult(query, defaultedOptions));
    }
    fetch(fetchOptions) {
        return this.#executeFetch({
            ...fetchOptions,
            cancelRefetch: fetchOptions.cancelRefetch ?? true
        }).then(()=>{
            this.updateResult();
            return this.#currentResult;
        });
    }
    #executeFetch(fetchOptions) {
        this.#updateQuery();
        let promise = this.#currentQuery.fetch(this.options, fetchOptions);
        if (!fetchOptions?.throwOnError) {
            promise = promise.catch(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noop"]);
        }
        return promise;
    }
    #updateStaleTimeout() {
        this.#clearStaleTimeout();
        const staleTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveStaleTime"])(this.options.staleTime, this.#currentQuery);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isServer"] || this.#currentResult.isStale || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidTimeout"])(staleTime)) {
            return;
        }
        const time = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeUntilStale"])(this.#currentResult.dataUpdatedAt, staleTime);
        const timeout = time + 1;
        this.#staleTimeoutId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeoutManager"].setTimeout(()=>{
            if (!this.#currentResult.isStale) {
                this.updateResult();
            }
        }, timeout);
    }
    #computeRefetchInterval() {
        return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;
    }
    #updateRefetchInterval(nextInterval) {
        this.#clearRefetchInterval();
        this.#currentRefetchInterval = nextInterval;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isServer"] || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(this.options.enabled, this.#currentQuery) === false || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidTimeout"])(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
            return;
        }
        this.#refetchIntervalId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeoutManager"].setInterval(()=>{
            if (this.options.refetchIntervalInBackground || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$focusManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["focusManager"].isFocused()) {
                this.#executeFetch();
            }
        }, this.#currentRefetchInterval);
    }
    #updateTimers() {
        this.#updateStaleTimeout();
        this.#updateRefetchInterval(this.#computeRefetchInterval());
    }
    #clearStaleTimeout() {
        if (this.#staleTimeoutId) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeoutManager"].clearTimeout(this.#staleTimeoutId);
            this.#staleTimeoutId = void 0;
        }
    }
    #clearRefetchInterval() {
        if (this.#refetchIntervalId) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeoutManager"].clearInterval(this.#refetchIntervalId);
            this.#refetchIntervalId = void 0;
        }
    }
    createResult(query, options) {
        const prevQuery = this.#currentQuery;
        const prevOptions = this.options;
        const prevResult = this.#currentResult;
        const prevResultState = this.#currentResultState;
        const prevResultOptions = this.#currentResultOptions;
        const queryChange = query !== prevQuery;
        const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;
        const { state } = query;
        let newState = {
            ...state
        };
        let isPlaceholderData = false;
        let data;
        if (options._optimisticResults) {
            const mounted = this.hasListeners();
            const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
            const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
            if (fetchOnMount || fetchOptionally) {
                newState = {
                    ...newState,
                    ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$query$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fetchState"])(state.data, query.options)
                };
            }
            if (options._optimisticResults === "isRestoring") {
                newState.fetchStatus = "idle";
            }
        }
        let { error, errorUpdatedAt, status } = newState;
        data = newState.data;
        let skipSelect = false;
        if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
            let placeholderData;
            if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {
                placeholderData = prevResult.data;
                skipSelect = true;
            } else {
                placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(this.#lastQueryWithDefinedData?.state.data, this.#lastQueryWithDefinedData) : options.placeholderData;
            }
            if (placeholderData !== void 0) {
                status = "success";
                data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceData"])(prevResult?.data, placeholderData, options);
                isPlaceholderData = true;
            }
        }
        if (options.select && data !== void 0 && !skipSelect) {
            if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {
                data = this.#selectResult;
            } else {
                try {
                    this.#selectFn = options.select;
                    data = options.select(data);
                    data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceData"])(prevResult?.data, data, options);
                    this.#selectResult = data;
                    this.#selectError = null;
                } catch (selectError) {
                    this.#selectError = selectError;
                }
            }
        }
        if (this.#selectError) {
            error = this.#selectError;
            data = this.#selectResult;
            errorUpdatedAt = Date.now();
            status = "error";
        }
        const isFetching = newState.fetchStatus === "fetching";
        const isPending = status === "pending";
        const isError = status === "error";
        const isLoading = isPending && isFetching;
        const hasData = data !== void 0;
        const result = {
            status,
            fetchStatus: newState.fetchStatus,
            isPending,
            isSuccess: status === "success",
            isError,
            isInitialLoading: isLoading,
            isLoading,
            data,
            dataUpdatedAt: newState.dataUpdatedAt,
            error,
            errorUpdatedAt,
            failureCount: newState.fetchFailureCount,
            failureReason: newState.fetchFailureReason,
            errorUpdateCount: newState.errorUpdateCount,
            isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
            isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
            isFetching,
            isRefetching: isFetching && !isPending,
            isLoadingError: isError && !hasData,
            isPaused: newState.fetchStatus === "paused",
            isPlaceholderData,
            isRefetchError: isError && hasData,
            isStale: isStale(query, options),
            refetch: this.refetch,
            promise: this.#currentThenable,
            isEnabled: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(options.enabled, query) !== false
        };
        const nextResult = result;
        if (this.options.experimental_prefetchInRender) {
            const finalizeThenableIfPossible = (thenable)=>{
                if (nextResult.status === "error") {
                    thenable.reject(nextResult.error);
                } else if (nextResult.data !== void 0) {
                    thenable.resolve(nextResult.data);
                }
            };
            const recreateThenable = ()=>{
                const pending = this.#currentThenable = nextResult.promise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$thenable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pendingThenable"])();
                finalizeThenableIfPossible(pending);
            };
            const prevThenable = this.#currentThenable;
            switch(prevThenable.status){
                case "pending":
                    if (query.queryHash === prevQuery.queryHash) {
                        finalizeThenableIfPossible(prevThenable);
                    }
                    break;
                case "fulfilled":
                    if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
                        recreateThenable();
                    }
                    break;
                case "rejected":
                    if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
                        recreateThenable();
                    }
                    break;
            }
        }
        return nextResult;
    }
    updateResult() {
        const prevResult = this.#currentResult;
        const nextResult = this.createResult(this.#currentQuery, this.options);
        this.#currentResultState = this.#currentQuery.state;
        this.#currentResultOptions = this.options;
        if (this.#currentResultState.data !== void 0) {
            this.#lastQueryWithDefinedData = this.#currentQuery;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowEqualObjects"])(nextResult, prevResult)) {
            return;
        }
        this.#currentResult = nextResult;
        const shouldNotifyListeners = ()=>{
            if (!prevResult) {
                return true;
            }
            const { notifyOnChangeProps } = this.options;
            const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
            if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.#trackedProps.size) {
                return true;
            }
            const includedProps = new Set(notifyOnChangePropsValue ?? this.#trackedProps);
            if (this.options.throwOnError) {
                includedProps.add("error");
            }
            return Object.keys(this.#currentResult).some((key)=>{
                const typedKey = key;
                const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
                return changed && includedProps.has(typedKey);
            });
        };
        this.#notify({
            listeners: shouldNotifyListeners()
        });
    }
    #updateQuery() {
        const query = this.#client.getQueryCache().build(this.#client, this.options);
        if (query === this.#currentQuery) {
            return;
        }
        const prevQuery = this.#currentQuery;
        this.#currentQuery = query;
        this.#currentQueryInitialState = query.state;
        if (this.hasListeners()) {
            prevQuery?.removeObserver(this);
            query.addObserver(this);
        }
    }
    onQueryUpdate() {
        this.updateResult();
        if (this.hasListeners()) {
            this.#updateTimers();
        }
    }
    #notify(notifyOptions) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batch(()=>{
            if (notifyOptions.listeners) {
                this.listeners.forEach((listener)=>{
                    listener(this.#currentResult);
                });
            }
            this.#client.getQueryCache().notify({
                query: this.#currentQuery,
                type: "observerResultsUpdated"
            });
        });
    }
};
function shouldLoadOnMount(query, options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
    return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(options.enabled, query) !== false && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveStaleTime"])(options.staleTime, query) !== "static") {
        const value = typeof field === "function" ? field(query) : field;
        return value === "always" || value !== false && isStale(query, options);
    }
    return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
    return (query !== prevQuery || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEnabled"])(options.enabled, query) !== false && query.isStaleByTime((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveStaleTime"])(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowEqualObjects"])(observer.getCurrentResult(), optimisticResult)) {
        return true;
    }
    return false;
}
;
 //# sourceMappingURL=queryObserver.js.map
}),
"[project]/node_modules/@tanstack/query-core/build/modern/mutationObserver.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/mutationObserver.ts
__turbopack_context__.s([
    "MutationObserver",
    ()=>MutationObserver
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$mutation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/mutation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/notifyManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/subscribable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)");
;
;
;
;
var MutationObserver = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subscribable"] {
    #client;
    #currentResult = void 0;
    #currentMutation;
    #mutateOptions;
    constructor(client, options){
        super();
        this.#client = client;
        this.setOptions(options);
        this.bindMethods();
        this.#updateResult();
    }
    bindMethods() {
        this.mutate = this.mutate.bind(this);
        this.reset = this.reset.bind(this);
    }
    setOptions(options) {
        const prevOptions = this.options;
        this.options = this.#client.defaultMutationOptions(options);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowEqualObjects"])(this.options, prevOptions)) {
            this.#client.getMutationCache().notify({
                type: "observerOptionsUpdated",
                mutation: this.#currentMutation,
                observer: this
            });
        }
        if (prevOptions?.mutationKey && this.options.mutationKey && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hashKey"])(prevOptions.mutationKey) !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hashKey"])(this.options.mutationKey)) {
            this.reset();
        } else if (this.#currentMutation?.state.status === "pending") {
            this.#currentMutation.setOptions(this.options);
        }
    }
    onUnsubscribe() {
        if (!this.hasListeners()) {
            this.#currentMutation?.removeObserver(this);
        }
    }
    onMutationUpdate(action) {
        this.#updateResult();
        this.#notify(action);
    }
    getCurrentResult() {
        return this.#currentResult;
    }
    reset() {
        this.#currentMutation?.removeObserver(this);
        this.#currentMutation = void 0;
        this.#updateResult();
        this.#notify();
    }
    mutate(variables, options) {
        this.#mutateOptions = options;
        this.#currentMutation?.removeObserver(this);
        this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);
        this.#currentMutation.addObserver(this);
        return this.#currentMutation.execute(variables);
    }
    #updateResult() {
        const state = this.#currentMutation?.state ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$mutation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultState"])();
        this.#currentResult = {
            ...state,
            isPending: state.status === "pending",
            isSuccess: state.status === "success",
            isError: state.status === "error",
            isIdle: state.status === "idle",
            mutate: this.mutate,
            reset: this.reset
        };
    }
    #notify(action) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batch(()=>{
            if (this.#mutateOptions && this.hasListeners()) {
                const variables = this.#currentResult.variables;
                const onMutateResult = this.#currentResult.context;
                const context = {
                    client: this.#client,
                    meta: this.options.meta,
                    mutationKey: this.options.mutationKey
                };
                if (action?.type === "success") {
                    this.#mutateOptions.onSuccess?.(action.data, variables, onMutateResult, context);
                    this.#mutateOptions.onSettled?.(action.data, null, variables, onMutateResult, context);
                } else if (action?.type === "error") {
                    this.#mutateOptions.onError?.(action.error, variables, onMutateResult, context);
                    this.#mutateOptions.onSettled?.(void 0, action.error, variables, onMutateResult, context);
                }
            }
            this.listeners.forEach((listener)=>{
                listener(this.#currentResult);
            });
        });
    }
};
;
 //# sourceMappingURL=mutationObserver.js.map
}),
"[project]/node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "QueryErrorResetBoundary",
    ()=>QueryErrorResetBoundary,
    "useQueryErrorResetBoundary",
    ()=>useQueryErrorResetBoundary
]);
// src/QueryErrorResetBoundary.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
"use client";
;
;
function createValue() {
    let isReset = false;
    return {
        clearReset: ()=>{
            isReset = false;
        },
        reset: ()=>{
            isReset = true;
        },
        isReset: ()=>{
            return isReset;
        }
    };
}
var QueryErrorResetBoundaryContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](createValue());
var useQueryErrorResetBoundary = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](QueryErrorResetBoundaryContext);
var QueryErrorResetBoundary = ({ children })=>{
    const [value] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "QueryErrorResetBoundary.useState": ()=>createValue()
    }["QueryErrorResetBoundary.useState"]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(QueryErrorResetBoundaryContext.Provider, {
        value,
        children: typeof children === "function" ? children(value) : children
    });
};
;
 //# sourceMappingURL=QueryErrorResetBoundary.js.map
}),
"[project]/node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ensurePreventErrorBoundaryRetry",
    ()=>ensurePreventErrorBoundaryRetry,
    "getHasError",
    ()=>getHasError,
    "useClearResetErrorBoundary",
    ()=>useClearResetErrorBoundary
]);
// src/errorBoundaryUtils.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)");
"use client";
;
;
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary)=>{
    if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {
        if (!errorResetBoundary.isReset()) {
            options.retryOnMount = false;
        }
    }
};
var useClearResetErrorBoundary = (errorResetBoundary)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "useClearResetErrorBoundary.useEffect": ()=>{
            errorResetBoundary.clearReset();
        }
    }["useClearResetErrorBoundary.useEffect"], [
        errorResetBoundary
    ]);
};
var getHasError = ({ result, errorResetBoundary, throwOnError, query, suspense })=>{
    return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldThrowError"])(throwOnError, [
        result.error,
        query
    ]));
};
;
 //# sourceMappingURL=errorBoundaryUtils.js.map
}),
"[project]/node_modules/@tanstack/react-query/build/modern/IsRestoringProvider.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "IsRestoringProvider",
    ()=>IsRestoringProvider,
    "useIsRestoring",
    ()=>useIsRestoring
]);
// src/IsRestoringProvider.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
"use client";
;
var IsRestoringContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](false);
var useIsRestoring = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;
;
 //# sourceMappingURL=IsRestoringProvider.js.map
}),
"[project]/node_modules/@tanstack/react-query/build/modern/suspense.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/suspense.ts
__turbopack_context__.s([
    "defaultThrowOnError",
    ()=>defaultThrowOnError,
    "ensureSuspenseTimers",
    ()=>ensureSuspenseTimers,
    "fetchOptimistic",
    ()=>fetchOptimistic,
    "shouldSuspend",
    ()=>shouldSuspend,
    "willFetch",
    ()=>willFetch
]);
var defaultThrowOnError = (_error, query)=>query.state.data === void 0;
var ensureSuspenseTimers = (defaultedOptions)=>{
    if (defaultedOptions.suspense) {
        const MIN_SUSPENSE_TIME_MS = 1e3;
        const clamp = (value)=>value === "static" ? value : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS);
        const originalStaleTime = defaultedOptions.staleTime;
        defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args)=>clamp(originalStaleTime(...args)) : clamp(originalStaleTime);
        if (typeof defaultedOptions.gcTime === "number") {
            defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, MIN_SUSPENSE_TIME_MS);
        }
    }
};
var willFetch = (result, isRestoring)=>result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result)=>defaultedOptions?.suspense && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary)=>observer.fetchOptimistic(defaultedOptions).catch(()=>{
        errorResetBoundary.clearReset();
    });
;
 //# sourceMappingURL=suspense.js.map
}),
"[project]/node_modules/@tanstack/react-query/build/modern/useBaseQuery.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useBaseQuery",
    ()=>useBaseQuery
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
// src/useBaseQuery.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/notifyManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryClientProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryErrorResetBoundary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$errorBoundaryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$IsRestoringProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/react-query/build/modern/IsRestoringProvider.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$suspense$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/react-query/build/modern/suspense.js [app-client] (ecmascript)");
"use client";
;
;
;
;
;
;
;
function useBaseQuery(options, Observer, queryClient) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (typeof options !== "object" || Array.isArray(options)) {
            throw new Error('Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object');
        }
    }
    const isRestoring = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$IsRestoringProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useIsRestoring"])();
    const errorResetBoundary = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryErrorResetBoundary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryErrorResetBoundary"])();
    const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryClientProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryClient"])(queryClient);
    const defaultedOptions = client.defaultQueryOptions(options);
    client.getDefaultOptions().queries?._experimental_beforeQuery?.(defaultedOptions);
    if ("TURBOPACK compile-time truthy", 1) {
        if (!defaultedOptions.queryFn) {
            console.error(`[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`);
        }
    }
    defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$suspense$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ensureSuspenseTimers"])(defaultedOptions);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$errorBoundaryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ensurePreventErrorBoundaryRetry"])(defaultedOptions, errorResetBoundary);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$errorBoundaryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useClearResetErrorBoundary"])(errorResetBoundary);
    const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
    const [observer] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "useBaseQuery.useState": ()=>new Observer(client, defaultedOptions)
    }["useBaseQuery.useState"]);
    const result = observer.getOptimisticResult(defaultedOptions);
    const shouldSubscribe = !isRestoring && options.subscribed !== false;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "useBaseQuery.useSyncExternalStore.useCallback": (onStoreChange)=>{
            const unsubscribe = shouldSubscribe ? observer.subscribe(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(onStoreChange)) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noop"];
            observer.updateResult();
            return unsubscribe;
        }
    }["useBaseQuery.useSyncExternalStore.useCallback"], [
        observer,
        shouldSubscribe
    ]), {
        "useBaseQuery.useSyncExternalStore": ()=>observer.getCurrentResult()
    }["useBaseQuery.useSyncExternalStore"], {
        "useBaseQuery.useSyncExternalStore": ()=>observer.getCurrentResult()
    }["useBaseQuery.useSyncExternalStore"]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "useBaseQuery.useEffect": ()=>{
            observer.setOptions(defaultedOptions);
        }
    }["useBaseQuery.useEffect"], [
        defaultedOptions,
        observer
    ]);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$suspense$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldSuspend"])(defaultedOptions, result)) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$suspense$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fetchOptimistic"])(defaultedOptions, observer, errorResetBoundary);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$errorBoundaryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getHasError"])({
        result,
        errorResetBoundary,
        throwOnError: defaultedOptions.throwOnError,
        query: client.getQueryCache().get(defaultedOptions.queryHash),
        suspense: defaultedOptions.suspense
    })) {
        throw result.error;
    }
    ;
    client.getDefaultOptions().queries?._experimental_afterQuery?.(defaultedOptions, result);
    if (defaultedOptions.experimental_prefetchInRender && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isServer"] && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$suspense$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["willFetch"])(result, isRestoring)) {
        const promise = isNewCacheEntry ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$suspense$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fetchOptimistic"])(defaultedOptions, observer, errorResetBoundary) : // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
        client.getQueryCache().get(defaultedOptions.queryHash)?.promise;
        promise?.catch(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noop"]).finally(()=>{
            observer.updateResult();
        });
    }
    return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
;
 //# sourceMappingURL=useBaseQuery.js.map
}),
"[project]/node_modules/@tanstack/react-query/build/modern/useQuery.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useQuery",
    ()=>useQuery
]);
// src/useQuery.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$queryObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/queryObserver.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$useBaseQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/react-query/build/modern/useBaseQuery.js [app-client] (ecmascript)");
"use client";
;
;
function useQuery(options, queryClient) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$useBaseQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useBaseQuery"])(options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$queryObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QueryObserver"], queryClient);
}
;
 //# sourceMappingURL=useQuery.js.map
}),
"[project]/node_modules/@tanstack/react-query/build/modern/useMutation.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useMutation",
    ()=>useMutation
]);
// src/useMutation.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$mutationObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/mutationObserver.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/notifyManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryClientProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js [app-client] (ecmascript)");
"use client";
;
;
;
function useMutation(options, queryClient) {
    const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryClientProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryClient"])(queryClient);
    const [observer] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "useMutation.useState": ()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$mutationObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutationObserver"](client, options)
    }["useMutation.useState"]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "useMutation.useEffect": ()=>{
            observer.setOptions(options);
        }
    }["useMutation.useEffect"], [
        observer,
        options
    ]);
    const result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "useMutation.useSyncExternalStore[result]": (onStoreChange)=>observer.subscribe(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(onStoreChange))
    }["useMutation.useSyncExternalStore[result]"], [
        observer
    ]), {
        "useMutation.useSyncExternalStore[result]": ()=>observer.getCurrentResult()
    }["useMutation.useSyncExternalStore[result]"], {
        "useMutation.useSyncExternalStore[result]": ()=>observer.getCurrentResult()
    }["useMutation.useSyncExternalStore[result]"]);
    const mutate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "useMutation.useCallback[mutate]": (variables, mutateOptions)=>{
            observer.mutate(variables, mutateOptions).catch(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noop"]);
        }
    }["useMutation.useCallback[mutate]"], [
        observer
    ]);
    if (result.error && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldThrowError"])(observer.options.throwOnError, [
        result.error
    ])) {
        throw result.error;
    }
    return {
        ...result,
        mutate,
        mutateAsync: result.mutate
    };
}
;
 //# sourceMappingURL=useMutation.js.map
}),
"[project]/node_modules/direction/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = direction;
var RTL = '\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC';
var LTR = 'A-Za-z\u00C0-\u00D6\u00D8-\u00F6' + '\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C' + '\uFE00-\uFE6F\uFEFD-\uFFFF';
var rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']');
var ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']');
function direction(value) {
    value = String(value || '');
    if (rtl.test(value)) {
        return 'rtl';
    }
    if (ltr.test(value)) {
        return 'ltr';
    }
    return 'neutral';
}
}),
"[project]/node_modules/compute-scroll-into-view/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "compute",
    ()=>r
]);
const t = (t)=>"object" == typeof t && null != t && 1 === t.nodeType, e = (t, e)=>(!e || "hidden" !== t) && "visible" !== t && "clip" !== t, n = (t, n)=>{
    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
        const o = getComputedStyle(t, null);
        return e(o.overflowY, n) || e(o.overflowX, n) || ((t)=>{
            const e = ((t)=>{
                if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;
                try {
                    return t.ownerDocument.defaultView.frameElement;
                } catch (t) {
                    return null;
                }
            })(t);
            return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth);
        })(t);
    }
    return !1;
}, o = (t, e, n, o, l, r, i, s)=>r < t && i > e || r > t && i < e ? 0 : r <= t && s <= n || i >= e && s >= n ? r - t - o : i > e && s < n || r < t && s > n ? i - e + l : 0, l = (t)=>{
    const e = t.parentElement;
    return null == e ? t.getRootNode().host || null : e;
}, r = (e, r)=>{
    var i, s, d, h;
    if ("undefined" == typeof document) return [];
    const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r, p = "function" == typeof a ? a : (t)=>t !== a;
    if (!t(e)) throw new TypeError("Invalid target");
    const m = document.scrollingElement || document.documentElement, w = [];
    let W = e;
    for(; t(W) && p(W);){
        if (W = l(W), W === m) {
            w.push(W);
            break;
        }
        null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
    }
    const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t)=>{
        const e = window.getComputedStyle(t);
        return {
            top: parseFloat(e.scrollMarginTop) || 0,
            right: parseFloat(e.scrollMarginRight) || 0,
            bottom: parseFloat(e.scrollMarginBottom) || 0,
            left: parseFloat(e.scrollMarginLeft) || 0
        };
    })(e);
    let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
    const L = [];
    for(let t = 0; t < w.length; t++){
        const e = w[t], { height: l, width: r, top: i, right: s, bottom: d, left: h } = e.getBoundingClientRect();
        if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && (e === m && !n(e) || x >= i && I <= d && R >= h && C <= s)) return L;
        const a = getComputedStyle(e), g = parseInt(a.borderLeftWidth, 10), p = parseInt(a.borderTopWidth, 10), W = parseInt(a.borderRightWidth, 10), T = parseInt(a.borderBottomWidth, 10);
        let B = 0, F = 0;
        const V = "offsetWidth" in e ? e.offsetWidth - e.clientWidth - g - W : 0, S = "offsetHeight" in e ? e.offsetHeight - e.clientHeight - p - T : 0, X = "offsetWidth" in e ? 0 === e.offsetWidth ? 0 : r / e.offsetWidth : 0, Y = "offsetHeight" in e ? 0 === e.offsetHeight ? 0 : l / e.offsetHeight : 0;
        if (m === e) B = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o(M, M + H, H, p, T, M + k, M + k + v, v) : k - H / 2, F = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o(y, y + b, b, g, W, y + D, y + D + E, E), B = Math.max(0, B + M), F = Math.max(0, F + y);
        else {
            B = "start" === f ? k - i - p : "end" === f ? k - d + T + S : "nearest" === f ? o(i, d, l, p, T + S, k, k + v, v) : k - (i + l / 2) + S / 2, F = "start" === u ? D - h - g : "center" === u ? D - (h + r / 2) + V / 2 : "end" === u ? D - s + W + V : o(h, s, r, g, W + V, D, D + E, E);
            const { scrollLeft: t, scrollTop: n } = e;
            B = 0 === Y ? 0 : Math.max(0, Math.min(n + B / Y, e.scrollHeight - l / Y + S)), F = 0 === X ? 0 : Math.max(0, Math.min(t + F / X, e.scrollWidth - r / X + V)), k += n - B, D += t - F;
        }
        L.push({
            el: e,
            top: B,
            left: F
        });
    }
    return L;
};
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/scroll-into-view-if-needed/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>e
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$compute$2d$scroll$2d$into$2d$view$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/compute-scroll-into-view/dist/index.js [app-client] (ecmascript)");
;
const o = (t)=>!1 === t ? {
        block: "end",
        inline: "nearest"
    } : ((t)=>t === Object(t) && 0 !== Object.keys(t).length)(t) ? t : {
        block: "start",
        inline: "nearest"
    };
function e(e, r) {
    if (!e.isConnected || !((t)=>{
        let o = t;
        for(; o && o.parentNode;){
            if (o.parentNode === document) return !0;
            o = o.parentNode instanceof ShadowRoot ? o.parentNode.host : o.parentNode;
        }
        return !1;
    })(e)) return;
    const n = ((t)=>{
        const o = window.getComputedStyle(t);
        return {
            top: parseFloat(o.scrollMarginTop) || 0,
            right: parseFloat(o.scrollMarginRight) || 0,
            bottom: parseFloat(o.scrollMarginBottom) || 0,
            left: parseFloat(o.scrollMarginLeft) || 0
        };
    })(e);
    if (((t)=>"object" == typeof t && "function" == typeof t.behavior)(r)) return r.behavior((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$compute$2d$scroll$2d$into$2d$view$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compute"])(e, r));
    const l = "boolean" == typeof r || null == r ? void 0 : r.behavior;
    for (const { el: a, top: i, left: s } of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$compute$2d$scroll$2d$into$2d$view$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compute"])(e, o(r))){
        const t = i - n.top + n.bottom, o = s - n.left + n.right;
        a.scroll({
            top: t,
            left: o,
            behavior: l
        });
    }
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/env.ts
__turbopack_context__.s([
    "Immer",
    ()=>Immer2,
    "applyPatches",
    ()=>applyPatches,
    "castDraft",
    ()=>castDraft,
    "castImmutable",
    ()=>castImmutable,
    "createDraft",
    ()=>createDraft,
    "current",
    ()=>current,
    "enableMapSet",
    ()=>enableMapSet,
    "enablePatches",
    ()=>enablePatches,
    "finishDraft",
    ()=>finishDraft,
    "freeze",
    ()=>freeze,
    "immerable",
    ()=>DRAFTABLE,
    "isDraft",
    ()=>isDraft,
    "isDraftable",
    ()=>isDraftable,
    "nothing",
    ()=>NOTHING,
    "original",
    ()=>original,
    "produce",
    ()=>produce,
    "produceWithPatches",
    ()=>produceWithPatches,
    "setAutoFreeze",
    ()=>setAutoFreeze,
    "setUseStrictIteration",
    ()=>setUseStrictIteration,
    "setUseStrictShallowCopy",
    ()=>setUseStrictShallowCopy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
// src/utils/errors.ts
var errors = ("TURBOPACK compile-time truthy", 1) ? [
    // All error codes, starting by 0:
    function(plugin) {
        return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
    },
    function(thing) {
        return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
    },
    "This object has been frozen and should not be mutated",
    function(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
    },
    "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
    "Immer forbids circular references",
    "The first or second argument to `produce` must be a function",
    "The third argument to `produce` must be a function or undefined",
    "First argument to `createDraft` must be a plain object, an array, or an immerable object",
    "First argument to `finishDraft` must be a draft returned by `createDraft`",
    function(thing) {
        return `'current' expects a draft, got: ${thing}`;
    },
    "Object.defineProperty() cannot be used on an Immer draft",
    "Object.setPrototypeOf() cannot be used on an Immer draft",
    "Immer only supports deleting array indices",
    "Immer only supports setting array indices and the 'length' property",
    function(thing) {
        return `'original' expects a draft, got: ${thing}`;
    }
] : "TURBOPACK unreachable";
function die(error, ...args) {
    if ("TURBOPACK compile-time truthy", 1) {
        const e = errors[error];
        const msg = typeof e === "function" ? e.apply(null, args) : e;
        throw new Error(`[Immer] ${msg}`);
    }
    throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);
}
// src/utils/common.ts
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
    if (!value) return false;
    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
var cachedCtorStrings = /* @__PURE__ */ new WeakMap();
function isPlainObject(value) {
    if (!value || typeof value !== "object") return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null || proto === Object.prototype) return true;
    const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    if (Ctor === Object) return true;
    if (typeof Ctor !== "function") return false;
    let ctorString = cachedCtorStrings.get(Ctor);
    if (ctorString === void 0) {
        ctorString = Function.toString.call(Ctor);
        cachedCtorStrings.set(Ctor, ctorString);
    }
    return ctorString === objectCtorString;
}
function original(value) {
    if (!isDraft(value)) die(15, value);
    return value[DRAFT_STATE].base_;
}
function each(obj, iter, strict = true) {
    if (getArchtype(obj) === 0 /* Object */ ) {
        const keys = strict ? Reflect.ownKeys(obj) : Object.keys(obj);
        keys.forEach((key)=>{
            iter(key, obj[key], obj);
        });
    } else {
        obj.forEach((entry, index)=>iter(index, entry, obj));
    }
}
function getArchtype(thing) {
    const state = thing[DRAFT_STATE];
    return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */  : isMap(thing) ? 2 /* Map */  : isSet(thing) ? 3 /* Set */  : 0 /* Object */ ;
}
function has(thing, prop) {
    return getArchtype(thing) === 2 /* Map */  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
    return getArchtype(thing) === 2 /* Map */  ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
    const t = getArchtype(thing);
    if (t === 2 /* Map */ ) thing.set(propOrOldValue, value);
    else if (t === 3 /* Set */ ) {
        thing.add(value);
    } else thing[propOrOldValue] = value;
}
function is(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function isMap(target) {
    return target instanceof Map;
}
function isSet(target) {
    return target instanceof Set;
}
function latest(state) {
    return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
    if (isMap(base)) {
        return new Map(base);
    }
    if (isSet(base)) {
        return new Set(base);
    }
    if (Array.isArray(base)) return Array.prototype.slice.call(base);
    const isPlain = isPlainObject(base);
    if (strict === true || strict === "class_only" && !isPlain) {
        const descriptors = Object.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE];
        let keys = Reflect.ownKeys(descriptors);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            const desc = descriptors[key];
            if (desc.writable === false) {
                desc.writable = true;
                desc.configurable = true;
            }
            if (desc.get || desc.set) descriptors[key] = {
                configurable: true,
                writable: true,
                // could live with !!desc.set as well here...
                enumerable: desc.enumerable,
                value: base[key]
            };
        }
        return Object.create(getPrototypeOf(base), descriptors);
    } else {
        const proto = getPrototypeOf(base);
        if (proto !== null && isPlain) {
            return {
                ...base
            };
        }
        const obj = Object.create(proto);
        return Object.assign(obj, base);
    }
}
function freeze(obj, deep = false) {
    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
    if (getArchtype(obj) > 1) {
        Object.defineProperties(obj, {
            set: dontMutateMethodOverride,
            add: dontMutateMethodOverride,
            clear: dontMutateMethodOverride,
            delete: dontMutateMethodOverride
        });
    }
    Object.freeze(obj);
    if (deep) Object.values(obj).forEach((value)=>freeze(value, true));
    return obj;
}
function dontMutateFrozenCollections() {
    die(2);
}
var dontMutateMethodOverride = {
    value: dontMutateFrozenCollections
};
function isFrozen(obj) {
    if (obj === null || typeof obj !== "object") return true;
    return Object.isFrozen(obj);
}
// src/utils/plugins.ts
var plugins = {};
function getPlugin(pluginKey) {
    const plugin = plugins[pluginKey];
    if (!plugin) {
        die(0, pluginKey);
    }
    return plugin;
}
function loadPlugin(pluginKey, implementation) {
    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
}
// src/core/scope.ts
var currentScope;
function getCurrentScope() {
    return currentScope;
}
function createScope(parent_, immer_) {
    return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
    };
}
function usePatchesInScope(scope, patchListener) {
    if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
    }
}
function revokeScope(scope) {
    leaveScope(scope);
    scope.drafts_.forEach(revokeDraft);
    scope.drafts_ = null;
}
function leaveScope(scope) {
    if (scope === currentScope) {
        currentScope = scope.parent_;
    }
}
function enterScope(immer2) {
    return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
    const state = draft[DRAFT_STATE];
    if (state.type_ === 0 /* Object */  || state.type_ === 1 /* Array */ ) state.revoke_();
    else state.revoked_ = true;
}
// src/core/finalize.ts
function processResult(result, scope) {
    scope.unfinalizedDrafts_ = scope.drafts_.length;
    const baseDraft = scope.drafts_[0];
    const isReplaced = result !== void 0 && result !== baseDraft;
    if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
            revokeScope(scope);
            die(4);
        }
        if (isDraftable(result)) {
            result = finalize(scope, result);
            if (!scope.parent_) maybeFreeze(scope, result);
        }
        if (scope.patches_) {
            getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
        }
    } else {
        result = finalize(scope, baseDraft, []);
    }
    revokeScope(scope);
    if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
    }
    return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
    if (isFrozen(value)) return value;
    const useStrictIteration = rootScope.immer_.shouldUseStrictIteration();
    const state = value[DRAFT_STATE];
    if (!state) {
        each(value, (key, childValue)=>finalizeProperty(rootScope, state, value, key, childValue, path), useStrictIteration);
        return value;
    }
    if (state.scope_ !== rootScope) return value;
    if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
    }
    if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3 /* Set */ ) {
            resultEach = new Set(result);
            result.clear();
            isSet2 = true;
        }
        each(resultEach, (key, childValue)=>finalizeProperty(rootScope, state, result, key, childValue, path, isSet2), useStrictIteration);
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
            getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
        }
    }
    return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
    if (childValue == null) {
        return;
    }
    if (typeof childValue !== "object" && !targetIsSet) {
        return;
    }
    const childIsFrozen = isFrozen(childValue);
    if (childIsFrozen && !targetIsSet) {
        return;
    }
    if (("TURBOPACK compile-time value", "development") !== "production" && childValue === targetObject) die(5);
    if (isDraft(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 /* Set */  && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
            rootScope.canAutoFreeze_ = false;
        } else return;
    } else if (targetIsSet) {
        targetObject.add(childValue);
    }
    if (isDraftable(childValue) && !childIsFrozen) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
            return;
        }
        if (parentState && parentState.base_ && parentState.base_[prop] === childValue && childIsFrozen) {
            return;
        }
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop))) maybeFreeze(rootScope, childValue);
    }
}
function maybeFreeze(scope, value, deep = false) {
    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
    }
}
// src/core/proxy.ts
function createProxyProxy(base, parent) {
    const isArray = Array.isArray(base);
    const state = {
        type_: isArray ? 1 /* Array */  : 0 /* Object */ ,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
    };
    let target = state;
    let traps = objectTraps;
    if (isArray) {
        target = [
            state
        ];
        traps = arrayTraps;
    }
    const { revoke, proxy } = Proxy.revocable(target, traps);
    state.draft_ = proxy;
    state.revoke_ = revoke;
    return proxy;
}
var objectTraps = {
    get (state, prop) {
        if (prop === DRAFT_STATE) return state;
        const source = latest(state);
        if (!has(source, prop)) {
            return readPropFromProto(state, source, prop);
        }
        const value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
            return value;
        }
        if (value === peek(state.base_, prop)) {
            prepareCopy(state);
            return state.copy_[prop] = createProxy(value, state);
        }
        return value;
    },
    has (state, prop) {
        return prop in latest(state);
    },
    ownKeys (state) {
        return Reflect.ownKeys(latest(state));
    },
    set (state, prop, value) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc?.set) {
            desc.set.call(state.draft_, value);
            return true;
        }
        if (!state.modified_) {
            const current2 = peek(latest(state), prop);
            const currentState = current2?.[DRAFT_STATE];
            if (currentState && currentState.base_ === value) {
                state.copy_[prop] = value;
                state.assigned_[prop] = false;
                return true;
            }
            if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;
            prepareCopy(state);
            markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
    },
    deleteProperty (state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
            state.assigned_[prop] = false;
            prepareCopy(state);
            markChanged(state);
        } else {
            delete state.assigned_[prop];
        }
        if (state.copy_) {
            delete state.copy_[prop];
        }
        return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor (state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc) return desc;
        return {
            writable: true,
            configurable: state.type_ !== 1 /* Array */  || prop !== "length",
            enumerable: desc.enumerable,
            value: owner[prop]
        };
    },
    defineProperty () {
        die(11);
    },
    getPrototypeOf (state) {
        return getPrototypeOf(state.base_);
    },
    setPrototypeOf () {
        die(12);
    }
};
var arrayTraps = {};
each(objectTraps, (key, fn)=>{
    arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
    };
});
arrayTraps.deleteProperty = function(state, prop) {
    if (("TURBOPACK compile-time value", "development") !== "production" && isNaN(parseInt(prop))) die(13);
    return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
    if (("TURBOPACK compile-time value", "development") !== "production" && prop !== "length" && isNaN(parseInt(prop))) die(14);
    return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
    const state = draft[DRAFT_STATE];
    const source = state ? latest(state) : draft;
    return source[prop];
}
function readPropFromProto(state, source, prop) {
    const desc = getDescriptorFromProto(source, prop);
    return desc ? `value` in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_) : void 0;
}
function getDescriptorFromProto(source, prop) {
    if (!(prop in source)) return void 0;
    let proto = getPrototypeOf(source);
    while(proto){
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc) return desc;
        proto = getPrototypeOf(proto);
    }
    return void 0;
}
function markChanged(state) {
    if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
            markChanged(state.parent_);
        }
    }
}
function prepareCopy(state) {
    if (!state.copy_) {
        state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
    }
}
// src/core/immerClass.ts
var Immer2 = class {
    constructor(config){
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.useStrictIteration_ = true;
        /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */ this.produce = (base, recipe, patchListener)=>{
            if (typeof base === "function" && typeof recipe !== "function") {
                const defaultBase = recipe;
                recipe = base;
                const self = this;
                return function curriedProduce(base2 = defaultBase, ...args) {
                    return self.produce(base2, (draft)=>recipe.call(this, draft, ...args));
                };
            }
            if (typeof recipe !== "function") die(6);
            if (patchListener !== void 0 && typeof patchListener !== "function") die(7);
            let result;
            if (isDraftable(base)) {
                const scope = enterScope(this);
                const proxy = createProxy(base, void 0);
                let hasError = true;
                try {
                    result = recipe(proxy);
                    hasError = false;
                } finally{
                    if (hasError) revokeScope(scope);
                    else leaveScope(scope);
                }
                usePatchesInScope(scope, patchListener);
                return processResult(result, scope);
            } else if (!base || typeof base !== "object") {
                result = recipe(base);
                if (result === void 0) result = base;
                if (result === NOTHING) result = void 0;
                if (this.autoFreeze_) freeze(result, true);
                if (patchListener) {
                    const p = [];
                    const ip = [];
                    getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
                    patchListener(p, ip);
                }
                return result;
            } else die(1, base);
        };
        this.produceWithPatches = (base, recipe)=>{
            if (typeof base === "function") {
                return (state, ...args)=>this.produceWithPatches(state, (draft)=>base(draft, ...args));
            }
            let patches, inversePatches;
            const result = this.produce(base, recipe, (p, ip)=>{
                patches = p;
                inversePatches = ip;
            });
            return [
                result,
                patches,
                inversePatches
            ];
        };
        if (typeof config?.autoFreeze === "boolean") this.setAutoFreeze(config.autoFreeze);
        if (typeof config?.useStrictShallowCopy === "boolean") this.setUseStrictShallowCopy(config.useStrictShallowCopy);
        if (typeof config?.useStrictIteration === "boolean") this.setUseStrictIteration(config.useStrictIteration);
    }
    createDraft(base) {
        if (!isDraftable(base)) die(8);
        if (isDraft(base)) base = current(base);
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
    }
    finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_) die(9);
        const { scope_: scope } = state;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
    }
    /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */ setAutoFreeze(value) {
        this.autoFreeze_ = value;
    }
    /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */ setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
    }
    /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */ setUseStrictIteration(value) {
        this.useStrictIteration_ = value;
    }
    shouldUseStrictIteration() {
        return this.useStrictIteration_;
    }
    applyPatches(base, patches) {
        let i;
        for(i = patches.length - 1; i >= 0; i--){
            const patch = patches[i];
            if (patch.path.length === 0 && patch.op === "replace") {
                base = patch.value;
                break;
            }
        }
        if (i > -1) {
            patches = patches.slice(i + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
            return applyPatchesImpl(base, patches);
        }
        return this.produce(base, (draft)=>applyPatchesImpl(draft, patches));
    }
};
function createProxy(value, parent) {
    const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
    const scope = parent ? parent.scope_ : getCurrentScope();
    scope.drafts_.push(draft);
    return draft;
}
// src/core/current.ts
function current(value) {
    if (!isDraft(value)) die(10, value);
    return currentImpl(value);
}
function currentImpl(value) {
    if (!isDraftable(value) || isFrozen(value)) return value;
    const state = value[DRAFT_STATE];
    let copy;
    let strict = true;
    if (state) {
        if (!state.modified_) return state.base_;
        state.finalized_ = true;
        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
        strict = state.scope_.immer_.shouldUseStrictIteration();
    } else {
        copy = shallowCopy(value, true);
    }
    each(copy, (key, childValue)=>{
        set(copy, key, currentImpl(childValue));
    }, strict);
    if (state) {
        state.finalized_ = false;
    }
    return copy;
}
// src/plugins/patches.ts
function enablePatches() {
    const errorOffset = 16;
    if ("TURBOPACK compile-time truthy", 1) {
        errors.push('Sets cannot have "replace" patches.', function(op) {
            return "Unsupported patch operation: " + op;
        }, function(path) {
            return "Cannot apply patch, path doesn't resolve: " + path;
        }, "Patching reserved attributes like __proto__, prototype and constructor is not allowed");
    }
    const REPLACE = "replace";
    const ADD = "add";
    const REMOVE = "remove";
    function generatePatches_(state, basePath, patches, inversePatches) {
        switch(state.type_){
            case 0 /* Object */ :
            case 2 /* Map */ :
                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
            case 1 /* Array */ :
                return generateArrayPatches(state, basePath, patches, inversePatches);
            case 3 /* Set */ :
                return generateSetPatches(state, basePath, patches, inversePatches);
        }
    }
    function generateArrayPatches(state, basePath, patches, inversePatches) {
        let { base_, assigned_ } = state;
        let copy_ = state.copy_;
        if (copy_.length < base_.length) {
            ;
            [base_, copy_] = [
                copy_,
                base_
            ];
            [patches, inversePatches] = [
                inversePatches,
                patches
            ];
        }
        for(let i = 0; i < base_.length; i++){
            if (assigned_[i] && copy_[i] !== base_[i]) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REPLACE,
                    path,
                    // Need to maybe clone it, as it can in fact be the original value
                    // due to the base/copy inversion at the start of this function
                    value: clonePatchValueIfNeeded(copy_[i])
                });
                inversePatches.push({
                    op: REPLACE,
                    path,
                    value: clonePatchValueIfNeeded(base_[i])
                });
            }
        }
        for(let i = base_.length; i < copy_.length; i++){
            const path = basePath.concat([
                i
            ]);
            patches.push({
                op: ADD,
                path,
                // Need to maybe clone it, as it can in fact be the original value
                // due to the base/copy inversion at the start of this function
                value: clonePatchValueIfNeeded(copy_[i])
            });
        }
        for(let i = copy_.length - 1; base_.length <= i; --i){
            const path = basePath.concat([
                i
            ]);
            inversePatches.push({
                op: REMOVE,
                path
            });
        }
    }
    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        const { base_, copy_ } = state;
        each(state.assigned_, (key, assignedValue)=>{
            const origValue = get(base_, key);
            const value = get(copy_, key);
            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
            if (origValue === value && op === REPLACE) return;
            const path = basePath.concat(key);
            patches.push(op === REMOVE ? {
                op,
                path
            } : {
                op,
                path,
                value
            });
            inversePatches.push(op === ADD ? {
                op: REMOVE,
                path
            } : op === REMOVE ? {
                op: ADD,
                path,
                value: clonePatchValueIfNeeded(origValue)
            } : {
                op: REPLACE,
                path,
                value: clonePatchValueIfNeeded(origValue)
            });
        });
    }
    function generateSetPatches(state, basePath, patches, inversePatches) {
        let { base_, copy_ } = state;
        let i = 0;
        base_.forEach((value)=>{
            if (!copy_.has(value)) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REMOVE,
                    path,
                    value
                });
                inversePatches.unshift({
                    op: ADD,
                    path,
                    value
                });
            }
            i++;
        });
        i = 0;
        copy_.forEach((value)=>{
            if (!base_.has(value)) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: ADD,
                    path,
                    value
                });
                inversePatches.unshift({
                    op: REMOVE,
                    path,
                    value
                });
            }
            i++;
        });
    }
    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
            op: REPLACE,
            path: [],
            value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
            op: REPLACE,
            path: [],
            value: baseValue
        });
    }
    function applyPatches_(draft, patches) {
        patches.forEach((patch)=>{
            const { path, op } = patch;
            let base = draft;
            for(let i = 0; i < path.length - 1; i++){
                const parentType = getArchtype(base);
                let p = path[i];
                if (typeof p !== "string" && typeof p !== "number") {
                    p = "" + p;
                }
                if ((parentType === 0 /* Object */  || parentType === 1 /* Array */ ) && (p === "__proto__" || p === "constructor")) die(errorOffset + 3);
                if (typeof base === "function" && p === "prototype") die(errorOffset + 3);
                base = get(base, p);
                if (typeof base !== "object") die(errorOffset + 2, path.join("/"));
            }
            const type = getArchtype(base);
            const value = deepClonePatchValue(patch.value);
            const key = path[path.length - 1];
            switch(op){
                case REPLACE:
                    switch(type){
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            die(errorOffset);
                        default:
                            return base[key] = value;
                    }
                case ADD:
                    switch(type){
                        case 1 /* Array */ :
                            return key === "-" ? base.push(value) : base.splice(key, 0, value);
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            return base.add(value);
                        default:
                            return base[key] = value;
                    }
                case REMOVE:
                    switch(type){
                        case 1 /* Array */ :
                            return base.splice(key, 1);
                        case 2 /* Map */ :
                            return base.delete(key);
                        case 3 /* Set */ :
                            return base.delete(patch.value);
                        default:
                            return delete base[key];
                    }
                default:
                    die(errorOffset + 1, op);
            }
        });
        return draft;
    }
    function deepClonePatchValue(obj) {
        if (!isDraftable(obj)) return obj;
        if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(([k, v])=>[
                k,
                deepClonePatchValue(v)
            ]));
        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
        const cloned = Object.create(getPrototypeOf(obj));
        for(const key in obj)cloned[key] = deepClonePatchValue(obj[key]);
        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
    }
    function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
            return deepClonePatchValue(obj);
        } else return obj;
    }
    loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
    });
}
// src/plugins/mapset.ts
function enableMapSet() {
    class DraftMap extends Map {
        constructor(target, parent){
            super();
            this[DRAFT_STATE] = {
                type_: 2 /* Map */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                assigned_: void 0,
                base_: target,
                draft_: this,
                isManual_: false,
                revoked_: false
            };
        }
        get size() {
            return latest(this[DRAFT_STATE]).size;
        }
        has(key) {
            return latest(this[DRAFT_STATE]).has(key);
        }
        set(key, value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!latest(state).has(key) || latest(state).get(key) !== value) {
                prepareMapCopy(state);
                markChanged(state);
                state.assigned_.set(key, true);
                state.copy_.set(key, value);
                state.assigned_.set(key, true);
            }
            return this;
        }
        delete(key) {
            if (!this.has(key)) {
                return false;
            }
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareMapCopy(state);
            markChanged(state);
            if (state.base_.has(key)) {
                state.assigned_.set(key, false);
            } else {
                state.assigned_.delete(key);
            }
            state.copy_.delete(key);
            return true;
        }
        clear() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (latest(state).size) {
                prepareMapCopy(state);
                markChanged(state);
                state.assigned_ = /* @__PURE__ */ new Map();
                each(state.base_, (key)=>{
                    state.assigned_.set(key, false);
                });
                state.copy_.clear();
            }
        }
        forEach(cb, thisArg) {
            const state = this[DRAFT_STATE];
            latest(state).forEach((_value, key, _map)=>{
                cb.call(thisArg, this.get(key), key, this);
            });
        }
        get(key) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            const value = latest(state).get(key);
            if (state.finalized_ || !isDraftable(value)) {
                return value;
            }
            if (value !== state.base_.get(key)) {
                return value;
            }
            const draft = createProxy(value, state);
            prepareMapCopy(state);
            state.copy_.set(key, draft);
            return draft;
        }
        keys() {
            return latest(this[DRAFT_STATE]).keys();
        }
        values() {
            const iterator = this.keys();
            return {
                [Symbol.iterator]: ()=>this.values(),
                next: ()=>{
                    const r = iterator.next();
                    if (r.done) return r;
                    const value = this.get(r.value);
                    return {
                        done: false,
                        value
                    };
                }
            };
        }
        entries() {
            const iterator = this.keys();
            return {
                [Symbol.iterator]: ()=>this.entries(),
                next: ()=>{
                    const r = iterator.next();
                    if (r.done) return r;
                    const value = this.get(r.value);
                    return {
                        done: false,
                        value: [
                            r.value,
                            value
                        ]
                    };
                }
            };
        }
        [(DRAFT_STATE, Symbol.iterator)]() {
            return this.entries();
        }
    }
    function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
    }
    function prepareMapCopy(state) {
        if (!state.copy_) {
            state.assigned_ = /* @__PURE__ */ new Map();
            state.copy_ = new Map(state.base_);
        }
    }
    class DraftSet extends Set {
        constructor(target, parent){
            super();
            this[DRAFT_STATE] = {
                type_: 3 /* Set */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                base_: target,
                draft_: this,
                drafts_: /* @__PURE__ */ new Map(),
                revoked_: false,
                isManual_: false
            };
        }
        get size() {
            return latest(this[DRAFT_STATE]).size;
        }
        has(value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!state.copy_) {
                return state.base_.has(value);
            }
            if (state.copy_.has(value)) return true;
            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
            return false;
        }
        add(value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!this.has(value)) {
                prepareSetCopy(state);
                markChanged(state);
                state.copy_.add(value);
            }
            return this;
        }
        delete(value) {
            if (!this.has(value)) {
                return false;
            }
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            markChanged(state);
            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);
        }
        clear() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (latest(state).size) {
                prepareSetCopy(state);
                markChanged(state);
                state.copy_.clear();
            }
        }
        values() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            return state.copy_.values();
        }
        entries() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            return state.copy_.entries();
        }
        keys() {
            return this.values();
        }
        [(DRAFT_STATE, Symbol.iterator)]() {
            return this.values();
        }
        forEach(cb, thisArg) {
            const iterator = this.values();
            let result = iterator.next();
            while(!result.done){
                cb.call(thisArg, result.value, result.value, this);
                result = iterator.next();
            }
        }
    }
    function proxySet_(target, parent) {
        return new DraftSet(target, parent);
    }
    function prepareSetCopy(state) {
        if (!state.copy_) {
            state.copy_ = /* @__PURE__ */ new Set();
            state.base_.forEach((value)=>{
                if (isDraftable(value)) {
                    const draft = createProxy(value, state);
                    state.drafts_.set(value, draft);
                    state.copy_.add(draft);
                } else {
                    state.copy_.add(value);
                }
            });
        }
    }
    function assertUnrevoked(state) {
        if (state.revoked_) die(3, JSON.stringify(latest(state)));
    }
    loadPlugin("MapSet", {
        proxyMap_,
        proxySet_
    });
}
// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(immer);
var setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(immer);
var setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(immer);
var applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer);
var createDraft = /* @__PURE__ */ immer.createDraft.bind(immer);
var finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer);
function castDraft(value) {
    return value;
}
function castImmutable(value) {
    return value;
}
;
 //# sourceMappingURL=immer.mjs.map
}),
"[project]/node_modules/is-hotkey/lib/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Constants.
 */ var IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
var MODIFIERS = {
    alt: 'altKey',
    control: 'ctrlKey',
    meta: 'metaKey',
    shift: 'shiftKey'
};
var ALIASES = {
    add: '+',
    break: 'pause',
    cmd: 'meta',
    command: 'meta',
    ctl: 'control',
    ctrl: 'control',
    del: 'delete',
    down: 'arrowdown',
    esc: 'escape',
    ins: 'insert',
    left: 'arrowleft',
    mod: IS_MAC ? 'meta' : 'control',
    opt: 'alt',
    option: 'alt',
    return: 'enter',
    right: 'arrowright',
    space: ' ',
    spacebar: ' ',
    up: 'arrowup',
    win: 'meta',
    windows: 'meta'
};
var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    ' ': 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ';': 186,
    '=': 187,
    ',': 188,
    '-': 189,
    '.': 190,
    '/': 191,
    '`': 192,
    '[': 219,
    '\\': 220,
    ']': 221,
    '\'': 222
};
for(var f = 1; f < 20; f++){
    CODES['f' + f] = 111 + f;
}
/**
 * Is hotkey?
 */ function isHotkey(hotkey, options, event) {
    if (options && !('byKey' in options)) {
        event = options;
        options = null;
    }
    if (!Array.isArray(hotkey)) {
        hotkey = [
            hotkey
        ];
    }
    var array = hotkey.map(function(string) {
        return parseHotkey(string, options);
    });
    var check = function check(e) {
        return array.some(function(object) {
            return compareHotkey(object, e);
        });
    };
    var ret = event == null ? check : check(event);
    return ret;
}
function isCodeHotkey(hotkey, event) {
    return isHotkey(hotkey, event);
}
function isKeyHotkey(hotkey, event) {
    return isHotkey(hotkey, {
        byKey: true
    }, event);
}
/**
 * Parse.
 */ function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    // Special case to handle the `+` key since we use it as a separator.
    hotkey = hotkey.replace('++', '+add');
    var values = hotkey.split('+');
    var length = values.length;
    // Ensure that all the modifiers are set to false unless the hotkey has them.
    for(var k in MODIFIERS){
        ret[MODIFIERS[k]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
        for(var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var value = _step.value;
            var optional = value.endsWith('?') && value.length > 1;
            if (optional) {
                value = value.slice(0, -1);
            }
            var name = toKeyName(value);
            var modifier = MODIFIERS[name];
            if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name]) {
                throw new TypeError('Unknown modifier: "' + value + '"');
            }
            if (length === 1 || !modifier) {
                if (byKey) {
                    ret.key = name;
                } else {
                    ret.which = toKeyCode(value);
                }
            }
            if (modifier) {
                ret[modifier] = optional ? null : true;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return ret;
}
/**
 * Compare.
 */ function compareHotkey(object, event) {
    for(var key in object){
        var expected = object[key];
        var actual = void 0;
        if (expected == null) {
            continue;
        }
        if (key === 'key' && event.key != null) {
            actual = event.key.toLowerCase();
        } else if (key === 'which') {
            actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
            actual = event[key];
        }
        if (actual == null && expected === false) {
            continue;
        }
        if (actual !== expected) {
            return false;
        }
    }
    return true;
}
/**
 * Utils.
 */ function toKeyCode(name) {
    name = toKeyName(name);
    var code = CODES[name] || name.toUpperCase().charCodeAt(0);
    return code;
}
function toKeyName(name) {
    name = name.toLowerCase();
    name = ALIASES[name] || name;
    return name;
}
/**
 * Export.
 */ exports.default = isHotkey;
exports.isHotkey = isHotkey;
exports.isCodeHotkey = isCodeHotkey;
exports.isKeyHotkey = isKeyHotkey;
exports.parseHotkey = parseHotkey;
exports.compareHotkey = compareHotkey;
exports.toKeyCode = toKeyCode;
exports.toKeyName = toKeyName;
}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resizeObservers",
    ()=>resizeObservers
]);
var resizeObservers = [];
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hasActiveObservations",
    ()=>hasActiveObservations
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)");
;
var hasActiveObservations = function() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].some(function(ro) {
        return ro.activeTargets.length > 0;
    });
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hasSkippedObservations",
    ()=>hasSkippedObservations
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)");
;
var hasSkippedObservations = function() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].some(function(ro) {
        return ro.skippedTargets.length > 0;
    });
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deliverResizeLoopError",
    ()=>deliverResizeLoopError
]);
var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function() {
    var event;
    if (typeof ErrorEvent === 'function') {
        event = new ErrorEvent('error', {
            message: msg
        });
    } else {
        event = document.createEvent('Event');
        event.initEvent('error', false, false);
        event.message = msg;
    }
    window.dispatchEvent(event);
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ResizeObserverBoxOptions",
    ()=>ResizeObserverBoxOptions
]);
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions) {
    ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
    ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
    ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/freeze.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "freeze",
    ()=>freeze
]);
var freeze = function(obj) {
    return Object.freeze(obj);
};
}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ResizeObserverSize",
    ()=>ResizeObserverSize
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/freeze.js [app-client] (ecmascript)");
;
var ResizeObserverSize = function() {
    function ResizeObserverSize(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])(this);
    }
    return ResizeObserverSize;
}();
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DOMRectReadOnly",
    ()=>DOMRectReadOnly
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/freeze.js [app-client] (ecmascript)");
;
var DOMRectReadOnly = function() {
    function DOMRectReadOnly(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])(this);
    }
    DOMRectReadOnly.prototype.toJSON = function() {
        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return {
            x: x,
            y: y,
            top: top,
            right: right,
            bottom: bottom,
            left: left,
            width: width,
            height: height
        };
    };
    DOMRectReadOnly.fromRect = function(rectangle) {
        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    };
    return DOMRectReadOnly;
}();
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/element.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isElement",
    ()=>isElement,
    "isHidden",
    ()=>isHidden,
    "isReplacedElement",
    ()=>isReplacedElement,
    "isSVG",
    ()=>isSVG
]);
var isSVG = function(target) {
    return target instanceof SVGElement && 'getBBox' in target;
};
var isHidden = function(target) {
    if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
    }
    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
    return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
    var _a;
    if (obj instanceof Element) {
        return true;
    }
    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
    return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
    switch(target.tagName){
        case 'INPUT':
            if (target.type !== 'image') {
                break;
            }
        case 'VIDEO':
        case 'AUDIO':
        case 'EMBED':
        case 'OBJECT':
        case 'CANVAS':
        case 'IFRAME':
        case 'IMG':
            return true;
    }
    return false;
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/global.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "global",
    ()=>global
]);
var global = typeof window !== 'undefined' ? window : {};
}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "calculateBoxSize",
    ()=>calculateBoxSize,
    "calculateBoxSizes",
    ()=>calculateBoxSizes
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverBoxOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$DOMRectReadOnly$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/freeze.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/global.js [app-client] (ecmascript)");
;
;
;
;
;
;
var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].navigator && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].navigator.userAgent);
var parseDimension = function(pixel) {
    return parseFloat(pixel || '0');
};
var size = function(inlineSize, blockSize, switchSizes) {
    if (inlineSize === void 0) {
        inlineSize = 0;
    }
    if (blockSize === void 0) {
        blockSize = 0;
    }
    if (switchSizes === void 0) {
        switchSizes = false;
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverSize"]((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])({
    devicePixelContentBoxSize: size(),
    borderBoxSize: size(),
    contentBoxSize: size(),
    contentRect: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$DOMRectReadOnly$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMRectReadOnly"](0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
    if (forceRecalculation === void 0) {
        forceRecalculation = false;
    }
    if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHidden"])(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
    }
    var cs = getComputedStyle(target);
    var svg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSVG"])(target) && target.ownerSVGElement && target.getBBox();
    var removePadding = !IE && cs.boxSizing === 'border-box';
    var switchSizes = verticalRegexp.test(cs.writingMode || '');
    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorderArea = borderLeft + borderRight;
    var verticalBorderArea = borderTop + borderBottom;
    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
    var boxes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$DOMRectReadOnly$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMRectReadOnly"](paddingLeft, paddingTop, contentWidth, contentHeight)
    });
    cache.set(target, boxes);
    return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
    switch(observedBox){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverBoxOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverBoxOptions"].DEVICE_PIXEL_CONTENT_BOX:
            return devicePixelContentBoxSize;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverBoxOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverBoxOptions"].BORDER_BOX:
            return borderBoxSize;
        default:
            return contentBoxSize;
    }
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ResizeObserverEntry",
    ()=>ResizeObserverEntry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/freeze.js [app-client] (ecmascript)");
;
;
var ResizeObserverEntry = function() {
    function ResizeObserverEntry(target) {
        var boxes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateBoxSizes"])(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])([
            boxes.borderBoxSize
        ]);
        this.contentBoxSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])([
            boxes.contentBoxSize
        ]);
        this.devicePixelContentBoxSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$freeze$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freeze"])([
            boxes.devicePixelContentBoxSize
        ]);
    }
    return ResizeObserverEntry;
}();
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "calculateDepthForNode",
    ()=>calculateDepthForNode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/element.js [app-client] (ecmascript)");
;
var calculateDepthForNode = function(node) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHidden"])(node)) {
        return Infinity;
    }
    var depth = 0;
    var parent = node.parentNode;
    while(parent){
        depth += 1;
        parent = parent.parentNode;
    }
    return depth;
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "broadcastActiveObservations",
    ()=>broadcastActiveObservations
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverEntry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateDepthForNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js [app-client] (ecmascript)");
;
;
;
;
var broadcastActiveObservations = function() {
    var shallowestDepth = Infinity;
    var callbacks = [];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
            return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
            var entry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverEntry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverEntry"](ot.target);
            var targetDepth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateDepthForNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateDepthForNode"])(ot.target);
            entries.push(entry);
            ot.lastReportedSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateBoxSize"])(ot.target, ot.observedBox);
            if (targetDepth < shallowestDepth) {
                shallowestDepth = targetDepth;
            }
        });
        callbacks.push(function resizeObserverCallback() {
            ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
    });
    for(var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++){
        var callback = callbacks_1[_i];
        callback();
    }
    return shallowestDepth;
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "gatherActiveObservationsAtDepth",
    ()=>gatherActiveObservationsAtDepth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateDepthForNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js [app-client] (ecmascript)");
;
;
var gatherActiveObservationsAtDepth = function(depth) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
            if (ot.isActive()) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateDepthForNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateDepthForNode"])(ot.target) > depth) {
                    ro.activeTargets.push(ot);
                } else {
                    ro.skippedTargets.push(ot);
                }
            }
        });
    });
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/process.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "process",
    ()=>process
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$hasActiveObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$hasSkippedObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$deliverResizeLoopError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$broadcastActiveObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$gatherActiveObservationsAtDepth$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js [app-client] (ecmascript)");
;
;
;
;
;
var process = function() {
    var depth = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$gatherActiveObservationsAtDepth$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gatherActiveObservationsAtDepth"])(depth);
    while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$hasActiveObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasActiveObservations"])()){
        depth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$broadcastActiveObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcastActiveObservations"])();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$gatherActiveObservationsAtDepth$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gatherActiveObservationsAtDepth"])(depth);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$hasSkippedObservations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasSkippedObservations"])()) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$deliverResizeLoopError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deliverResizeLoopError"])();
    }
    return depth > 0;
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "queueMicroTask",
    ()=>queueMicroTask
]);
var trigger;
var callbacks = [];
var notify = function() {
    return callbacks.splice(0).forEach(function(cb) {
        return cb();
    });
};
var queueMicroTask = function(callback) {
    if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode('');
        var config = {
            characterData: true
        };
        new MutationObserver(function() {
            return notify();
        }).observe(el_1, config);
        trigger = function() {
            el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
    }
    callbacks.push(callback);
    trigger();
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "queueResizeObserver",
    ()=>queueResizeObserver
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$queueMicroTask$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js [app-client] (ecmascript)");
;
var queueResizeObserver = function(cb) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$queueMicroTask$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["queueMicroTask"])(function ResizeObserver() {
        requestAnimationFrame(cb);
    });
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/utils/scheduler.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "scheduler",
    ()=>scheduler,
    "updateCount",
    ()=>updateCount
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/global.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$queueResizeObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js [app-client] (ecmascript)");
;
;
;
var watching = 0;
var isWatching = function() {
    return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = {
    attributes: true,
    characterData: true,
    childList: true,
    subtree: true
};
var events = [
    'resize',
    'load',
    'transitionend',
    'animationend',
    'animationstart',
    'animationiteration',
    'keyup',
    'keydown',
    'mouseup',
    'mousedown',
    'mouseover',
    'mouseout',
    'blur',
    'focus'
];
var time = function(timeout) {
    if (timeout === void 0) {
        timeout = 0;
    }
    return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
    function Scheduler() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
            return _this.schedule();
        };
    }
    Scheduler.prototype.run = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
            timeout = CATCH_PERIOD;
        }
        if (scheduled) {
            return;
        }
        scheduled = true;
        var until = time(timeout);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$queueResizeObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["queueResizeObserver"])(function() {
            var elementsHaveResized = false;
            try {
                elementsHaveResized = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["process"])();
            } finally{
                scheduled = false;
                timeout = until - time();
                if (!isWatching()) {
                    return;
                }
                if (elementsHaveResized) {
                    _this.run(1000);
                } else if (timeout > 0) {
                    _this.run(timeout);
                } else {
                    _this.start();
                }
            }
        });
    };
    Scheduler.prototype.schedule = function() {
        this.stop();
        this.run();
    };
    Scheduler.prototype.observe = function() {
        var _this = this;
        var cb = function() {
            return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].addEventListener('DOMContentLoaded', cb);
    };
    Scheduler.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
            this.stopped = false;
            this.observer = new MutationObserver(this.listener);
            this.observe();
            events.forEach(function(name) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].addEventListener(name, _this.listener, true);
            });
        }
    };
    Scheduler.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
            this.observer && this.observer.disconnect();
            events.forEach(function(name) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["global"].removeEventListener(name, _this.listener, true);
            });
            this.stopped = true;
        }
    };
    return Scheduler;
}();
var scheduler = new Scheduler();
var updateCount = function(n) {
    !watching && n > 0 && scheduler.start();
    watching += n;
    !watching && scheduler.stop();
};
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObservation.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ResizeObservation",
    ()=>ResizeObservation
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverBoxOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/element.js [app-client] (ecmascript)");
;
;
;
var skipNotifyOnElement = function(target) {
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSVG"])(target) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReplacedElement"])(target) && getComputedStyle(target).display === 'inline';
};
var ResizeObservation = function() {
    function ResizeObservation(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverBoxOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverBoxOptions"].CONTENT_BOX;
        this.lastReportedSize = {
            inlineSize: 0,
            blockSize: 0
        };
    }
    ResizeObservation.prototype.isActive = function() {
        var size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$algorithms$2f$calculateBoxSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calculateBoxSize"])(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
            this.lastReportedSize = size;
        }
        if (this.lastReportedSize.inlineSize !== size.inlineSize || this.lastReportedSize.blockSize !== size.blockSize) {
            return true;
        }
        return false;
    };
    return ResizeObservation;
}();
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ResizeObserverDetail",
    ()=>ResizeObserverDetail
]);
var ResizeObserverDetail = function() {
    function ResizeObserverDetail(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
    }
    return ResizeObserverDetail;
}();
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverController.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ResizeObserverController",
    ()=>ResizeObserverController
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/scheduler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObservation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/ResizeObservation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverDetail$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js [app-client] (ecmascript)");
;
;
;
;
var observerMap = new WeakMap();
var getObservationIndex = function(observationTargets, target) {
    for(var i = 0; i < observationTargets.length; i += 1){
        if (observationTargets[i].target === target) {
            return i;
        }
    }
    return -1;
};
var ResizeObserverController = function() {
    function ResizeObserverController() {}
    ResizeObserverController.connect = function(resizeObserver, callback) {
        var detail = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverDetail$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverDetail"](resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
    };
    ResizeObserverController.observe = function(resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
            firstObservation && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].push(detail);
            detail.observationTargets.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObservation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObservation"](target, options && options.box));
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateCount"])(1);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scheduler"].schedule();
        }
    };
    ResizeObserverController.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
            lastObservation && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].splice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$resizeObservers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeObservers"].indexOf(detail), 1);
            detail.observationTargets.splice(index, 1);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateCount"])(-1);
        }
    };
    ResizeObserverController.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot) {
            return _this.unobserve(resizeObserver, ot.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
    };
    return ResizeObserverController;
}();
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/ResizeObserver.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ResizeObserver",
    ()=>ResizeObserver
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverController$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverController.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/utils/element.js [app-client] (ecmascript)");
;
;
var ResizeObserver = function() {
    function ResizeObserver(callback) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== 'function') {
            throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverController$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverController"].connect(this, callback);
    }
    ResizeObserver.prototype.observe = function(target, options) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(target)) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverController$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverController"].observe(this, target, options);
    };
    ResizeObserver.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$utils$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(target)) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverController$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverController"].unobserve(this, target);
    };
    ResizeObserver.prototype.disconnect = function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverController$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResizeObserverController"].disconnect(this);
    };
    ResizeObserver.toString = function() {
        return 'function ResizeObserver () { [polyfill code] }';
    };
    return ResizeObserver;
}();
;
}),
"[project]/node_modules/@juggle/resize-observer/lib/exports/resize-observer.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserver.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverEntry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$juggle$2f$resize$2d$observer$2f$lib$2f$ResizeObserverSize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js [app-client] (ecmascript)");
;
;
;
}),
"[project]/node_modules/@udecode/react-hotkeys/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HotkeysProvider",
    ()=>HotkeysProvider,
    "Key",
    ()=>Key,
    "isHotkeyPressed",
    ()=>isHotkeyPressed,
    "useHotkeys",
    ()=>useHotkeys,
    "useHotkeysContext",
    ()=>useHotkeysContext,
    "useRecordHotkeys",
    ()=>useRecordHotkeys
]);
// src/internal/HotkeysProvider.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
;
;
var BoundHotkeysProxyProvider = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(void 0);
var useBoundHotkeysProxy = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(BoundHotkeysProxyProvider);
};
function BoundHotkeysProxyProviderProvider({ addHotkey, children, removeHotkey }) {
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(BoundHotkeysProxyProvider.Provider, {
        value: {
            addHotkey,
            removeHotkey
        }
    }, children);
}
// src/internal/deepEqual.ts
function deepEqual(x, y) {
    return x && y && typeof x === "object" && typeof y === "object" ? Object.keys(x).length === Object.keys(y).length && Object.keys(x).reduce((isEqual, key)=>isEqual && deepEqual(x[key], y[key]), true) : x === y;
}
// src/internal/HotkeysProvider.tsx
var HotkeysContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])({
    activeScopes: [],
    // This array has to be empty instead of containing '*' as default, to check if the provider is set or not
    disableScope: ()=>{},
    enableScope: ()=>{},
    hotkeys: [],
    toggleScope: ()=>{}
});
var useHotkeysContext = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(HotkeysContext);
};
var HotkeysProvider = ({ children, initiallyActiveScopes = [
    "*"
] })=>{
    const [internalActiveScopes, setInternalActiveScopes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(initiallyActiveScopes);
    const [boundHotkeys, setBoundHotkeys] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])([]);
    const enableScope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "HotkeysProvider.useCallback[enableScope]": (scope)=>{
            setInternalActiveScopes({
                "HotkeysProvider.useCallback[enableScope]": (prev)=>{
                    if (prev.includes("*")) {
                        return [
                            scope
                        ];
                    }
                    return Array.from(/* @__PURE__ */ new Set([
                        ...prev,
                        scope
                    ]));
                }
            }["HotkeysProvider.useCallback[enableScope]"]);
        }
    }["HotkeysProvider.useCallback[enableScope]"], []);
    const disableScope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "HotkeysProvider.useCallback[disableScope]": (scope)=>{
            setInternalActiveScopes({
                "HotkeysProvider.useCallback[disableScope]": (prev)=>{
                    return prev.filter({
                        "HotkeysProvider.useCallback[disableScope]": (s)=>s !== scope
                    }["HotkeysProvider.useCallback[disableScope]"]);
                }
            }["HotkeysProvider.useCallback[disableScope]"]);
        }
    }["HotkeysProvider.useCallback[disableScope]"], []);
    const toggleScope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "HotkeysProvider.useCallback[toggleScope]": (scope)=>{
            setInternalActiveScopes({
                "HotkeysProvider.useCallback[toggleScope]": (prev)=>{
                    if (prev.includes(scope)) {
                        return prev.filter({
                            "HotkeysProvider.useCallback[toggleScope]": (s)=>s !== scope
                        }["HotkeysProvider.useCallback[toggleScope]"]);
                    } else {
                        if (prev.includes("*")) {
                            return [
                                scope
                            ];
                        }
                        return Array.from(/* @__PURE__ */ new Set([
                            ...prev,
                            scope
                        ]));
                    }
                }
            }["HotkeysProvider.useCallback[toggleScope]"]);
        }
    }["HotkeysProvider.useCallback[toggleScope]"], []);
    const addBoundHotkey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "HotkeysProvider.useCallback[addBoundHotkey]": (hotkey)=>{
            setBoundHotkeys({
                "HotkeysProvider.useCallback[addBoundHotkey]": (prev)=>[
                        ...prev,
                        hotkey
                    ]
            }["HotkeysProvider.useCallback[addBoundHotkey]"]);
        }
    }["HotkeysProvider.useCallback[addBoundHotkey]"], []);
    const removeBoundHotkey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "HotkeysProvider.useCallback[removeBoundHotkey]": (hotkey)=>{
            setBoundHotkeys({
                "HotkeysProvider.useCallback[removeBoundHotkey]": (prev)=>prev.filter({
                        "HotkeysProvider.useCallback[removeBoundHotkey]": (h)=>!deepEqual(h, hotkey)
                    }["HotkeysProvider.useCallback[removeBoundHotkey]"])
            }["HotkeysProvider.useCallback[removeBoundHotkey]"]);
        }
    }["HotkeysProvider.useCallback[removeBoundHotkey]"], []);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(HotkeysContext.Provider, {
        value: {
            activeScopes: internalActiveScopes,
            disableScope,
            enableScope,
            hotkeys: boundHotkeys,
            toggleScope
        }
    }, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(BoundHotkeysProxyProviderProvider, {
        addHotkey: addBoundHotkey,
        removeHotkey: removeBoundHotkey
    }, children));
};
// src/internal/parseHotkeys.ts
var reservedModifierKeywords = /* @__PURE__ */ new Set([
    "shift",
    "alt",
    "meta",
    "mod",
    "ctrl",
    "control"
]);
var mappedKeys = {
    AltLeft: "alt",
    AltRight: "alt",
    ControlLeft: "ctrl",
    ControlRight: "ctrl",
    MetaLeft: "meta",
    MetaRight: "meta",
    OSLeft: "meta",
    OSRight: "meta",
    ShiftLeft: "shift",
    ShiftRight: "shift",
    down: "arrowdown",
    esc: "escape",
    left: "arrowleft",
    return: "enter",
    right: "arrowright",
    up: "arrowup"
};
function mapKey(key) {
    return (mappedKeys[key.trim()] || key.trim()).toLowerCase().replace(/key|digit|numpad/, "");
}
function isHotkeyModifier(key) {
    return reservedModifierKeywords.has(key);
}
function parseKeysHookInput(keys, delimiter = ",") {
    return keys.toLowerCase().split(delimiter);
}
function parseHotkey(hotkey, splitKey = "+", useKey = false, description) {
    const keys = hotkey.toLocaleLowerCase().split(splitKey).map((k)=>mapKey(k));
    const modifiers = {
        alt: keys.includes("alt"),
        ctrl: keys.includes("ctrl") || keys.includes("control"),
        meta: keys.includes("meta"),
        mod: keys.includes("mod"),
        shift: keys.includes("shift"),
        useKey
    };
    const singleCharKeys = keys.filter((k)=>!reservedModifierKeywords.has(k));
    return __spreadProps(__spreadValues({}, modifiers), {
        description,
        keys: singleCharKeys
    });
}
// src/internal/isHotkeyPressed.ts
(()=>{
    if (typeof document !== "undefined") {
        document.addEventListener("keydown", (e)=>{
            if (e.code === void 0) {
                return;
            }
            pushToCurrentlyPressedKeys([
                mapKey(e.code)
            ]);
        });
        document.addEventListener("keyup", (e)=>{
            if (e.code === void 0) {
                return;
            }
            removeFromCurrentlyPressedKeys([
                mapKey(e.code)
            ]);
        });
    }
    if (typeof window !== "undefined") {
        window.addEventListener("blur", ()=>{
            currentlyPressedKeys.clear();
        });
    }
})();
var currentlyPressedKeys = /* @__PURE__ */ new Set();
function isReadonlyArray(value) {
    return Array.isArray(value);
}
function isHotkeyPressed(key, delimiter = ",") {
    const hotkeyArray = isReadonlyArray(key) ? key : key.split(delimiter);
    return hotkeyArray.every((hotkey)=>currentlyPressedKeys.has(hotkey.trim().toLowerCase()));
}
function pushToCurrentlyPressedKeys(key) {
    const hotkeyArray = Array.isArray(key) ? key : [
        key
    ];
    if (currentlyPressedKeys.has("meta")) {
        currentlyPressedKeys.forEach((key2)=>!isHotkeyModifier(key2) && currentlyPressedKeys.delete(key2.toLowerCase()));
    }
    hotkeyArray.forEach((hotkey)=>currentlyPressedKeys.add(hotkey.toLowerCase()));
}
function removeFromCurrentlyPressedKeys(key) {
    const hotkeyArray = Array.isArray(key) ? key : [
        key
    ];
    if (key === "meta") {
        currentlyPressedKeys.clear();
    } else {
        hotkeyArray.forEach((hotkey)=>currentlyPressedKeys.delete(hotkey.toLowerCase()));
    }
}
// src/internal/key.ts
var Key = {
    /** Changes the input mode on an external audio/video receiver (AVR) unit. */ AVRInput: "AVRInput",
    /** Toggles the power on an external AVR unit. */ AVRPower: "AVRPower",
    /**
   * The Accept, Commit, or OK key or button. Accepts the currently selected
   * option or input method sequence conversion.
   */ Accept: "Accept",
    /** The numeric keypad's addition key, +. */ Add: "Add",
    /** The Again key. Redoes or repeats a previous action. */ Again: "Again",
    /**
   * The All Candidates key, which starts multi-candidate mode, in which
   * multiple candidates are displayed for the ongoing input.
   */ AllCandidates: "AllCandidates",
    /** The Alphanumeric key. */ Alphanumeric: "Alphanumeric",
    /**
   * The Alt (Alternative) key. This is the Option  key on Mac, or the Alt key
   * on Windows.
   */ Alt: "Alt",
    /**
   * The AltGr or AltGraph (Alternate Graphics) key. Enables the ISO Level 3
   * shift modifier (where Shift is the level 2 modifier).
   */ AltGraph: "AltGraph",
    /**
   * Presents a list of recently-used applications which lets the user change
   * apps quickly.
   */ AppSwitch: "AppSwitch",
    /** The down arrow key. */ ArrowDown: "ArrowDown",
    /** The left arrow key. */ ArrowLeft: "ArrowLeft",
    /** The right arrow key. */ ArrowRight: "ArrowRight",
    /** The up arrow key. */ ArrowUp: "ArrowUp",
    /** The Attn (Attention) key. */ Attn: "Attn",
    /** Adjusts audio balance toward the left. */ AudioBalanceLeft: "AudioBalanceLeft",
    /** Adjusts audio balance twoard the right. */ AudioBalanceRight: "AudioBalanceRight",
    /**
   * Reduces bass boosting or cycles downward through bass boost modes or
   * states.
   */ AudioBassBoostDown: "AudioBassBoostDown",
    /** Toggles bass boosting on and off. */ AudioBassBoostToggle: "AudioBassBoostToggle",
    /**
   * Increases the amoung of bass boosting, or cycles upward through a set of
   * bass boost modes or states.
   */ AudioBassBoostUp: "AudioBassBoostUp",
    /** Decreases the amount of bass. */ AudioBassDown: "AudioBassDown",
    /** Increases the amount of bass. */ AudioBassUp: "AudioBassUp",
    /** Adjusts the audio fader toward the front. */ AudioFaderFront: "AudioFaderFront",
    /** Adjustts the audio fader toward the rear. */ AudioFaderRear: "AudioFaderRear",
    /** Selects the next available surround sound mode. */ AudioSurroundModeNext: "AudioSurroundModeNext",
    /** Decreases the amount of treble. */ AudioTrebleDown: "AudioTrebleDown",
    /** Increases the amount of treble. */ AudioTrebleUp: "AudioTrebleUp",
    /** Decreases the audio volume. */ AudioVolumeDown: "AudioVolumeDown",
    /** Mutes the audio. */ AudioVolumeMute: "AudioVolumeMute",
    /** Increases the audio volume. */ AudioVolumeUp: "AudioVolumeUp",
    /** The Backspace key. This key is labeled Delete on Mac keyboards. */ Backspace: "Backspace",
    /**
   * The Brightness Down key. Typically used to reduce the brightness of the
   * display.
   */ BrightnessDown: "BrightnessDown",
    /** The Brightness Up key. Typically increases the brightness of the display. */ BrightnessUp: "BrightnessUp",
    /**
   * Navigates to the previous content or page in the current Web view's
   * history.
   */ BrowserBack: "BrowserBack",
    /** Opens the user's list of bookmarks/favorites. */ BrowserFavorites: "BrowserFavorites",
    /** Navigates to the next content or page in the current Web view's history. */ BrowserForward: "BrowserForward",
    /** Navigates to the user's preferred home page. */ BrowserHome: "BrowserHome",
    /** Refreshes the current page or contentl. */ BrowserRefresh: "BrowserRefresh",
    /**
   * Activates the user's preferred search engine or the search interface within
   * their browser.
   */ BrowserSearch: "BrowserSearch",
    /** Stops loading the currently displayed Web view or content. */ BrowserStop: "BrowserStop",
    /** The Call key; dials the number which has been entered. */ Call: "Call",
    /** The Camera key; activates the camera. */ Camera: "Camera",
    /** The Focus key; focuses the camera. */ CameraFocus: "CameraFocus",
    /** The Cancel key. */ Cancel: "Cancel",
    /**
   * The Caps Lock key. Toggles the capital character lock on and off for
   * subsequent input.
   */ CapsLock: "CapsLock",
    /** Switches to the previous channel. */ ChannelDown: "ChannelDown",
    /** Switches to the next channel. */ ChannelUp: "ChannelUp",
    /** The Clear key. Removes the currently selected input. */ Clear: "Clear",
    /** Closes the current document or message. Must not exit the application. */ Close: "Close",
    /** Toggles closed captioning on and off. */ ClosedCaptionToggle: "ClosedCaptionToggle",
    /**
   * The Code Input key, which enables code input mode, which lets the user
   * enter characters by typing their code points (their Unicode character
   * numbers, typically).
   */ CodeInput: "CodeInput",
    /**
   * General-purpose media function key, color-coded red; this has index 0 among
   * the colored keys.
   */ ColorF0Red: "ColorF0Red",
    /**
   * General-purpose media funciton key, color-coded green; this has index 1
   * among the colored keys.
   */ ColorF1Green: "ColorF1Green",
    /**
   * General-purpose media funciton key, color-coded yellow; this has index 2
   * among the colored keys.
   */ ColorF2Yellow: "ColorF2Yellow",
    /**
   * General-purpose media funciton key, color-coded blue; this has index 3
   * among the colored keys.
   */ ColorF3Blue: "ColorF3Blue",
    /**
   * General-purpose media funciton key, color-coded grey; this has index 4
   * among the colored keys.
   */ ColorF4Grey: "ColorF4Grey",
    /**
   * General-purpose media funciton key, color-coded brown; this has index 5
   * among the colored keys.
   */ ColorF5Brown: "ColorF5Brown",
    /** The Compose key. */ Compose: "Compose",
    /**
   * Shows the context menu. Typically found between the Windows (or OS) key and
   * the Control key on the right side of the keyboard.
   */ ContextMenu: "ContextMenu",
    /** The Control, Ctrl, or Ctl key. Allows typing control characters. */ Control: "Control",
    /**
   * The Convert key, which instructs the IME to convert the current input
   * method sequence into the resulting character.
   */ Convert: "Convert",
    /** The Copy key (on certain extended keyboards). */ Copy: "Copy",
    /** The Cursor Select key, CrSel. */ CrSel: "CrSel",
    /** The Cut key (on certain extended keyboards). */ Cut: "Cut",
    /** Switches the input source to the Digital Video Recorder (DVR). */ DVR: "DVR",
    /**
   * A dead "combining" key; that is, a key which is used in tandem with other
   * keys to generate accented and other modified characters. If pressed by
   * itself, it doesn't generate a character. If you wish to identify which
   * specific dead key was pressed (in cases where more than one exists), you
   * can do so by examining the KeyboardEvent's associated compositionupdate
   * event's data property.
   */ Dead: "Dead",
    /**
   * The decimal point key (typically . or , depending on the region. In newer
   * browsers, this value to simply be the character generated by the decimal
   * key (one of those two characters). [1]
   */ Decimal: "Decimal",
    /** The Delete key, Del. */ Delete: "Delete",
    /**
   * Adjusts the brightness of the device by toggling between two brightness
   * levels or by cycling among multiple brightness levels.
   */ Dimmer: "Dimmer",
    /** Cycles among video sources. */ DisplaySwap: "DisplaySwap",
    /** The numeric keypad's division key, /. */ Divide: "Divide",
    /**
   * The Eisu key. This key's purpose is defined by the IME, but may be used to
   * close the IME.
   */ Eisu: "Eisu",
    /**
   * The Eject key. Ejects removable media (or toggles an optical storage device
   * tray open and closed).
   */ Eject: "Eject",
    /** The End key. Moves to the end of content. */ End: "End",
    /** The End Call or Hang Up button. */ EndCall: "EndCall",
    /** The Enter or  key (sometimes labeled Return). */ Enter: "Enter",
    /**
   * Erase to End of Field. Deletes all characters from the current cursor
   * position to the end of the current field.
   */ EraseEof: "EraseEof",
    /**
   * The Esc (Escape) key. Typically used as an exit, cancel, or "escape this
   * operation" button. Historically, the Escape character was used to signal
   * the start of a special control sequence of characters called an "escape
   * sequence."
   */ Escape: "Escape",
    /** The ExSel (Extend Selection) key. */ ExSel: "ExSel",
    /** The Execute key. */ Execute: "Execute",
    /** The Exit button, which exits the curreent application or menu. */ Exit: "Exit",
    /** The first general-purpose function key, F1. */ F1: "F1",
    /** The F2 key. */ F2: "F2",
    /** The F3 key. */ F3: "F3",
    /** The F4 key. */ F4: "F4",
    /** The F5 key. */ F5: "F5",
    /** The F6 key. */ F6: "F6",
    /** The F7 key. */ F7: "F7",
    /** The F8 key. */ F8: "F8",
    /** The F9 key. */ F9: "F9",
    /** The F10 key. */ F10: "F10",
    /** The F11 key. */ F11: "F11",
    /** The F12 key. */ F12: "F12",
    /** The F13 key. */ F13: "F13",
    /** The F14 key. */ F14: "F14",
    /** The F15 key. */ F15: "F15",
    /** The F16 key. */ F16: "F16",
    /** The F17 key. */ F17: "F17",
    /** The F18 key. */ F18: "F18",
    /** The F19 key. */ F19: "F19",
    /** The F20 key. */ F20: "F20",
    /** Clears the program or content stored in the first favorites list slot. */ FavoriteClear0: "FavoriteClear0",
    /** Clears the program or content stored in the second favorites list slot. */ FavoriteClear1: "FavoriteClear1",
    /** Clears the program or content stored in the third favorites list slot. */ FavoriteClear2: "FavoriteClear2",
    /** Clears the program or content stored in the fourth favorites list slot. */ FavoriteClear3: "FavoriteClear3",
    /**
   * Selects (recalls) the program or content stored in the first favorites list
   * slot.
   */ FavoriteRecall0: "FavoriteRecall0",
    /**
   * Selects (recalls) the program or content stored in the second favorites
   * list slot.
   */ FavoriteRecall1: "FavoriteRecall1",
    /**
   * Selects (recalls) the program or content stored in the third favorites list
   * slot.
   */ FavoriteRecall2: "FavoriteRecall2",
    /**
   * Selects (recalls) the program or content stored in the fourth favorites
   * list slot.
   */ FavoriteRecall3: "FavoriteRecall3",
    /** Stores the current program or content into the first favorites list slot. */ FavoriteStore0: "FavoriteStore0",
    /** Stores the current program or content into the second favorites list slot. */ FavoriteStore1: "FavoriteStore1",
    /** Stores the current program or content into the third favorites list slot. */ FavoriteStore2: "FavoriteStore2",
    /** Stores the current program or content into the fourth favorites list slot. */ FavoriteStore3: "FavoriteStore3",
    /**
   * The Final (Final Mode) key is used on some Asian keyboards to enter final
   * mode when using IMEs.
   */ FinalMode: "FinalMode",
    /**
   * The Find key. Opens an interface (typically a dialog box) for performing a
   * find/search operation.
   */ Find: "Find",
    /** The Finish key. */ Finish: "Finish",
    /**
   * The Fn (Function modifier) key. Used to allow generating function key
   * (F1-F15, for instance) characters on keyboards without a dedicated function
   * key area. Often handled in hardware so that events aren't generated for
   * this key.
   */ Fn: "Fn",
    /**
   * The FnLock or F-Lock (Function Lock) key.Toggles the function key mode
   * described by "Fn" on and off. Often handled in hardware so that events
   * aren't generated for this key.
   */ FnLock: "FnLock",
    /** The Back button. */ GoBack: "GoBack",
    /**
   * The Home button, which takes the user to the phone's main screen (usually
   * an application launcher).
   */ GoHome: "GoHome",
    /**
   * Switches to the first character group on an ISO/IEC 9995 keyboard. Each key
   * may have multiple groups of characters, each in its own column. Pressing
   * this key instructs the device to interpret keypresses as coming from the
   * first column on subsequent keystrokes.
   */ GroupFirst: "GroupFirst",
    /** Switches to the last character group on an ISO/IEC 9995 keyboard. */ GroupLast: "GroupLast",
    /** Switches to the next character group on an ISO/IEC 9995 keyboard. */ GroupNext: "GroupNext",
    /** Switches to the previous character group on an ISO/IEC 9995 keyboard. */ GroupPrevious: "GroupPrevious",
    /** Toggles the display of the program or content guide. */ Guide: "Guide",
    /**
   * If the guide is currently displayed, this button tells the guide to display
   * the next day's content.
   */ GuideNextDay: "GuideNextDay",
    /**
   * If the guide is currently displayed, this button tells the guide to display
   * the previous day's content.
   */ GuidePreviousDay: "GuidePreviousDay",
    /**
   * The Hangul (Korean character set) mode key, which toggles between Hangul
   * and English entry modes.
   */ HangulMode: "HangulMode",
    /**
   * Selects the Hanja mode, for converting Hangul characters to the more
   * specific Hanja characters.
   */ HanjaMode: "HanjaMode",
    /** The Hankaku (half-width characters) key. */ Hankaku: "Hankaku",
    /**
   * The Headset Hook key. This is typically actually a button on the headset
   * which is used to hang up calls and play or pause media.
   */ HeadsetHook: "HeadsetHook",
    /** The Help key. Opens or toggles the display of help information. */ Help: "Help",
    /**
   * The Hibernate key. This saves the state of the computer to disk and then
   * shuts down; the computer can be returned to its previous state by restoring
   * the saved state information.
   */ Hibernate: "Hibernate",
    /** The Hiragana key; selects Kana characters mode. */ Hiragana: "Hiragana",
    /** Toggles between the Hiragana and Katakana writing systems. */ HiraganaKatakana: "HiraganaKatakana",
    /** The Home key. Moves to the start of content. */ Home: "Home",
    /** The Hyper key. */ Hyper: "Hyper",
    /**
   * Toggles the display of information about the currently selected content,
   * program, or media.
   */ Info: "Info",
    /** The Insert key, Ins. Toggles between inserting and overwriting text. */ Insert: "Insert",
    /**
   * Tellls the device to perform an instant replay (typically some form of
   * jumping back a short amount of time then playing it again, possibly but not
   * usually in slow motion).
   */ InstantReplay: "InstantReplay",
    /**
   * Selects the Junja mode, in which Korean is represented using single-byte
   * Latin characters.
   */ JunjaMode: "JunjaMode",
    /** The Kana Mode (Kana Lock) key. */ KanaMode: "KanaMode",
    /**
   * The Kanji Mode key. Enables entering Japanese text using the ideographic
   * characters of Chinese origin.
   */ KanjiMode: "KanjiMode",
    /** The Katakana key. */ Katakana: "Katakana",
    /** The 11 key found on certain media numeric keypads. */ Key11: "Key11",
    /** The 12 key found on certain media numeric keypads. */ Key12: "Key12",
    /** The Redial button, which redials the last-called number. */ LastNumberRedial: "LastNumberRedial",
    /** The first generic application launcher button. */ LaunchApplication1: "LaunchApplication1",
    /** The second generic application launcher button. */ LaunchApplication2: "LaunchApplication2",
    /** The third generic application launcher button. */ LaunchApplication3: "LaunchApplication3",
    /** The fourth generic application launcher button. */ LaunchApplication4: "LaunchApplication4",
    /** The fifth generic application launcher button. */ LaunchApplication5: "LaunchApplication5",
    /** The sixth generic application launcher button. */ LaunchApplication6: "LaunchApplication6",
    /** The seventh generic application launcher button. */ LaunchApplication7: "LaunchApplication7",
    /** The eighth generic application launcher button. */ LaunchApplication8: "LaunchApplication8",
    /** The ninth generic application launcher button. */ LaunchApplication9: "LaunchApplication9",
    /** The 10th generic application launcher button. */ LaunchApplication10: "LaunchApplication10",
    /** The 11th generic application launcher button. */ LaunchApplication11: "LaunchApplication11",
    /** The 12th generic application launcher button. */ LaunchApplication12: "LaunchApplication12",
    /** The 13th generic application launcher button. */ LaunchApplication13: "LaunchApplication13",
    /** The 14th generic application launcher button. */ LaunchApplication14: "LaunchApplication14",
    /** The 15th generic application launcher button. */ LaunchApplication15: "LaunchApplication15",
    /** The 16th generic application launcher button. */ LaunchApplication16: "LaunchApplication16",
    /**
   * The Calculator key, often labeled with an icon such as . This is often used
   * as a generic application launcher key (APPCOMMAND_LAUNCH_APP2).
   */ LaunchCalculator: "LaunchCalculator",
    /** The Calendar key, often labeled with an icon like . */ LaunchCalendar: "LaunchCalendar",
    /** The Contacts key. */ LaunchContacts: "LaunchContacts",
    /** The Mail key. This is often displayed as . */ LaunchMail: "LaunchMail",
    /** The Media Player key. */ LaunchMediaPlayer: "LaunchMediaPlayer",
    /** The Music Player key, often labeled with an icon such as . */ LaunchMusicPlayer: "LaunchMusicPlayer",
    /**
   * The My Computer key on Windows keyboards. This is often used as a generic
   * application launcher key (APPCOMMAND_LAUNCH_APP1).
   */ LaunchMyComputer: "LaunchMyComputer",
    /** The Phone key, to open the phone dialer application if one is present. */ LaunchPhone: "LaunchPhone",
    /** The Screen Saver key. */ LaunchScreenSaver: "LaunchScreenSaver",
    /**
   * The Spreadsheet key. This key may be labeled with an icon such as or that
   * of a specific spreadsheet application.
   */ LaunchSpreadsheet: "LaunchSpreadsheet",
    /**
   * The Web Browser key. This key is frequently labeled with an icon such as or
   * the icon of a specific browser, depending on the device manufacturer.
   */ LaunchWebBrowser: "LaunchWebBrowser",
    /** The WebCam key. Opens the webcam application. */ LaunchWebCam: "LaunchWebCam",
    /**
   * The Word Processor key. This may be an icon of a specific word processor
   * application, or a generic document icon.
   */ LaunchWordProcessor: "LaunchWordProcessor",
    /** Opens content liniked to the current program, if available and possible. */ Link: "Link",
    /** Lists the current program. */ ListProgram: "ListProgram",
    /** Toggles a display listing currently available live content or programs. */ LiveContent: "LiveContent",
    /** Locks or unlocks the currently selected content or pgoram. */ Lock: "Lock",
    /** The LogOff key. */ LogOff: "LogOff",
    /** Opens the user interface to forward a message. */ MailForward: "MailForward",
    /** Opens the user interface to reply to a message. */ MailReply: "MailReply",
    /** Sends the current message. */ MailSend: "MailSend",
    /**
   * A button which cycles among the notification modes: silent, vibrate, ring,
   * and so forth.
   */ MannerMode: "MannerMode",
    /**
   * Presents a list of media applications, such as photo viewers, audio and
   * video players, and games. [1]
   */ MediaApps: "MediaApps",
    /** The Audio Track key. */ MediaAudioTrack: "MediaAudioTrack",
    /** Starts, continues, or increases the speed of fast forwarding the media. */ MediaFastForward: "MediaFastForward",
    /** Jumps back to the last-viewed content, program, or other media. */ MediaLast: "MediaLast",
    /**
   * Pauses the currently playing media. Some older applications use simply
   * "Pause" but this is not correct.
   */ MediaPause: "MediaPause",
    /**
   * Starts or continues playing media at normal speed, if not already doing so.
   * Has no effect otherwise.
   */ MediaPlay: "MediaPlay",
    /** Toggles between playing and pausing the current media. */ MediaPlayPause: "MediaPlayPause",
    /** Starts or resumes recording media. */ MediaRecord: "MediaRecord",
    /** Starts, continues, or increases the speed of rewinding the media. */ MediaRewind: "MediaRewind",
    /** Skips backward to the previous content or program. */ MediaSkipBackward: "MediaSkipBackward",
    /** Skips forward to the next content or program. */ MediaSkipForward: "MediaSkipForward",
    /** Steps backward to the previous content or program. */ MediaStepBackward: "MediaStepBackward",
    /** Steps forward to the next content or program. */ MediaStepForward: "MediaStepForward",
    /**
   * Stops the current media activity (such as playing, recording, pausing,
   * forwarding, or rewinding). Has no effect if the media is currently stopped
   * already.
   */ MediaStop: "MediaStop",
    /**
   * Top Menu button; opens the media's main menu, such as on a DVD or Blu-Ray
   * disc.
   */ MediaTopMenu: "MediaTopMenu",
    /** Seeks to the next media or program track. */ MediaTrackNext: "MediaTrackNext",
    /** Seeks to the previous media or program track. */ MediaTrackPrevious: "MediaTrackPrevious",
    /**
   * The Meta key. Allows issuing special command inputs. This is the Windows
   * logo key, or the Command  key on Mac.
   */ Meta: "Meta",
    /** Toggles the microphone on and off. */ MicrophoneToggle: "MicrophoneToggle",
    /** Decreases the microphone's input volume. */ MicrophoneVolumeDown: "MicrophoneVolumeDown",
    /** Mutes the microphone input. */ MicrophoneVolumeMute: "MicrophoneVolumeMute",
    /** Increases the microphone's input volume. */ MicrophoneVolumeUp: "MicrophoneVolumeUp",
    /** The Mod key. This is the Command  on Mac, or the Control key on Windows. */ Mod: "Mod",
    /** The Mode Change key. Toggles or cycles among input modes of IMEs. */ ModeChange: "ModeChange",
    /** The numeric keypad's multiplication key, *. */ Multiply: "Multiply",
    /** Navigates into a submenu or option. */ NavigateIn: "NavigateIn",
    /** Navigates to the next item. */ NavigateNext: "NavigateNext",
    /** Navigates out of the current screen or menu. */ NavigateOut: "NavigateOut",
    /** Navigates to the previous item. */ NavigatePrevious: "NavigatePrevious",
    /** Creates a new document or message. */ New: "New",
    /**
   * The Next Candidate function key. Selects the next possible match for the
   * ongoing input.
   */ NextCandidate: "NextCandidate",
    /** Cycles to the next channel in the favorites list. */ NextFavoriteChannel: "NextFavoriteChannel",
    /**
   * Cycles to the next saved user profile, if this feature is supported and
   * multiple profiles exist.
   */ NextUserProfile: "NextUserProfile",
    /**
   * The NonConvert ("Don't convert") key. This accepts the current input method
   * sequence without running conversion when using an IME.
   */ NonConvert: "NonConvert",
    /** The Notification key. */ Notification: "Notification",
    /**
   * The NumLock (Number Lock) key. Toggles the numeric keypad between number
   * entry some other mode (often directional arrows).
   */ NumLock: "NumLock",
    /**
   * Opens the user interface for selecting on demand content or programs to
   * watch.
   */ OnDemand: "OnDemand",
    /** Opens an existing document or message. */ Open: "Open",
    /**
   * The Page Down (or PgDn) key. Scrolls down or displays the next page of
   * content.
   */ PageDown: "PageDown",
    /**
   * The Page Up (or PgUp) key. Scrolls up or displays the previous page of
   * content.
   */ PageUp: "PageUp",
    /** Starts the process of pairing the remote with a device to be controlled. */ Pairing: "Pairing",
    /** Paste from the clipboard. */ Paste: "Paste",
    /**
   * The Pause key. Pauses the current application or state, if applicable. This
   * shouldn't be confused with the "MediaPause" key value, which is used for
   * media controllers, rather than to control applications and processes.
   */ Pause: "Pause",
    /** A button to move the picture-in-picture view downward. */ PinPDown: "PinPDown",
    /** A button to control moving the picture-in-picture view. */ PinPMove: "PinPMove",
    /** Toggles display of th epicture-in-picture view on and off. */ PinPToggle: "PinPToggle",
    /** A button to move the picture-in-picture view upward. */ PinPUp: "PinPUp",
    /**
   * The Play key. Resumes a previously paused application, if applicable. This
   * shouldn't be confused with the "MediaPlay" key value, which is used for
   * media controllers, rather than to control applications and processes.
   */ Play: "Play",
    /** Decreases the media playback rate. */ PlaySpeedDown: "PlaySpeedDown",
    /** Returns the media playback rate to normal. */ PlaySpeedReset: "PlaySpeedReset",
    /** Increases the media playback rate. */ PlaySpeedUp: "PlaySpeedUp",
    /**
   * The Power button or key, to toggle power on and off. Not all systems pass
   * this key through to to the user agent.
   */ Power: "Power",
    /** The PowerOff or PowerDown key. Shuts off the system. */ PowerOff: "PowerOff",
    /**
   * The Previous Candidate key. Selects the previous possible match for the
   * ongoing input.
   */ PreviousCandidate: "PreviousCandidate",
    /** Prints the current document or message. */ Print: "Print",
    /**
   * The PrintScreen or PrtScr key. Sometimes SnapShot. Captures the screen and
   * prints it or saves it to disk.
   */ PrintScreen: "PrintScreen",
    /** The Process key. Instructs the IME to process the conversion. */ Process: "Process",
    /** The Props (Properties) key. */ Props: "Props",
    /** Toggles random media (also known as "shuffle mode") on and off. */ RandomToggle: "RandomToggle",
    /**
   * A code sent when the remote control's battery is low. This doesn't actually
   * correspond to a physical key at all.
   */ RcLowBattery: "RcLowBattery",
    /** Cycles among the available media recording speeds. */ RecordSpeedNext: "RecordSpeedNext",
    /** Redo the last action. */ Redo: "Redo",
    /**
   * Toggles radio frequency (RF) input bypass mode on and off. RF bypass mode
   * passes RF input directly to the RF output without any processing or
   * filtering.
   */ RfBypass: "RfBypass",
    /** The Romaji key; selects the Roman character set. */ Romaji: "Romaji",
    /** Cycles among input modes on an external set-top box (STB). */ STBInput: "STBInput",
    /** Toggles on and off an external STB. */ STBPower: "STBPower",
    /** Saves the current document or message. */ Save: "Save",
    /**
   * Toggles the channel scan mode on and off; this is a mode which flips
   * through channels automatically until the user stops the scan.
   */ ScanChannelsToggle: "ScanChannelsToggle",
    /** Cycles through the available screen display modes. */ ScreenModeNext: "ScreenModeNext",
    /** The Scroll Lock key. Toggles beteen scrolling and cursor movement modes. */ ScrollLock: "ScrollLock",
    /** The Select key. */ Select: "Select",
    /**
   * The numeric keypad's places separator character (in the United States, this
   * is a comma, but elsewhere it is frequently a period).
   */ Separator: "Separator",
    /** Toggles display of the device's settings screen on and off. */ Settings: "Settings",
    /**
   * The Shift key. Modifies keystrokes to allow typing upper (or other) case
   * letters, and to support typing punctuation and other special characters.
   */ Shift: "Shift",
    /**
   * The Single Candidate key. Enables single candidate mode (as opposed to
   * multi-candidate mode); in this mode, only one candidate is displayed at a
   * time.
   */ SingleCandidate: "SingleCandidate",
    /** The first general-purpose virtual function key. */ Soft1: "Soft1",
    /** The second general-purpose virtual function key. */ Soft2: "Soft2",
    /** The third general-purpose virtual function key. */ Soft3: "Soft3",
    /** The fourth general-purpose virtual function key. */ Soft4: "Soft4",
    /**
   * Presents a list of possible corrections for a word which was incorrectly
   * identified.
   */ SpeechCorrectionList: "SpeechCorrectionList",
    /**
   * Toggles between dictation mode and command/control mode. This lets the
   * speech engine know whether to interpret spoken words as input text or as
   * commands.
   */ SpeechInputToggle: "SpeechInputToggle",
    /** Starts spell checking the current document. */ SpellCheck: "SpellCheck",
    /** Toggles split screen display mode on and off. */ SplitScreenToggle: "SplitScreenToggle",
    /**
   * The Standby key; also known as Suspend or Sleep. This turns off the display
   * and puts the computer in a low power consumption mode, without completely
   * powering off.
   */ Standby: "Standby",
    /** Toggles the display of subtitles on and off if they're available. */ Subtitle: "Subtitle",
    /** The numeric keypad's subtraction key, -. */ Subtract: "Subtract",
    /** The Super key. */ Super: "Super",
    /** The Symbol modifier key (found on certain virtual keyboards). */ Symbol: "Symbol",
    /** The Symbol Lock key. */ SymbolLock: "SymbolLock",
    /** Switches into TV viewing mode. */ TV: "TV",
    /** Toggles 3D TV mode on and off. */ TV3DMode: "TV3DMode",
    /** Toggles between antenna and cable inputs. */ TVAntennaCable: "TVAntennaCable",
    /** Toggles audio description mode on and off. */ TVAudioDescription: "TVAudioDescription",
    /**
   * Decreases trhe audio description's mixing volume; reduces the volume of the
   * audio descriptions relative to the program sound.
   */ TVAudioDescriptionMixDown: "TVAudioDescriptionMixDown",
    /**
   * Increases the audio description's mixing volume; increases the volume of
   * the audio descriptions relative to the program sound.
   */ TVAudioDescriptionMixUp: "TVAudioDescriptionMixUp",
    /**
   * Displays or hides the media contents available for playback (this may be a
   * channel guide showing the currently airing programs, or a list of media
   * files to play).
   */ TVContentsMenu: "TVContentsMenu",
    /** Displays or hides the TV's data service menu. */ TVDataService: "TVDataService",
    /** Cycles the input mode on an external TV. */ TVInput: "TVInput",
    /** Switches to the input "Component 1." */ TVInputComponent1: "TVInputComponent1",
    /** Switches to the input "Component 2." */ TVInputComponent2: "TVInputComponent2",
    /** Switches to the input "Composite 1." */ TVInputComposite1: "TVInputComposite1",
    /** Switches to the input "Composite 2." */ TVInputComposite2: "TVInputComposite2",
    /** Switches to the input "HDMI 1." */ TVInputHDMI1: "TVInputHDMI1",
    /** Switches to the input "HDMI 2." */ TVInputHDMI2: "TVInputHDMI2",
    /** Switches to the input "HDMI 3." */ TVInputHDMI3: "TVInputHDMI3",
    /** Switches to the input "HDMI 4." */ TVInputHDMI4: "TVInputHDMI4",
    /** Switches to the input "VGA 1." */ TVInputVGA1: "TVInputVGA1",
    /** The Media Context menu key. */ TVMediaContext: "TVMediaContext",
    /** Toggle the TV's network connection on and off. */ TVNetwork: "TVNetwork",
    /** Put the TV into number entry mode. */ TVNumberEntry: "TVNumberEntry",
    /** The device's power button. */ TVPower: "TVPower",
    /** Radio button. */ TVRadioService: "TVRadioService",
    /** Satellite button. */ TVSatellite: "TVSatellite",
    /** Broadcast Satellite button. */ TVSatelliteBS: "TVSatelliteBS",
    /** Communication Satellite button. */ TVSatelliteCS: "TVSatelliteCS",
    /** Toggles among available satellites. */ TVSatelliteToggle: "TVSatelliteToggle",
    /**
   * Selects analog terrestrial television service (analog cable or antenna
   * reception).
   */ TVTerrestrialAnalog: "TVTerrestrialAnalog",
    /**
   * Selects digital terrestrial television service (digital cable or antenna
   * receiption).
   */ TVTerrestrialDigital: "TVTerrestrialDigital",
    /** Timer programming button. */ TVTimer: "TVTimer",
    /** The Horizontal Tab key, Tab. */ Tab: "Tab",
    /** Toggles display of teletext, if available. */ Teletext: "Teletext",
    /** Undo the last action. */ Undo: "Undo",
    /**
   * The user agent wasn't able to map the event's virtual keycode to a specific
   * key value. This can happen due to hardware or software constraints, or
   * because of constraints around the platform on which the user agent is
   * running.
   */ Unidentified: "Unidentified",
    /** Cycles through the available video modes. */ VideoModeNext: "VideoModeNext",
    /** The Voice Dial key. Initiates voice dialing. */ VoiceDial: "VoiceDial",
    /**
   * The WakeUp key; used to wake the computer from the hibernation or standby
   * modes.
   */ WakeUp: "WakeUp",
    /**
   * Causes the device to identify itself in some fashion, such as by flashing a
   * light, briefly changing the brightness of indicator lights, or emitting a
   * tone.
   */ Wink: "Wink",
    /** The Zenkaku (full width) characters key. */ Zenkaku: "Zenkaku",
    /** The Zenkaku/Hankaku (full width/half width) toggle key. */ ZenkakuHanaku: "ZenkakuHanaku",
    /** The ZoomIn key. */ ZoomIn: "ZoomIn",
    /** The ZoomOut key. */ ZoomOut: "ZoomOut",
    /**
   * Toggles between full-screen and scaled content display, or otherwise change
   * the magnification level.
   */ ZoomToggle: "ZoomToggle"
};
;
function useRecordHotkeys() {
    const [keys, setKeys] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(/* @__PURE__ */ new Set());
    const [isRecording, setIsRecording] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
    const handler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRecordHotkeys.useCallback2[handler]": (event)=>{
            if (event.code === void 0) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            setKeys({
                "useRecordHotkeys.useCallback2[handler]": (prev)=>{
                    const newKeys = new Set(prev);
                    newKeys.add(mapKey(event.code));
                    return newKeys;
                }
            }["useRecordHotkeys.useCallback2[handler]"]);
        }
    }["useRecordHotkeys.useCallback2[handler]"], []);
    const stop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRecordHotkeys.useCallback2[stop]": ()=>{
            if (typeof document !== "undefined") {
                document.removeEventListener("keydown", handler);
                setIsRecording(false);
            }
        }
    }["useRecordHotkeys.useCallback2[stop]"], [
        handler
    ]);
    const start = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRecordHotkeys.useCallback2[start]": ()=>{
            setKeys(/* @__PURE__ */ new Set());
            if (typeof document !== "undefined") {
                stop();
                document.addEventListener("keydown", handler);
                setIsRecording(true);
            }
        }
    }["useRecordHotkeys.useCallback2[start]"], [
        handler,
        stop
    ]);
    const resetKeys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRecordHotkeys.useCallback2[resetKeys]": ()=>{
            setKeys(/* @__PURE__ */ new Set());
        }
    }["useRecordHotkeys.useCallback2[resetKeys]"], []);
    return [
        keys,
        {
            isRecording,
            resetKeys,
            start,
            stop
        }
    ];
}
;
;
function useDeepEqualMemo(value) {
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    if (!deepEqual(ref.current, value)) {
        ref.current = value;
    }
    return ref.current;
}
// src/internal/validators.ts
function maybePreventDefault(e, hotkey, preventDefault) {
    if (typeof preventDefault === "function" && preventDefault(e, hotkey) || preventDefault === true) {
        e.preventDefault();
    }
}
function isHotkeyEnabled(e, hotkey, enabled) {
    if (typeof enabled === "function") {
        return enabled(e, hotkey);
    }
    return enabled === true || enabled === void 0;
}
function isKeyboardEventTriggeredByInput(ev) {
    return isHotkeyEnabledOnTag(ev, [
        "input",
        "textarea",
        "select"
    ]);
}
function isHotkeyEnabledOnTag({ target }, enabledOnTags = false) {
    const targetTagName = target && target.tagName;
    if (isReadonlyArray(enabledOnTags)) {
        return Boolean(targetTagName && (enabledOnTags == null ? void 0 : enabledOnTags.some((tag)=>tag.toLowerCase() === targetTagName.toLowerCase())));
    }
    return Boolean(targetTagName && enabledOnTags && enabledOnTags);
}
function isScopeActive(activeScopes, scopes) {
    if (activeScopes.length === 0 && scopes) {
        console.warn('A hotkey has the "scopes" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>');
        return true;
    }
    if (!scopes) {
        return true;
    }
    return activeScopes.some((scope)=>scopes.includes(scope)) || activeScopes.includes("*");
}
var isHotkeyMatchingKeyboardEvent = (e, hotkey, ignoreModifiers = false)=>{
    const { alt, ctrl, keys, meta, mod, shift, useKey } = hotkey;
    const { altKey, code, ctrlKey, key: producedKey, metaKey, shiftKey } = e;
    const mappedCode = mapKey(code);
    if (useKey && (keys == null ? void 0 : keys.length) === 1 && keys.includes(producedKey)) {
        return true;
    }
    if (!(keys == null ? void 0 : keys.includes(mappedCode)) && ![
        "alt",
        "control",
        "ctrl",
        "meta",
        "os",
        "shift",
        "unknown"
    ].includes(mappedCode)) {
        return false;
    }
    if (!ignoreModifiers) {
        if (alt !== altKey && mappedCode !== "alt") {
            return false;
        }
        if (shift !== shiftKey && mappedCode !== "shift") {
            return false;
        }
        if (mod) {
            if (!metaKey && !ctrlKey) {
                return false;
            }
        } else {
            if (meta !== metaKey && mappedCode !== "meta" && mappedCode !== "os") {
                return false;
            }
            if (ctrl !== ctrlKey && mappedCode !== "ctrl" && mappedCode !== "control") {
                return false;
            }
        }
    }
    if (keys && keys.length === 1 && keys.includes(mappedCode)) {
        return true;
    } else if (keys) {
        return isHotkeyPressed(keys);
    } else if (!keys) {
        return true;
    }
    return false;
};
// src/internal/useHotkeys.ts
var stopPropagation = (e)=>{
    e.stopPropagation();
    e.preventDefault();
    e.stopImmediatePropagation();
};
var useSafeLayoutEffect = typeof window === "undefined" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"];
function useHotkeys(keys, callback, options, dependencies) {
    const [ref, setRef] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
    const hasTriggeredRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    const _options = Array.isArray(options) ? Array.isArray(dependencies) ? void 0 : dependencies : options;
    const _keys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useHotkeys.useMemo[_keys]": ()=>{
            if (Array.isArray(keys) && keys.length > 0 && Array.isArray(keys[0])) {
                return keys.map({
                    "useHotkeys.useMemo[_keys]": (keyCombo)=>keyCombo.map({
                            "useHotkeys.useMemo[_keys]": (k)=>k.toString()
                        }["useHotkeys.useMemo[_keys]"]).join((_options == null ? void 0 : _options.splitKey) || "+")
                }["useHotkeys.useMemo[_keys]"]).join((_options == null ? void 0 : _options.delimiter) || ",");
            } else if (Array.isArray(keys)) {
                return keys.join((_options == null ? void 0 : _options.delimiter) || ",");
            }
            return keys;
        }
    }["useHotkeys.useMemo[_keys]"], [
        keys,
        _options == null ? void 0 : _options.splitKey,
        _options == null ? void 0 : _options.delimiter
    ]);
    const _deps = Array.isArray(options) ? options : Array.isArray(dependencies) ? dependencies : void 0;
    const memoisedCB = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(callback, _deps != null ? _deps : []);
    const cbRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(memoisedCB);
    cbRef.current = _deps ? memoisedCB : callback;
    const memoisedOptions = useDeepEqualMemo(_options);
    const { activeScopes } = useHotkeysContext();
    const proxy = useBoundHotkeysProxy();
    useSafeLayoutEffect({
        "useHotkeys.useSafeLayoutEffect": ()=>{
            if ((memoisedOptions == null ? void 0 : memoisedOptions.enabled) === false || !isScopeActive(activeScopes, memoisedOptions == null ? void 0 : memoisedOptions.scopes)) {
                return;
            }
            const listener = {
                "useHotkeys.useSafeLayoutEffect.listener": (e, isKeyUp = false)=>{
                    var _a;
                    if (isKeyboardEventTriggeredByInput(e) && !isHotkeyEnabledOnTag(e, memoisedOptions == null ? void 0 : memoisedOptions.enableOnFormTags)) {
                        return;
                    }
                    if (ref !== null) {
                        const rootNode = ref.getRootNode();
                        if ((rootNode instanceof Document || rootNode instanceof ShadowRoot) && rootNode.activeElement !== ref && !ref.contains(rootNode.activeElement)) {
                            stopPropagation(e);
                            return;
                        }
                    }
                    if (((_a = e.target) == null ? void 0 : _a.isContentEditable) && !(memoisedOptions == null ? void 0 : memoisedOptions.enableOnContentEditable)) {
                        return;
                    }
                    parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.delimiter).forEach({
                        "useHotkeys.useSafeLayoutEffect.listener": (key)=>{
                            var _a2, _b, _c;
                            const hotkey = parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.splitKey, memoisedOptions == null ? void 0 : memoisedOptions.useKey);
                            if (isHotkeyMatchingKeyboardEvent(e, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.ignoreModifiers) || ((_a2 = hotkey.keys) == null ? void 0 : _a2.includes("*"))) {
                                if (((_b = memoisedOptions == null ? void 0 : memoisedOptions.ignoreEventWhenPrevented) != null ? _b : true) && e.defaultPrevented) {
                                    return;
                                }
                                if ((_c = memoisedOptions == null ? void 0 : memoisedOptions.ignoreEventWhen) == null ? void 0 : _c.call(memoisedOptions, e)) {
                                    return;
                                }
                                if (isKeyUp && hasTriggeredRef.current) {
                                    return;
                                }
                                if (!isHotkeyEnabled(e, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.enabled)) {
                                    stopPropagation(e);
                                    return;
                                }
                                cbRef.current(e, hotkey);
                                maybePreventDefault(e, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.preventDefault);
                                if (!isKeyUp) {
                                    hasTriggeredRef.current = true;
                                }
                            }
                        }
                    }["useHotkeys.useSafeLayoutEffect.listener"]);
                }
            }["useHotkeys.useSafeLayoutEffect.listener"];
            const handleKeyDown = {
                "useHotkeys.useSafeLayoutEffect.handleKeyDown": (event)=>{
                    if (event.code === void 0) {
                        return;
                    }
                    pushToCurrentlyPressedKeys(mapKey(event.code));
                    if ((memoisedOptions == null ? void 0 : memoisedOptions.keydown) === void 0 && (memoisedOptions == null ? void 0 : memoisedOptions.keyup) !== true || (memoisedOptions == null ? void 0 : memoisedOptions.keydown)) {
                        listener(event);
                    }
                }
            }["useHotkeys.useSafeLayoutEffect.handleKeyDown"];
            const handleKeyUp = {
                "useHotkeys.useSafeLayoutEffect.handleKeyUp": (event)=>{
                    if (event.code === void 0) {
                        return;
                    }
                    removeFromCurrentlyPressedKeys(mapKey(event.code));
                    hasTriggeredRef.current = false;
                    if (memoisedOptions == null ? void 0 : memoisedOptions.keyup) {
                        listener(event, true);
                    }
                }
            }["useHotkeys.useSafeLayoutEffect.handleKeyUp"];
            const domNode = ref || (_options == null ? void 0 : _options.document) || document;
            domNode.addEventListener("keyup", handleKeyUp);
            domNode.addEventListener("keydown", handleKeyDown);
            if (proxy) {
                parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.delimiter).forEach({
                    "useHotkeys.useSafeLayoutEffect": (key)=>proxy.addHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.splitKey, memoisedOptions == null ? void 0 : memoisedOptions.useKey, memoisedOptions == null ? void 0 : memoisedOptions.description))
                }["useHotkeys.useSafeLayoutEffect"]);
            }
            return ({
                "useHotkeys.useSafeLayoutEffect": ()=>{
                    domNode.removeEventListener("keyup", handleKeyUp);
                    domNode.removeEventListener("keydown", handleKeyDown);
                    if (proxy) {
                        parseKeysHookInput(_keys, memoisedOptions == null ? void 0 : memoisedOptions.delimiter).forEach({
                            "useHotkeys.useSafeLayoutEffect": (key)=>proxy.removeHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.splitKey, memoisedOptions == null ? void 0 : memoisedOptions.useKey, memoisedOptions == null ? void 0 : memoisedOptions.description))
                        }["useHotkeys.useSafeLayoutEffect"]);
                    }
                }
            })["useHotkeys.useSafeLayoutEffect"];
        }
    }["useHotkeys.useSafeLayoutEffect"], [
        ref,
        _keys,
        memoisedOptions,
        activeScopes
    ]);
    return setRef;
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@udecode/utils/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/environment.ts
__turbopack_context__.s([
    "IS_APPLE",
    ()=>IS_APPLE,
    "bindFirst",
    ()=>bindFirst,
    "escapeRegExp",
    ()=>escapeRegExp,
    "findHtmlParentElement",
    ()=>findHtmlParentElement,
    "getHandler",
    ()=>getHandler,
    "hexToBase64",
    ()=>hexToBase64,
    "isDefined",
    ()=>isDefined,
    "isNull",
    ()=>isNull,
    "isUndefined",
    ()=>isUndefined,
    "isUndefinedOrNull",
    ()=>isUndefinedOrNull,
    "isUrl",
    ()=>isUrl,
    "mergeProps",
    ()=>mergeProps,
    "sanitizeUrl",
    ()=>sanitizeUrl
]);
var IS_APPLE = typeof navigator !== "undefined" && navigator.userAgent.includes("Mac OS X");
// src/escapeRegexp.ts
var escapeRegExp = (text)=>{
    return text.replaceAll(/[#$()*+,.?[\\\]^s{|}-]/g, String.raw`\$&`);
};
// src/findHtmlParentElement.ts
var findHtmlParentElement = (el, nodeName)=>{
    if (!el || el.nodeName === nodeName) {
        return el;
    }
    return findHtmlParentElement(el.parentElement, nodeName);
};
// src/getHandler.ts
var getHandler = (cb, ...args)=>()=>{
        cb?.(...args);
    };
// src/hexToBase64.ts
var hexToBase64 = (hex)=>{
    const hexPairs = hex.match(/\w{2}/g) || [];
    const binary = hexPairs.map((hexPair)=>String.fromCodePoint(Number.parseInt(hexPair, 16)));
    return btoa(binary.join(""));
};
// src/isUrl.ts
var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
var emailLintRE = /mailto:([^?\\]+)/;
var localhostDomainRE = /^localhost[\d:?]*(?:[^\d:?]\S*)?$/;
var nonLocalhostDomainRE = /^[^\s.]+\.\S{2,}$/;
var isUrl = (string)=>{
    if (typeof string !== "string") {
        return false;
    }
    const generalMatch = protocolAndDomainRE.exec(string);
    const emailLinkMatch = emailLintRE.exec(string);
    const match = generalMatch || emailLinkMatch;
    if (!match) {
        return false;
    }
    const everythingAfterProtocol = match[1];
    if (!everythingAfterProtocol) {
        return false;
    }
    try {
        new URL(string);
    } catch  {
        return false;
    }
    return localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol);
};
// src/mergeProps.ts
var mergeProps = (props, overrideProps, { handlerKeys, handlerQuery = (key)=>key.startsWith("on") } = {})=>{
    const map = /* @__PURE__ */ new Map();
    const acc = {};
    const mapProps = (_props)=>{
        if (!_props) return;
        Object.entries(_props).forEach(([key, value])=>{
            if ((!handlerKeys || handlerKeys.includes(key)) && (!handlerQuery || handlerQuery(key)) && typeof value === "function") {
                if (!map.has(key)) {
                    map.set(key, []);
                }
                map.get(key)?.push(value);
                acc[key] = (...args)=>{
                    map.get(key)?.forEach((fn)=>fn(...args));
                };
            } else {
                acc[key] = value;
            }
        });
    };
    mapProps(props);
    mapProps(overrideProps);
    return acc;
};
// src/sanitizeUrl.ts
var sanitizeUrl = (url, { allowedSchemes, permitInvalid = false })=>{
    if (!url) return null;
    if (url.startsWith("/") || url.startsWith("#")) {
        return url;
    }
    let parsedUrl = null;
    try {
        parsedUrl = new URL(url);
    } catch  {
        return permitInvalid ? url : null;
    }
    if (allowedSchemes && !allowedSchemes.includes(parsedUrl.protocol.slice(0, -1))) {
        return null;
    }
    return parsedUrl.href;
};
// src/type-utils.ts
var isUndefined = (obj)=>obj === void 0;
var isNull = (obj)=>obj === null;
var isUndefinedOrNull = (obj)=>isUndefined(obj) || isNull(obj);
var isDefined = (arg)=>!isUndefinedOrNull(arg);
function bindFirst(fn, firstArg) {
    return (...args)=>fn(firstArg, ...args);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/jotai/esm/vanilla.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "atom",
    ()=>atom,
    "createStore",
    ()=>createStore,
    "getDefaultStore",
    ()=>getDefaultStore
]);
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/jotai/esm/vanilla.mjs")}`;
    }
};
let keyCount = 0;
function atom(read, write) {
    const key = `atom${++keyCount}`;
    const config = {
        toString: ()=>key
    };
    if (typeof read === "function") {
        config.read = read;
    } else {
        config.init = read;
        config.read = defaultRead;
        config.write = defaultWrite;
    }
    if (write) {
        config.write = write;
    }
    return config;
}
function defaultRead(get) {
    return get(this);
}
function defaultWrite(get, set, arg) {
    return set(this, typeof arg === "function" ? arg(get(this)) : arg);
}
const isSelfAtom = (atom, a)=>atom.unstable_is ? atom.unstable_is(a) : a === atom;
const hasInitialValue = (atom)=>"init" in atom;
const isActuallyWritableAtom = (atom)=>!!atom.write;
const cancelPromiseMap = /* @__PURE__ */ new WeakMap();
const registerCancelPromise = (promise, cancel)=>{
    cancelPromiseMap.set(promise, cancel);
    promise.catch(()=>{}).finally(()=>cancelPromiseMap.delete(promise));
};
const cancelPromise = (promise, next)=>{
    const cancel = cancelPromiseMap.get(promise);
    if (cancel) {
        cancelPromiseMap.delete(promise);
        cancel(next);
    }
};
const resolvePromise = (promise, value)=>{
    promise.status = "fulfilled";
    promise.value = value;
};
const rejectPromise = (promise, e)=>{
    promise.status = "rejected";
    promise.reason = e;
};
const isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === "function";
const isEqualAtomValue = (a, b)=>!!a && "v" in a && "v" in b && Object.is(a.v, b.v);
const isEqualAtomError = (a, b)=>!!a && "e" in a && "e" in b && Object.is(a.e, b.e);
const hasPromiseAtomValue = (a)=>!!a && "v" in a && a.v instanceof Promise;
const isEqualPromiseAtomValue = (a, b)=>"v" in a && "v" in b && a.v.orig && a.v.orig === b.v.orig;
const returnAtomValue = (atomState)=>{
    if ("e" in atomState) {
        throw atomState.e;
    }
    return atomState.v;
};
const createStore$1 = ()=>{
    const atomStateMap = /* @__PURE__ */ new WeakMap();
    const mountedMap = /* @__PURE__ */ new WeakMap();
    const pendingStack = [];
    const pendingMap = /* @__PURE__ */ new WeakMap();
    let devListenersRev2;
    let mountedAtoms;
    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
        devListenersRev2 = /* @__PURE__ */ new Set();
        mountedAtoms = /* @__PURE__ */ new Set();
    }
    const getAtomState = (atom)=>atomStateMap.get(atom);
    const addPendingDependent = (atom, atomState)=>{
        atomState.d.forEach((_, a)=>{
            if (!pendingMap.has(a)) {
                const aState = getAtomState(a);
                pendingMap.set(a, [
                    aState,
                    /* @__PURE__ */ new Set()
                ]);
                if (aState) {
                    addPendingDependent(a, aState);
                }
            }
            pendingMap.get(a)[1].add(atom);
        });
    };
    const setAtomState = (atom, atomState)=>{
        var _a;
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            Object.freeze(atomState);
        }
        const prevAtomState = getAtomState(atom);
        atomStateMap.set(atom, atomState);
        (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);
        if (!pendingMap.has(atom)) {
            pendingMap.set(atom, [
                prevAtomState,
                /* @__PURE__ */ new Set()
            ]);
            addPendingDependent(atom, atomState);
        }
        if (hasPromiseAtomValue(prevAtomState)) {
            const next = "v" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);
            if (prevAtomState.v !== next) {
                cancelPromise(prevAtomState.v, next);
            }
        }
    };
    const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies)=>{
        const dependencies = new Map(keepPreviousDependencies ? nextAtomState.d : null);
        let changed = false;
        nextDependencies.forEach((aState, a)=>{
            if (!aState && isSelfAtom(atom, a)) {
                aState = nextAtomState;
            }
            if (aState) {
                dependencies.set(a, aState);
                if (nextAtomState.d.get(a) !== aState) {
                    changed = true;
                }
            } else if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
                console.warn("[Bug] atom state not found");
            }
        });
        if (changed || nextAtomState.d.size !== dependencies.size) {
            nextAtomState.d = dependencies;
        }
    };
    const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies)=>{
        const prevAtomState = getAtomState(atom);
        const nextAtomState = {
            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),
            v: value
        };
        if (nextDependencies) {
            updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies);
        }
        if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {
            return prevAtomState;
        }
        if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {
            if (prevAtomState.d === nextAtomState.d) {
                return prevAtomState;
            } else {
                nextAtomState.v = prevAtomState.v;
            }
        }
        setAtomState(atom, nextAtomState);
        return nextAtomState;
    };
    const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise)=>{
        if (isPromiseLike(valueOrPromise)) {
            let continuePromise;
            const updatePromiseDependencies = ()=>{
                const prevAtomState = getAtomState(atom);
                if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {
                    return;
                }
                const nextAtomState = setAtomValue(atom, promise, nextDependencies);
                if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {
                    mountDependencies(atom, nextAtomState, prevAtomState.d);
                }
            };
            const promise = new Promise((resolve, reject)=>{
                let settled = false;
                valueOrPromise.then((v)=>{
                    if (!settled) {
                        settled = true;
                        resolvePromise(promise, v);
                        resolve(v);
                        updatePromiseDependencies();
                    }
                }, (e)=>{
                    if (!settled) {
                        settled = true;
                        rejectPromise(promise, e);
                        reject(e);
                        updatePromiseDependencies();
                    }
                });
                continuePromise = (next)=>{
                    if (!settled) {
                        settled = true;
                        next.then((v)=>resolvePromise(promise, v), (e)=>rejectPromise(promise, e));
                        resolve(next);
                    }
                };
            });
            promise.orig = valueOrPromise;
            promise.status = "pending";
            registerCancelPromise(promise, (next)=>{
                if (next) {
                    continuePromise(next);
                    abortPromise == null ? void 0 : abortPromise();
                }
            });
            return setAtomValue(atom, promise, nextDependencies, true);
        }
        return setAtomValue(atom, valueOrPromise, nextDependencies);
    };
    const setAtomError = (atom, error, nextDependencies)=>{
        const prevAtomState = getAtomState(atom);
        const nextAtomState = {
            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),
            e: error
        };
        if (nextDependencies) {
            updateDependencies(atom, nextAtomState, nextDependencies);
        }
        if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {
            return prevAtomState;
        }
        setAtomState(atom, nextAtomState);
        return nextAtomState;
    };
    const readAtomState = (atom, force)=>{
        const atomState = getAtomState(atom);
        if (!(force == null ? void 0 : force(atom)) && atomState) {
            if (mountedMap.has(atom)) {
                return atomState;
            }
            if (Array.from(atomState.d).every(([a, s])=>{
                if (a === atom) {
                    return true;
                }
                const aState = readAtomState(a, force);
                return aState === s || isEqualAtomValue(aState, s);
            })) {
                return atomState;
            }
        }
        const nextDependencies = /* @__PURE__ */ new Map();
        let isSync = true;
        const getter = (a)=>{
            if (isSelfAtom(atom, a)) {
                const aState2 = getAtomState(a);
                if (aState2) {
                    nextDependencies.set(a, aState2);
                    return returnAtomValue(aState2);
                }
                if (hasInitialValue(a)) {
                    nextDependencies.set(a, void 0);
                    return a.init;
                }
                throw new Error("no atom init");
            }
            const aState = readAtomState(a, force);
            nextDependencies.set(a, aState);
            return returnAtomValue(aState);
        };
        let controller;
        let setSelf;
        const options = {
            get signal () {
                if (!controller) {
                    controller = new AbortController();
                }
                return controller.signal;
            },
            get setSelf () {
                if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production" && !isActuallyWritableAtom(atom)) {
                    console.warn("setSelf function cannot be used with read-only atom");
                }
                if (!setSelf && isActuallyWritableAtom(atom)) {
                    setSelf = (...args)=>{
                        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production" && isSync) {
                            console.warn("setSelf function cannot be called in sync");
                        }
                        if (!isSync) {
                            return writeAtom(atom, ...args);
                        }
                    };
                }
                return setSelf;
            }
        };
        try {
            const valueOrPromise = atom.read(getter, options);
            return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, ()=>controller == null ? void 0 : controller.abort());
        } catch (error) {
            return setAtomError(atom, error, nextDependencies);
        } finally{
            isSync = false;
        }
    };
    const readAtom = (atom)=>returnAtomValue(readAtomState(atom));
    const recomputeDependents = (atom)=>{
        const getDependents = (a)=>{
            var _a, _b;
            const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);
            (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach((dependent)=>{
                dependents.add(dependent);
            });
            return dependents;
        };
        const topsortedAtoms = new Array();
        const markedAtoms = /* @__PURE__ */ new Set();
        const visit = (n)=>{
            if (markedAtoms.has(n)) {
                return;
            }
            markedAtoms.add(n);
            for (const m of getDependents(n)){
                if (n !== m) {
                    visit(m);
                }
            }
            topsortedAtoms.push(n);
        };
        visit(atom);
        const changedAtoms = /* @__PURE__ */ new Set([
            atom
        ]);
        const isMarked = (a)=>markedAtoms.has(a);
        for(let i = topsortedAtoms.length - 1; i >= 0; --i){
            const a = topsortedAtoms[i];
            const prevAtomState = getAtomState(a);
            if (!prevAtomState) {
                continue;
            }
            let hasChangedDeps = false;
            for (const dep of prevAtomState.d.keys()){
                if (dep !== a && changedAtoms.has(dep)) {
                    hasChangedDeps = true;
                    break;
                }
            }
            if (hasChangedDeps) {
                const nextAtomState = readAtomState(a, isMarked);
                addPendingDependent(a, nextAtomState);
                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {
                    changedAtoms.add(a);
                }
            }
            markedAtoms.delete(a);
        }
    };
    const writeAtomState = (atom, ...args)=>{
        const getter = (a)=>returnAtomValue(readAtomState(a));
        const setter = (a, ...args2)=>{
            const isSync = pendingStack.length > 0;
            if (!isSync) {
                pendingStack.push(/* @__PURE__ */ new Set([
                    a
                ]));
            }
            let r;
            if (isSelfAtom(atom, a)) {
                if (!hasInitialValue(a)) {
                    throw new Error("atom not writable");
                }
                const prevAtomState = getAtomState(a);
                const nextAtomState = setAtomValueOrPromise(a, args2[0]);
                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {
                    recomputeDependents(a);
                }
            } else {
                r = writeAtomState(a, ...args2);
            }
            if (!isSync) {
                const flushed = flushPending(pendingStack.pop());
                if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
                    devListenersRev2.forEach((l)=>l({
                            type: "async-write",
                            flushed
                        }));
                }
            }
            return r;
        };
        const result = atom.write(getter, setter, ...args);
        return result;
    };
    const writeAtom = (atom, ...args)=>{
        pendingStack.push(/* @__PURE__ */ new Set([
            atom
        ]));
        const result = writeAtomState(atom, ...args);
        const flushed = flushPending(pendingStack.pop());
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            devListenersRev2.forEach((l)=>l({
                    type: "write",
                    flushed
                }));
        }
        return result;
    };
    const mountAtom = (atom, initialDependent, onMountQueue)=>{
        var _a;
        const existingMount = mountedMap.get(atom);
        if (existingMount) {
            if (initialDependent) {
                existingMount.t.add(initialDependent);
            }
            return existingMount;
        }
        const queue = onMountQueue || [];
        (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a)=>{
            if (a !== atom) {
                mountAtom(a, atom, queue);
            }
        });
        readAtomState(atom);
        const mounted = {
            t: new Set(initialDependent && [
                initialDependent
            ]),
            l: /* @__PURE__ */ new Set()
        };
        mountedMap.set(atom, mounted);
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            mountedAtoms.add(atom);
        }
        if (isActuallyWritableAtom(atom) && atom.onMount) {
            const { onMount } = atom;
            queue.push(()=>{
                const onUnmount = onMount((...args)=>writeAtom(atom, ...args));
                if (onUnmount) {
                    mounted.u = onUnmount;
                }
            });
        }
        if (!onMountQueue) {
            queue.forEach((f)=>f());
        }
        return mounted;
    };
    const canUnmountAtom = (atom, mounted)=>!mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));
    const tryUnmountAtom = (atom, mounted)=>{
        if (!canUnmountAtom(atom, mounted)) {
            return;
        }
        const onUnmount = mounted.u;
        if (onUnmount) {
            onUnmount();
        }
        mountedMap.delete(atom);
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            mountedAtoms.delete(atom);
        }
        const atomState = getAtomState(atom);
        if (atomState) {
            if (hasPromiseAtomValue(atomState)) {
                cancelPromise(atomState.v);
            }
            atomState.d.forEach((_, a)=>{
                if (a !== atom) {
                    const mountedDep = mountedMap.get(a);
                    if (mountedDep) {
                        mountedDep.t.delete(atom);
                        tryUnmountAtom(a, mountedDep);
                    }
                }
            });
        } else if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            console.warn("[Bug] could not find atom state to unmount", atom);
        }
    };
    const mountDependencies = (atom, atomState, prevDependencies)=>{
        const depSet = new Set(atomState.d.keys());
        const maybeUnmountAtomSet = /* @__PURE__ */ new Set();
        prevDependencies == null ? void 0 : prevDependencies.forEach((_, a)=>{
            if (depSet.has(a)) {
                depSet.delete(a);
                return;
            }
            maybeUnmountAtomSet.add(a);
            const mounted = mountedMap.get(a);
            if (mounted) {
                mounted.t.delete(atom);
            }
        });
        depSet.forEach((a)=>{
            mountAtom(a, atom);
        });
        maybeUnmountAtomSet.forEach((a)=>{
            const mounted = mountedMap.get(a);
            if (mounted) {
                tryUnmountAtom(a, mounted);
            }
        });
    };
    const flushPending = (pendingAtoms)=>{
        let flushed;
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            flushed = /* @__PURE__ */ new Set();
        }
        const pending = [];
        const collectPending = (pendingAtom)=>{
            var _a;
            if (!pendingMap.has(pendingAtom)) {
                return;
            }
            const [prevAtomState, dependents] = pendingMap.get(pendingAtom);
            pendingMap.delete(pendingAtom);
            pending.push([
                pendingAtom,
                prevAtomState
            ]);
            dependents.forEach(collectPending);
            (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a)=>collectPending(a));
        };
        pendingAtoms.forEach(collectPending);
        pending.forEach(([atom, prevAtomState])=>{
            const atomState = getAtomState(atom);
            if (!atomState) {
                if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
                    console.warn("[Bug] no atom state to flush");
                }
                return;
            }
            if (atomState !== prevAtomState) {
                const mounted = mountedMap.get(atom);
                if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
                    mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
                }
                if (mounted && !// Maybe we could `mountDependencies` in `setAtomState`?
                (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {
                    mounted.l.forEach((listener)=>listener());
                    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
                        flushed.add(atom);
                    }
                }
            }
        });
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            return flushed;
        }
    };
    const subscribeAtom = (atom, listener)=>{
        const mounted = mountAtom(atom);
        const flushed = flushPending([
            atom
        ]);
        const listeners = mounted.l;
        listeners.add(listener);
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            devListenersRev2.forEach((l)=>l({
                    type: "sub",
                    flushed
                }));
        }
        return ()=>{
            listeners.delete(listener);
            tryUnmountAtom(atom, mounted);
            if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
                devListenersRev2.forEach((l)=>l({
                        type: "unsub"
                    }));
            }
        };
    };
    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
        return {
            get: readAtom,
            set: writeAtom,
            sub: subscribeAtom,
            // store dev methods (these are tentative and subject to change without notice)
            dev_subscribe_store: (l)=>{
                devListenersRev2.add(l);
                return ()=>{
                    devListenersRev2.delete(l);
                };
            },
            dev_get_mounted_atoms: ()=>mountedAtoms.values(),
            dev_get_atom_state: (a)=>atomStateMap.get(a),
            dev_get_mounted: (a)=>mountedMap.get(a),
            dev_restore_atoms: (values)=>{
                pendingStack.push(/* @__PURE__ */ new Set());
                for (const [atom, valueOrPromise] of values){
                    if (hasInitialValue(atom)) {
                        setAtomValueOrPromise(atom, valueOrPromise);
                        recomputeDependents(atom);
                    }
                }
                const flushed = flushPending(pendingStack.pop());
                devListenersRev2.forEach((l)=>l({
                        type: "restore",
                        flushed
                    }));
            }
        };
    }
    return {
        get: readAtom,
        set: writeAtom,
        sub: subscribeAtom
    };
};
let defaultStore;
const getDefaultStore$1 = ()=>{
    if (!defaultStore) {
        defaultStore = createStore$1();
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);
            if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {
                console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044");
            }
        }
    }
    return defaultStore;
};
Symbol((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production" ? "CONTINUE_PROMISE" : "");
const createStore = createStore$1;
const getDefaultStore = getDefaultStore$1;
;
}),
"[project]/node_modules/jotai/esm/react.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Provider",
    ()=>Provider,
    "useAtom",
    ()=>useAtom,
    "useAtomValue",
    ()=>useAtomValue,
    "useSetAtom",
    ()=>useSetAtom,
    "useStore",
    ()=>useStore
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jotai/esm/vanilla.mjs [app-client] (ecmascript)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/jotai/esm/react.mjs")}`;
    }
};
'use client';
;
;
const StoreContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(void 0);
const useStore = (options)=>{
    const store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(StoreContext);
    return (options == null ? void 0 : options.store) || store || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultStore"])();
};
const Provider = ({ children, store })=>{
    const storeRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    if (!store && !storeRef.current) {
        storeRef.current = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"])();
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(StoreContext.Provider, {
        value: store || storeRef.current
    }, children);
};
const isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === "function";
const use = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].use || ((promise)=>{
    if (promise.status === "pending") {
        throw promise;
    } else if (promise.status === "fulfilled") {
        return promise.value;
    } else if (promise.status === "rejected") {
        throw promise.reason;
    } else {
        promise.status = "pending";
        promise.then((v)=>{
            promise.status = "fulfilled";
            promise.value = v;
        }, (e)=>{
            promise.status = "rejected";
            promise.reason = e;
        });
        throw promise;
    }
});
function useAtomValue(atom, options) {
    const store = useStore(options);
    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useReducer"])({
        "useAtomValue.useReducer": (prev)=>{
            const nextValue = store.get(atom);
            if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {
                return prev;
            }
            return [
                nextValue,
                store,
                atom
            ];
        }
    }["useAtomValue.useReducer"], void 0, {
        "useAtomValue.useReducer": ()=>[
                store.get(atom),
                store,
                atom
            ]
    }["useAtomValue.useReducer"]);
    let value = valueFromReducer;
    if (storeFromReducer !== store || atomFromReducer !== atom) {
        rerender();
        value = store.get(atom);
    }
    const delay = options == null ? void 0 : options.delay;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useAtomValue.useEffect": ()=>{
            const unsub = store.sub(atom, {
                "useAtomValue.useEffect.unsub": ()=>{
                    if (typeof delay === "number") {
                        setTimeout(rerender, delay);
                        return;
                    }
                    rerender();
                }
            }["useAtomValue.useEffect.unsub"]);
            rerender();
            return unsub;
        }
    }["useAtomValue.useEffect"], [
        store,
        atom,
        delay
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDebugValue"])(value);
    return isPromiseLike(value) ? use(value) : value;
}
function useSetAtom(atom, options) {
    const store = useStore(options);
    const setAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useSetAtom.useCallback[setAtom]": (...args)=>{
            if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production" && !("write" in atom)) {
                throw new Error("not writable atom");
            }
            return store.set(atom, ...args);
        }
    }["useSetAtom.useCallback[setAtom]"], [
        store,
        atom
    ]);
    return setAtom;
}
function useAtom(atom, options) {
    return [
        useAtomValue(atom, options),
        // We do wrong type assertion here, which results in throwing an error.
        useSetAtom(atom, options)
    ];
}
;
}),
"[project]/node_modules/jotai/esm/vanilla/utils.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RESET",
    ()=>RESET,
    "atomFamily",
    ()=>atomFamily,
    "atomWithDefault",
    ()=>atomWithDefault,
    "atomWithLazy",
    ()=>atomWithLazy,
    "atomWithObservable",
    ()=>atomWithObservable,
    "atomWithReducer",
    ()=>atomWithReducer,
    "atomWithRefresh",
    ()=>atomWithRefresh,
    "atomWithReset",
    ()=>atomWithReset,
    "atomWithStorage",
    ()=>atomWithStorage,
    "createJSONStorage",
    ()=>createJSONStorage,
    "freezeAtom",
    ()=>freezeAtom,
    "freezeAtomCreator",
    ()=>freezeAtomCreator,
    "loadable",
    ()=>loadable,
    "selectAtom",
    ()=>selectAtom,
    "splitAtom",
    ()=>splitAtom,
    "unstable_withStorageValidator",
    ()=>withStorageValidator,
    "unwrap",
    ()=>unwrap
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jotai/esm/vanilla.mjs [app-client] (ecmascript)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/jotai/esm/vanilla/utils.mjs")}`;
    }
};
;
const RESET = Symbol((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production" ? "RESET" : "");
function atomWithReset(initialValue) {
    const anAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(initialValue, (get, set, update)=>{
        const nextValue = typeof update === "function" ? update(get(anAtom)) : update;
        set(anAtom, nextValue === RESET ? initialValue : nextValue);
    });
    return anAtom;
}
function atomWithReducer(initialValue, reducer) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(initialValue, function(get, set, action) {
        set(this, reducer(get(this), action));
    });
}
function atomFamily(initializeAtom, areEqual) {
    let shouldRemove = null;
    const atoms = /* @__PURE__ */ new Map();
    const createAtom = (param)=>{
        let item;
        if (areEqual === void 0) {
            item = atoms.get(param);
        } else {
            for (const [key, value] of atoms){
                if (areEqual(key, param)) {
                    item = value;
                    break;
                }
            }
        }
        if (item !== void 0) {
            if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {
                createAtom.remove(param);
            } else {
                return item[0];
            }
        }
        const newAtom = initializeAtom(param);
        atoms.set(param, [
            newAtom,
            Date.now()
        ]);
        return newAtom;
    };
    createAtom.remove = (param)=>{
        if (areEqual === void 0) {
            atoms.delete(param);
        } else {
            for (const [key] of atoms){
                if (areEqual(key, param)) {
                    atoms.delete(key);
                    break;
                }
            }
        }
    };
    createAtom.setShouldRemove = (fn)=>{
        shouldRemove = fn;
        if (!shouldRemove) return;
        for (const [key, value] of atoms){
            if (shouldRemove(value[1], key)) {
                atoms.delete(key);
            }
        }
    };
    return createAtom;
}
const getCached$2 = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);
const cache1$3 = /* @__PURE__ */ new WeakMap();
const memo3 = (create, dep1, dep2, dep3)=>{
    const cache2 = getCached$2(()=>/* @__PURE__ */ new WeakMap(), cache1$3, dep1);
    const cache3 = getCached$2(()=>/* @__PURE__ */ new WeakMap(), cache2, dep2);
    return getCached$2(create, cache3, dep3);
};
function selectAtom(anAtom, selector, equalityFn = Object.is) {
    return memo3(()=>{
        const EMPTY = Symbol();
        const selectValue = ([value, prevSlice])=>{
            if (prevSlice === EMPTY) {
                return selector(value);
            }
            const slice = selector(value, prevSlice);
            return equalityFn(prevSlice, slice) ? prevSlice : slice;
        };
        const derivedAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>{
            const prev = get(derivedAtom);
            const value = get(anAtom);
            return selectValue([
                value,
                prev
            ]);
        });
        derivedAtom.init = EMPTY;
        return derivedAtom;
    }, anAtom, selector, equalityFn);
}
const frozenAtoms = /* @__PURE__ */ new WeakSet();
const deepFreeze = (obj)=>{
    if (typeof obj !== "object" || obj === null) return;
    Object.freeze(obj);
    const propNames = Object.getOwnPropertyNames(obj);
    for (const name of propNames){
        const value = obj[name];
        deepFreeze(value);
    }
    return obj;
};
function freezeAtom(anAtom) {
    if (frozenAtoms.has(anAtom)) {
        return anAtom;
    }
    frozenAtoms.add(anAtom);
    const origRead = anAtom.read;
    anAtom.read = function(get, options) {
        return deepFreeze(origRead.call(this, get, options));
    };
    if ("write" in anAtom) {
        const origWrite = anAtom.write;
        anAtom.write = function(get, set, ...args) {
            return origWrite.call(this, get, (...setArgs)=>{
                if (setArgs[0] === anAtom) {
                    setArgs[1] = deepFreeze(setArgs[1]);
                }
                return set(...setArgs);
            }, ...args);
        };
    }
    return anAtom;
}
function freezeAtomCreator(createAtom) {
    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
        console.warn("[DEPRECATED] freezeAtomCreator is deprecated, define it on users end");
    }
    return (...args)=>freezeAtom(createAtom(...args));
}
const getCached$1 = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);
const cache1$2 = /* @__PURE__ */ new WeakMap();
const memo2$1 = (create, dep1, dep2)=>{
    const cache2 = getCached$1(()=>/* @__PURE__ */ new WeakMap(), cache1$2, dep1);
    return getCached$1(create, cache2, dep2);
};
const cacheKeyForEmptyKeyExtractor = {};
const isWritable = (atom2)=>!!atom2.write;
const isFunction = (x)=>typeof x === "function";
function splitAtom(arrAtom, keyExtractor) {
    return memo2$1(()=>{
        const mappingCache = /* @__PURE__ */ new WeakMap();
        const getMapping = (arr, prev)=>{
            let mapping = mappingCache.get(arr);
            if (mapping) {
                return mapping;
            }
            const prevMapping = prev && mappingCache.get(prev);
            const atomList = [];
            const keyList = [];
            arr.forEach((item, index)=>{
                const key = keyExtractor ? keyExtractor(item) : index;
                keyList[index] = key;
                const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];
                if (cachedAtom) {
                    atomList[index] = cachedAtom;
                    return;
                }
                const read = (get)=>{
                    const prev2 = get(mappingAtom);
                    const currArr = get(arrAtom);
                    const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);
                    const index2 = mapping2.keyList.indexOf(key);
                    if (index2 < 0 || index2 >= currArr.length) {
                        const prevItem = arr[getMapping(arr).keyList.indexOf(key)];
                        if (prevItem) {
                            return prevItem;
                        }
                        throw new Error("splitAtom: index out of bounds for read");
                    }
                    return currArr[index2];
                };
                const write = (get, set, update)=>{
                    const prev2 = get(mappingAtom);
                    const arr2 = get(arrAtom);
                    const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);
                    const index2 = mapping2.keyList.indexOf(key);
                    if (index2 < 0 || index2 >= arr2.length) {
                        throw new Error("splitAtom: index out of bounds for write");
                    }
                    const nextItem = isFunction(update) ? update(arr2[index2]) : update;
                    if (!Object.is(arr2[index2], nextItem)) {
                        set(arrAtom, [
                            ...arr2.slice(0, index2),
                            nextItem,
                            ...arr2.slice(index2 + 1)
                        ]);
                    }
                };
                atomList[index] = isWritable(arrAtom) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(read, write) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(read);
            });
            if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i)=>x === keyList[i])) {
                mapping = prevMapping;
            } else {
                mapping = {
                    arr,
                    atomList,
                    keyList
                };
            }
            mappingCache.set(arr, mapping);
            return mapping;
        };
        const mappingAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>{
            const prev = get(mappingAtom);
            const arr = get(arrAtom);
            const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);
            return mapping;
        });
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            mappingAtom.debugPrivate = true;
        }
        mappingAtom.init = void 0;
        const splittedAtom = isWritable(arrAtom) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>get(mappingAtom).atomList, (get, set, action)=>{
            switch(action.type){
                case "remove":
                    {
                        const index = get(splittedAtom).indexOf(action.atom);
                        if (index >= 0) {
                            const arr = get(arrAtom);
                            set(arrAtom, [
                                ...arr.slice(0, index),
                                ...arr.slice(index + 1)
                            ]);
                        }
                        break;
                    }
                case "insert":
                    {
                        const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;
                        if (index >= 0) {
                            const arr = get(arrAtom);
                            set(arrAtom, [
                                ...arr.slice(0, index),
                                action.value,
                                ...arr.slice(index)
                            ]);
                        }
                        break;
                    }
                case "move":
                    {
                        const index1 = get(splittedAtom).indexOf(action.atom);
                        const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;
                        if (index1 >= 0 && index2 >= 0) {
                            const arr = get(arrAtom);
                            if (index1 < index2) {
                                set(arrAtom, [
                                    ...arr.slice(0, index1),
                                    ...arr.slice(index1 + 1, index2),
                                    arr[index1],
                                    ...arr.slice(index2)
                                ]);
                            } else {
                                set(arrAtom, [
                                    ...arr.slice(0, index2),
                                    arr[index1],
                                    ...arr.slice(index2, index1),
                                    ...arr.slice(index1 + 1)
                                ]);
                            }
                        }
                        break;
                    }
            }
        }) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>get(mappingAtom).atomList);
        return splittedAtom;
    }, arrAtom, keyExtractor || cacheKeyForEmptyKeyExtractor);
}
function atomWithDefault(getDefault) {
    const EMPTY = Symbol();
    const overwrittenAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(EMPTY);
    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
        overwrittenAtom.debugPrivate = true;
    }
    const anAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get, options)=>{
        const overwritten = get(overwrittenAtom);
        if (overwritten !== EMPTY) {
            return overwritten;
        }
        return getDefault(get, options);
    }, (get, set, update)=>{
        if (update === RESET) {
            set(overwrittenAtom, EMPTY);
        } else if (typeof update === "function") {
            const prevValue = get(anAtom);
            set(overwrittenAtom, update(prevValue));
        } else {
            set(overwrittenAtom, update);
        }
    });
    return anAtom;
}
const isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === "function";
function withStorageValidator(validator) {
    return (unknownStorage)=>{
        const storage = {
            ...unknownStorage,
            getItem: (key, initialValue)=>{
                const validate = (value2)=>{
                    if (!validator(value2)) {
                        return initialValue;
                    }
                    return value2;
                };
                const value = unknownStorage.getItem(key, initialValue);
                if (isPromiseLike(value)) {
                    return value.then(validate);
                }
                return validate(value);
            }
        };
        return storage;
    };
}
function createJSONStorage(getStringStorage = ()=>{
    try {
        return window.localStorage;
    } catch (e) {
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            if (typeof window !== "undefined") {
                console.warn(e);
            }
        }
        return void 0;
    }
}, options) {
    var _a;
    let lastStr;
    let lastValue;
    const storage = {
        getItem: (key, initialValue)=>{
            var _a2, _b;
            const parse = (str2)=>{
                str2 = str2 || "";
                if (lastStr !== str2) {
                    try {
                        lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);
                    } catch (e) {
                        return initialValue;
                    }
                    lastStr = str2;
                }
                return lastValue;
            };
            const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;
            if (isPromiseLike(str)) {
                return str.then(parse);
            }
            return parse(str);
        },
        setItem: (key, newValue)=>{
            var _a2;
            return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(key, JSON.stringify(newValue, options == null ? void 0 : options.replacer));
        },
        removeItem: (key)=>{
            var _a2;
            return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);
        }
    };
    const createHandleSubscribe = (subscriber2)=>(key, callback, initialValue)=>subscriber2(key, (v)=>{
                let newValue;
                try {
                    newValue = JSON.parse(v || "");
                } catch (e) {
                    newValue = initialValue;
                }
                callback(newValue);
            });
    let subscriber;
    try {
        subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;
    } catch (e) {}
    if (!subscriber && typeof window !== "undefined" && typeof window.addEventListener === "function" && window.Storage) {
        subscriber = (key, callback)=>{
            if (!(getStringStorage() instanceof window.Storage)) {
                return ()=>{};
            }
            const storageEventCallback = (e)=>{
                if (e.storageArea === getStringStorage() && e.key === key) {
                    callback(e.newValue);
                }
            };
            window.addEventListener("storage", storageEventCallback);
            return ()=>{
                window.removeEventListener("storage", storageEventCallback);
            };
        };
    }
    if (subscriber) {
        storage.subscribe = createHandleSubscribe(subscriber);
    }
    return storage;
}
const defaultStorage = createJSONStorage();
function atomWithStorage(key, initialValue, storage = defaultStorage, options) {
    const getOnInit = options == null ? void 0 : options.getOnInit;
    const baseAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(getOnInit ? storage.getItem(key, initialValue) : initialValue);
    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
        baseAtom.debugPrivate = true;
    }
    baseAtom.onMount = (setAtom)=>{
        setAtom(storage.getItem(key, initialValue));
        let unsub;
        if (storage.subscribe) {
            unsub = storage.subscribe(key, setAtom, initialValue);
        }
        return unsub;
    };
    const anAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>get(baseAtom), (get, set, update)=>{
        const nextValue = typeof update === "function" ? update(get(baseAtom)) : update;
        if (nextValue === RESET) {
            set(baseAtom, initialValue);
            return storage.removeItem(key);
        }
        if (nextValue instanceof Promise) {
            return nextValue.then((resolvedValue)=>{
                set(baseAtom, resolvedValue);
                return storage.setItem(key, resolvedValue);
            });
        }
        set(baseAtom, nextValue);
        return storage.setItem(key, nextValue);
    });
    return anAtom;
}
function atomWithObservable(getObservable, options) {
    const returnResultData = (result)=>{
        if ("e" in result) {
            throw result.e;
        }
        return result.d;
    };
    const observableResultAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>{
        var _a;
        let observable = getObservable(get);
        const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);
        if (itself) {
            observable = itself;
        }
        let resolve;
        const makePending = ()=>new Promise((r)=>{
                resolve = r;
            });
        const initialResult = options && "initialValue" in options ? {
            d: typeof options.initialValue === "function" ? options.initialValue() : options.initialValue
        } : makePending();
        let setResult;
        let lastResult;
        const listener = (result)=>{
            lastResult = result;
            resolve == null ? void 0 : resolve(result);
            setResult == null ? void 0 : setResult(result);
        };
        let subscription;
        let timer;
        const isNotMounted = ()=>!setResult;
        const start = ()=>{
            if (subscription) {
                clearTimeout(timer);
                subscription.unsubscribe();
            }
            subscription = observable.subscribe({
                next: (d)=>listener({
                        d
                    }),
                error: (e)=>listener({
                        e
                    }),
                complete: ()=>{}
            });
            if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {
                timer = setTimeout(()=>{
                    if (subscription) {
                        subscription.unsubscribe();
                        subscription = void 0;
                    }
                }, options.unstable_timeout);
            }
        };
        start();
        const resultAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(lastResult || initialResult);
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            resultAtom.debugPrivate = true;
        }
        resultAtom.onMount = (update)=>{
            setResult = update;
            if (lastResult) {
                update(lastResult);
            }
            if (subscription) {
                clearTimeout(timer);
            } else {
                start();
            }
            return ()=>{
                setResult = void 0;
                if (subscription) {
                    subscription.unsubscribe();
                    subscription = void 0;
                }
            };
        };
        return [
            resultAtom,
            observable,
            makePending,
            start,
            isNotMounted
        ];
    });
    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
        observableResultAtom.debugPrivate = true;
    }
    const observableAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>{
        const [resultAtom] = get(observableResultAtom);
        const result = get(resultAtom);
        if (result instanceof Promise) {
            return result.then(returnResultData);
        }
        return returnResultData(result);
    }, (get, set, data)=>{
        const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);
        if ("next" in observable) {
            if (isNotMounted()) {
                set(resultAtom, makePending());
                start();
            }
            observable.next(data);
        } else {
            throw new Error("observable is not subject");
        }
    });
    return observableAtom;
}
const cache1$1 = /* @__PURE__ */ new WeakMap();
const memo1 = (create, dep1)=>(cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);
const isPromise$1 = (x)=>x instanceof Promise;
const LOADING = {
    state: "loading"
};
function loadable(anAtom) {
    return memo1(()=>{
        const loadableCache = /* @__PURE__ */ new WeakMap();
        const refreshAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(0);
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            refreshAtom.debugPrivate = true;
        }
        const derivedAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get, { setSelf })=>{
            get(refreshAtom);
            let value;
            try {
                value = get(anAtom);
            } catch (error) {
                return {
                    state: "hasError",
                    error
                };
            }
            if (!isPromise$1(value)) {
                return {
                    state: "hasData",
                    data: value
                };
            }
            const promise = value;
            const cached1 = loadableCache.get(promise);
            if (cached1) {
                return cached1;
            }
            if (promise.status === "fulfilled") {
                loadableCache.set(promise, {
                    state: "hasData",
                    data: promise.value
                });
            } else if (promise.status === "rejected") {
                loadableCache.set(promise, {
                    state: "hasError",
                    error: promise.reason
                });
            } else {
                promise.then((data)=>{
                    loadableCache.set(promise, {
                        state: "hasData",
                        data
                    });
                }, (error)=>{
                    loadableCache.set(promise, {
                        state: "hasError",
                        error
                    });
                }).finally(setSelf);
            }
            const cached2 = loadableCache.get(promise);
            if (cached2) {
                return cached2;
            }
            loadableCache.set(promise, LOADING);
            return LOADING;
        }, (_get, set)=>{
            set(refreshAtom, (c)=>c + 1);
        });
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            derivedAtom.debugPrivate = true;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>get(derivedAtom));
    }, anAtom);
}
const getCached = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);
const cache1 = /* @__PURE__ */ new WeakMap();
const memo2 = (create, dep1, dep2)=>{
    const cache2 = getCached(()=>/* @__PURE__ */ new WeakMap(), cache1, dep1);
    return getCached(create, cache2, dep2);
};
const isPromise = (x)=>x instanceof Promise;
const defaultFallback = ()=>void 0;
function unwrap(anAtom, fallback = defaultFallback) {
    return memo2(()=>{
        const promiseErrorCache = /* @__PURE__ */ new WeakMap();
        const promiseResultCache = /* @__PURE__ */ new WeakMap();
        const refreshAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(0);
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            refreshAtom.debugPrivate = true;
        }
        const promiseAndValueAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get, { setSelf })=>{
            get(refreshAtom);
            const prev = get(promiseAndValueAtom);
            const promise = get(anAtom);
            if (!isPromise(promise)) {
                return {
                    v: promise
                };
            }
            if (promise !== (prev == null ? void 0 : prev.p)) {
                if (promise.status === "fulfilled") {
                    promiseResultCache.set(promise, promise.value);
                } else if (promise.status === "rejected") {
                    promiseErrorCache.set(promise, promise.reason);
                } else {
                    promise.then((v)=>promiseResultCache.set(promise, v), (e)=>promiseErrorCache.set(promise, e)).finally(setSelf);
                }
            }
            if (promiseErrorCache.has(promise)) {
                throw promiseErrorCache.get(promise);
            }
            if (promiseResultCache.has(promise)) {
                return {
                    p: promise,
                    v: promiseResultCache.get(promise)
                };
            }
            if (prev && "v" in prev) {
                return {
                    p: promise,
                    f: fallback(prev.v),
                    v: prev.v
                };
            }
            return {
                p: promise,
                f: fallback()
            };
        }, (_get, set)=>{
            set(refreshAtom, (c)=>c + 1);
        });
        promiseAndValueAtom.init = void 0;
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            promiseAndValueAtom.debugPrivate = true;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>{
            const state = get(promiseAndValueAtom);
            if ("f" in state) {
                return state.f;
            }
            return state.v;
        }, (_get, set, ...args)=>set(anAtom, ...args));
    }, anAtom, fallback);
}
function atomWithRefresh(read, write) {
    const refreshAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(0);
    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
        refreshAtom.debugPrivate = true;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get, options)=>{
        get(refreshAtom);
        return read(get, options);
    }, (get, set, ...args)=>{
        if (args.length === 0) {
            set(refreshAtom, (c)=>c + 1);
        } else if (write) {
            return write(get, set, ...args);
        }
    });
}
function atomWithLazy(makeInitial) {
    const a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(void 0);
    delete a.init;
    Object.defineProperty(a, "init", {
        get () {
            return makeInitial();
        }
    });
    return a;
}
;
}),
"[project]/node_modules/jotai/esm/react/utils.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useAtomCallback",
    ()=>useAtomCallback,
    "useHydrateAtoms",
    ()=>useHydrateAtoms,
    "useReducerAtom",
    ()=>useReducerAtom,
    "useResetAtom",
    ()=>useResetAtom
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jotai/esm/react.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jotai/esm/vanilla/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jotai/esm/vanilla.mjs [app-client] (ecmascript)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/jotai/esm/react/utils.mjs")}`;
    }
};
'use client';
;
;
;
;
function useResetAtom(anAtom, options) {
    const setAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetAtom"])(anAtom, options);
    const resetAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useResetAtom.useCallback[resetAtom]": ()=>setAtom(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RESET"])
    }["useResetAtom.useCallback[resetAtom]"], [
        setAtom
    ]);
    return resetAtom;
}
function useReducerAtom(anAtom, reducer, options) {
    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
        console.warn("[DEPRECATED] useReducerAtom is deprecated and will be removed in the future. Please create your own version using the recipe. https://github.com/pmndrs/jotai/pull/2467");
    }
    const [state, setState] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useAtom"])(anAtom, options);
    const dispatch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useReducerAtom.useCallback[dispatch]": (action)=>{
            setState({
                "useReducerAtom.useCallback[dispatch]": (prev)=>reducer(prev, action)
            }["useReducerAtom.useCallback[dispatch]"]);
        }
    }["useReducerAtom.useCallback[dispatch]"], [
        setState,
        reducer
    ]);
    return [
        state,
        dispatch
    ];
}
function useAtomCallback(callback, options) {
    const anAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useAtomCallback.useMemo[anAtom]": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(null, {
                "useAtomCallback.useMemo[anAtom]": (get, set, ...args)=>callback(get, set, ...args)
            }["useAtomCallback.useMemo[anAtom]"])
    }["useAtomCallback.useMemo[anAtom]"], [
        callback
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetAtom"])(anAtom, options);
}
const hydratedMap = /* @__PURE__ */ new WeakMap();
function useHydrateAtoms(values, options) {
    const store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useStore"])(options);
    const hydratedSet = getHydratedSet(store);
    for (const [atom, value] of values){
        if (!hydratedSet.has(atom) || (options == null ? void 0 : options.dangerouslyForceHydrate)) {
            hydratedSet.add(atom);
            store.set(atom, value);
        }
    }
}
const getHydratedSet = (store)=>{
    let hydratedSet = hydratedMap.get(store);
    if (!hydratedSet) {
        hydratedSet = /* @__PURE__ */ new WeakSet();
        hydratedMap.set(store, hydratedSet);
    }
    return hydratedSet;
};
;
}),
"[project]/node_modules/jotai-x/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HydrateAtoms",
    ()=>HydrateAtoms,
    "atomWithFn",
    ()=>atomWithFn,
    "createAtomProvider",
    ()=>createAtomProvider,
    "createAtomStore",
    ()=>createAtomStore,
    "useAtomStore",
    ()=>useAtomStore,
    "useAtomStoreSet",
    ()=>useAtomStoreSet,
    "useAtomStoreState",
    ()=>useAtomStoreState,
    "useAtomStoreValue",
    ()=>useAtomStoreValue,
    "useHydrateStore",
    ()=>useHydrateStore,
    "useStoreAtomState",
    ()=>useStoreAtomState,
    "useStoreAtomValue",
    ()=>useStoreAtomValue,
    "useStoreSetAtom",
    ()=>useStoreSetAtom,
    "useSyncStore",
    ()=>useSyncStore
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
// src/atomWithFn.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jotai/esm/vanilla.mjs [app-client] (ecmascript)");
// src/createAtomProvider.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jotai/esm/react.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jotai/esm/react/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jotai/esm/vanilla/utils.mjs [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
;
var wrapFn = (fnOrValue)=>typeof fnOrValue === "function" ? {
        __fn: fnOrValue
    } : fnOrValue;
var unwrapFn = (wrappedFnOrValue)=>wrappedFnOrValue && typeof wrappedFnOrValue === "object" && "__fn" in wrappedFnOrValue ? wrappedFnOrValue.__fn : wrappedFnOrValue;
var atomWithFn = (initialValue)=>{
    const baseAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])(wrapFn(initialValue));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>unwrapFn(get(baseAtom)), (_get, set, value)=>set(baseAtom, wrapFn(value)));
};
;
;
;
;
;
var useHydrateStore = (atoms, initialValues, options = {})=>{
    const values = [];
    for (const key of Object.keys(atoms)){
        const initialValue = initialValues[key];
        if (initialValue !== void 0) {
            values.push([
                atoms[key],
                initialValue
            ]);
        }
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useHydrateAtoms"])(values, options);
};
var useSyncStore = (atoms, values, { store } = {})=>{
    for (const key of Object.keys(atoms)){
        const value = values[key];
        const atom2 = atoms[key];
        const set = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetAtom"])(atom2, {
            store
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
            "useSyncStore.useEffect": ()=>{
                if (value !== void 0 && value !== null) {
                    set(value);
                }
            }
        }["useSyncStore.useEffect"], [
            set,
            value
        ]);
    }
};
// src/createAtomProvider.tsx
var getFullyQualifiedScope = (storeName, scope)=>{
    return `${storeName}:${scope}`;
};
var PROVIDER_SCOPE = "provider";
var AtomStoreContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createContext(/* @__PURE__ */ new Map());
var useAtomStore = (storeName, scope = PROVIDER_SCOPE, warnIfUndefined = true)=>{
    var _a;
    const storeContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useContext(AtomStoreContext);
    const store = (_a = storeContext.get(getFullyQualifiedScope(storeName, scope))) != null ? _a : storeContext.get(getFullyQualifiedScope(storeName, PROVIDER_SCOPE));
    if (!store && warnIfUndefined) {
        console.warn(`Tried to access jotai store '${storeName}' outside of a matching provider.`);
    }
    return store;
};
var HydrateAtoms = (_a)=>{
    var _b = _a, { initialValues, children, store, atoms } = _b, props = __objRest(_b, [
        "initialValues",
        "children",
        "store",
        "atoms"
    ]);
    useHydrateStore(atoms, __spreadValues(__spreadValues({}, initialValues), props), {
        store
    });
    useSyncStore(atoms, props, {
        store
    });
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, children);
};
var createAtomProvider = (storeScope, atoms, options = {})=>{
    const Effect = options.effect;
    return (_a)=>{
        var _b = _a, { store, scope, children, resetKey } = _b, props = __objRest(_b, [
            "store",
            "scope",
            "children",
            "resetKey"
        ]);
        const [storeState, setStoreState] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"])());
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
            "createAtomProvider.useEffect": ()=>{
                if (resetKey) {
                    setStoreState((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"])());
                }
            }
        }["createAtomProvider.useEffect"], [
            resetKey
        ]);
        const previousStoreContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useContext(AtomStoreContext);
        const storeContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
            "createAtomProvider.useMemo[storeContext]": ()=>{
                const newStoreContext = new Map(previousStoreContext);
                if (scope) {
                    newStoreContext.set(getFullyQualifiedScope(storeScope, scope), storeState);
                }
                newStoreContext.set(getFullyQualifiedScope(storeScope, PROVIDER_SCOPE), storeState);
                return newStoreContext;
            }
        }["createAtomProvider.useMemo[storeContext]"], [
            previousStoreContext,
            scope,
            storeState
        ]);
        return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(AtomStoreContext.Provider, {
            value: storeContext
        }, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(HydrateAtoms, __spreadValues({
            store: storeState,
            atoms
        }, props), !!Effect && /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Effect, null), children));
    };
};
;
;
;
var capitalizeFirstLetter = (str = "")=>str.length > 0 ? str[0].toUpperCase() + str.slice(1) : "";
var getProviderIndex = (name = "")=>`${capitalizeFirstLetter(name)}Provider`;
var getStoreIndex = (name = "")=>name.length > 0 ? `${name}Store` : "store";
var getUseStoreIndex = (name = "")=>`use${capitalizeFirstLetter(name)}Store`;
var getUseValueIndex = (key = "")=>`use${capitalizeFirstLetter(key)}Value`;
var getGetIndex = (key = "")=>`get${capitalizeFirstLetter(key)}`;
var getUseSetIndex = (key = "")=>`useSet${capitalizeFirstLetter(key)}`;
var getSetIndex = (key = "")=>`set${capitalizeFirstLetter(key)}`;
var getUseStateIndex = (key = "")=>`use${capitalizeFirstLetter(key)}State`;
var getSubscribeIndex = (key = "")=>`subscribe${capitalizeFirstLetter(key)}`;
var isAtom = (possibleAtom)=>!!possibleAtom && typeof possibleAtom === "object" && "read" in possibleAtom && typeof possibleAtom.read === "function";
var withStoreAndOptions = (fnRecord, getIndex, store, options)=>Object.fromEntries(Object.entries(fnRecord).map(([key, fn])=>[
            getIndex(key),
            (...args)=>fn(store, options, ...args)
        ]));
var withKeyAndStoreAndOptions = (fnRecord, store, options)=>(key, ...args)=>fnRecord[key](store, options, ...args);
var convertScopeShorthand = (optionsOrScope = {})=>typeof optionsOrScope === "string" ? {
        scope: optionsOrScope
    } : optionsOrScope;
var useConvertScopeShorthand = (optionsOrScope)=>{
    const convertedOptions = convertScopeShorthand(optionsOrScope);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useConvertScopeShorthand.useMemo": ()=>convertedOptions
    }["useConvertScopeShorthand.useMemo"], Object.values(convertedOptions));
};
var identity = (x)=>x;
var createAtomStore = (initialState, { name, delay: delayRoot, effect, extend, infiniteRenderDetectionLimit = 1e5, suppressWarnings })=>{
    const providerIndex = getProviderIndex(name);
    const useStoreIndex = getUseStoreIndex(name);
    const storeIndex = getStoreIndex(name);
    const atomsWithoutExtend = {};
    const writableAtomsWithoutExtend = {};
    const atomIsWritable = {};
    for (const [key, atomOrValue] of Object.entries(initialState)){
        const atomConfig = isAtom(atomOrValue) ? atomOrValue : atomWithFn(atomOrValue);
        atomsWithoutExtend[key] = atomConfig;
        const writable = "write" in atomConfig;
        atomIsWritable[key] = writable;
        if (writable) {
            writableAtomsWithoutExtend[key] = atomConfig;
        }
    }
    const atoms = __spreadValues({}, atomsWithoutExtend);
    if (extend) {
        const extendedAtoms = extend(atomsWithoutExtend);
        for (const [key, atomConfig] of Object.entries(extendedAtoms)){
            atoms[key] = atomConfig;
            atomIsWritable[key] = "write" in atomConfig;
        }
    }
    const atomsOfUseValue = {};
    const atomsOfGet = {};
    const atomsOfUseSet = {};
    const atomsOfSet = {};
    const atomsOfUseState = {};
    const atomsOfSubscribe = {};
    const useStore = (optionsOrScope = {})=>{
        const { scope, store, warnIfNoStore = !suppressWarnings } = convertScopeShorthand(optionsOrScope);
        const contextStore = useAtomStore(name, scope, !store && warnIfNoStore);
        return store != null ? store : contextStore;
    };
    let renderCount = 0;
    const useAtomValueWithStore = (atomConfig, store, optionsOrScope, selector, equalityFnOrDeps, deps)=>{
        var _a, _b;
        if (("TURBOPACK compile-time value", "development") !== "production" && infiniteRenderDetectionLimit) {
            renderCount += 1;
            if (renderCount > infiniteRenderDetectionLimit) {
                throw new Error(`
use<Key>Value/useValue/use<StoreName>Value has rendered ${infiniteRenderDetectionLimit} times in the same render.
It is very likely to have fallen into an infinite loop.
That is because you do not memoize the selector/equalityFn function param.
Please wrap them with useCallback or configure the deps array correctly.`);
            }
            setTimeout(()=>{
                renderCount = 0;
            });
        }
        const options = convertScopeShorthand(optionsOrScope);
        selector != null ? selector : selector = identity;
        const equalityFn = typeof equalityFnOrDeps === "function" ? equalityFnOrDeps : void 0;
        deps = (_a = typeof equalityFnOrDeps === "function" ? deps : equalityFnOrDeps) != null ? _a : [
            selector,
            equalityFn
        ];
        const [memoizedSelector, memoizedEqualityFn] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
            "createAtomStore.useAtomValueWithStore.useMemo": ()=>[
                    selector,
                    equalityFn
                ]
        }["createAtomStore.useAtomValueWithStore.useMemo"], deps);
        const selectorAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectAtom"])(atomConfig, memoizedSelector, memoizedEqualityFn);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useAtomValue"])(selectorAtom, {
            store,
            delay: (_b = options.delay) != null ? _b : delayRoot
        });
    };
    const getAtomWithStore = (atomConfig, store, _optionsOrScope)=>{
        return (store != null ? store : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultStore"])()).get(atomConfig);
    };
    const useSetAtomWithStore = (atomConfig, store, _optionsOrScope)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSetAtom"])(atomConfig, {
            store
        });
    };
    const setAtomWithStore = (atomConfig, store, _optionsOrScope)=>{
        return (...args)=>(store != null ? store : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultStore"])()).set(atomConfig, ...args);
    };
    const useAtomStateWithStore = (atomConfig, store, optionsOrScope)=>{
        const { delay = delayRoot } = convertScopeShorthand(optionsOrScope);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$react$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useAtom"])(atomConfig, {
            store,
            delay
        });
    };
    const subscribeAtomWithStore = (atomConfig, store, _optionsOrScope)=>{
        return (callback)=>{
            store != null ? store : store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultStore"])();
            const unsubscribe = store.sub(atomConfig, ()=>{
                callback(store.get(atomConfig));
            });
            return ()=>unsubscribe();
        };
    };
    for (const key of Object.keys(atoms)){
        const atomConfig = atoms[key];
        const isWritable = atomIsWritable[key];
        atomsOfUseValue[key] = (store, optionsOrScope = {}, selector, equalityFnOrDeps, deps)=>useAtomValueWithStore(atomConfig, store, optionsOrScope, selector, equalityFnOrDeps, deps);
        atomsOfGet[key] = (store, optionsOrScope = {})=>getAtomWithStore(atomConfig, store, optionsOrScope);
        atomsOfSubscribe[key] = (store, optionsOrScope = {}, callback)=>subscribeAtomWithStore(atomConfig, store, optionsOrScope)(callback);
        if (isWritable) {
            atomsOfUseSet[key] = (store, optionsOrScope = {})=>useSetAtomWithStore(atomConfig, store, optionsOrScope);
            atomsOfSet[key] = (store, optionsOrScope = {}, ...args)=>setAtomWithStore(atomConfig, store, optionsOrScope)(...args);
            atomsOfUseState[key] = (store, optionsOrScope = {})=>useAtomStateWithStore(atomConfig, store, optionsOrScope);
        }
    }
    const Provider = createAtomProvider(name, writableAtomsWithoutExtend, {
        effect
    });
    const storeApi = {
        atom: atoms,
        name
    };
    const useStoreApi = (options = {})=>{
        const convertedOptions = useConvertScopeShorthand(options);
        const store = useStore(convertedOptions);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
            "createAtomStore.useStoreApi.useMemo": ()=>__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, withStoreAndOptions(atomsOfUseValue, getUseValueIndex, store, convertedOptions)), withStoreAndOptions(atomsOfGet, getGetIndex, store, convertedOptions)), withStoreAndOptions(atomsOfUseSet, getUseSetIndex, store, convertedOptions)), withStoreAndOptions(atomsOfSet, getSetIndex, store, convertedOptions)), withStoreAndOptions(atomsOfUseState, getUseStateIndex, store, convertedOptions)), withStoreAndOptions(atomsOfSubscribe, getSubscribeIndex, store, convertedOptions)), {
                    // store.useValue('key')
                    useValue: withKeyAndStoreAndOptions(atomsOfUseValue, store, convertedOptions),
                    // store.get('key')
                    get: withKeyAndStoreAndOptions(atomsOfGet, store, convertedOptions),
                    // store.useSet('key')
                    useSet: withKeyAndStoreAndOptions(atomsOfUseSet, store, convertedOptions),
                    // store.set('key', ...args)
                    set: withKeyAndStoreAndOptions(atomsOfSet, store, convertedOptions),
                    // store.useState('key')
                    useState: withKeyAndStoreAndOptions(atomsOfUseState, store, convertedOptions),
                    // store.subscribe('key', callback)
                    subscribe: withKeyAndStoreAndOptions(atomsOfSubscribe, store, convertedOptions),
                    // store.useAtomValue(atomConfig)
                    useAtomValue: {
                        "createAtomStore.useStoreApi.useMemo": (atomConfig, selector, equalityFnOrDeps, deps)=>// eslint-disable-next-line react-compiler/react-compiler
                            useAtomValueWithStore(atomConfig, store, convertedOptions, selector, equalityFnOrDeps, deps)
                    }["createAtomStore.useStoreApi.useMemo"],
                    // store.getAtom(atomConfig)
                    getAtom: {
                        "createAtomStore.useStoreApi.useMemo": (atomConfig)=>getAtomWithStore(atomConfig, store, convertedOptions)
                    }["createAtomStore.useStoreApi.useMemo"],
                    // store.useSetAtom(atomConfig)
                    useSetAtom: {
                        "createAtomStore.useStoreApi.useMemo": (atomConfig)=>// eslint-disable-next-line react-compiler/react-compiler
                            useSetAtomWithStore(atomConfig, store, convertedOptions)
                    }["createAtomStore.useStoreApi.useMemo"],
                    // store.setAtom(atomConfig, ...args)
                    setAtom: {
                        "createAtomStore.useStoreApi.useMemo": (atomConfig)=>setAtomWithStore(atomConfig, store, convertedOptions)
                    }["createAtomStore.useStoreApi.useMemo"],
                    // store.useAtomState(atomConfig)
                    useAtomState: {
                        "createAtomStore.useStoreApi.useMemo": (atomConfig)=>// eslint-disable-next-line react-compiler/react-compiler
                            useAtomStateWithStore(atomConfig, store, convertedOptions)
                    }["createAtomStore.useStoreApi.useMemo"],
                    // store.subscribeAtom(atomConfig, callback)
                    subscribeAtom: {
                        "createAtomStore.useStoreApi.useMemo": (atomConfig)=>subscribeAtomWithStore(atomConfig, store, convertedOptions)
                    }["createAtomStore.useStoreApi.useMemo"],
                    store
                })
        }["createAtomStore.useStoreApi.useMemo"], [
            store,
            convertedOptions
        ]);
    };
    const useNameState = (key, options)=>{
        var _a;
        const store = (_a = useStore(options)) != null ? _a : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultStore"])();
        return useAtomStateWithStore(atoms[key], store, options);
    };
    const useNameValue = (key, _a = {}, deps)=>{
        var _b = _a, { equalityFn, selector } = _b, options = __objRest(_b, [
            "equalityFn",
            "selector"
        ]);
        var _a2;
        const store = (_a2 = useStore(options)) != null ? _a2 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultStore"])();
        return useAtomValueWithStore(atoms[key], store, options, selector, equalityFn != null ? equalityFn : deps, equalityFn && deps);
    };
    const useNameSet = (key, options)=>{
        var _a;
        const store = (_a = useStore(options)) != null ? _a : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultStore"])();
        return useSetAtomWithStore(atoms[key], store, options);
    };
    return {
        [providerIndex]: Provider,
        [useStoreIndex]: useStoreApi,
        [storeIndex]: storeApi,
        [`use${capitalizeFirstLetter(name)}State`]: useNameState,
        [`use${capitalizeFirstLetter(name)}Value`]: useNameValue,
        [`use${capitalizeFirstLetter(name)}Set`]: useNameSet,
        name
    };
};
function useAtomStoreValue(store, key, selector, equalityFnOrDeps, deps) {
    return store.useValue(key, selector, equalityFnOrDeps, deps);
}
function useAtomStoreSet(store, key) {
    return store.useSet(key);
}
function useAtomStoreState(store, key) {
    return store.useState(key);
}
function useStoreAtomValue(store, atom2, selector, equalityFnOrDeps, deps) {
    return store.useAtomValue(atom2, selector, equalityFnOrDeps, deps);
}
function useStoreSetAtom(store, atom2) {
    return store.useSetAtom(atom2);
}
function useStoreAtomState(store, atom2) {
    return store.useAtomState(atom2);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/scheduler/cjs/scheduler.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
            var index = heap.length;
            heap.push(node);
            siftUp(heap, node, index);
        }
        function peek(heap) {
            return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
            if (heap.length === 0) {
                return null;
            }
            var first = heap[0];
            var last = heap.pop();
            if (last !== first) {
                heap[0] = last;
                siftDown(heap, last, 0);
            }
            return first;
        }
        function siftUp(heap, node, i) {
            var index = i;
            while(index > 0){
                var parentIndex = index - 1 >>> 1;
                var parent = heap[parentIndex];
                if (compare(parent, node) > 0) {
                    // The parent is larger. Swap positions.
                    heap[parentIndex] = node;
                    heap[index] = parent;
                    index = parentIndex;
                } else {
                    // The parent is smaller. Exit.
                    return;
                }
            }
        }
        function siftDown(heap, node, i) {
            var index = i;
            var length = heap.length;
            var halfLength = length >>> 1;
            while(index < halfLength){
                var leftIndex = (index + 1) * 2 - 1;
                var left = heap[leftIndex];
                var rightIndex = leftIndex + 1;
                var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.
                if (compare(left, node) < 0) {
                    if (rightIndex < length && compare(right, left) < 0) {
                        heap[index] = right;
                        heap[rightIndex] = node;
                        index = rightIndex;
                    } else {
                        heap[index] = left;
                        heap[leftIndex] = node;
                        index = leftIndex;
                    }
                } else if (rightIndex < length && compare(right, node) < 0) {
                    heap[index] = right;
                    heap[rightIndex] = node;
                    index = rightIndex;
                } else {
                    // Neither child is smaller. Exit.
                    return;
                }
            }
        }
        function compare(a, b) {
            // Compare sort index first, then task id.
            var diff = a.sortIndex - b.sortIndex;
            return diff !== 0 ? diff : a.id - b.id;
        }
        // TODO: Use symbols?
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {}
        /* eslint-disable no-var */ var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
        if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function() {
                return localPerformance.now();
            };
        } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports.unstable_now = function() {
                return localDate.now() - initialTime;
            };
        } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
        // Math.pow(2, 30) - 1
        // 0b111111111111111111111111111111
        var maxSigned31BitInt = 1073741823; // Times out immediately
        var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5000;
        var LOW_PRIORITY_TIMEOUT = 10000; // Never times out
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap
        var taskQueue = [];
        var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.
        var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
        var currentTask = null;
        var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.
        var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom
        var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
            // Check for tasks that are no longer delayed and add them to the queue.
            var timer = peek(timerQueue);
            while(timer !== null){
                if (timer.callback === null) {
                    // Timer was cancelled.
                    pop(timerQueue);
                } else if (timer.startTime <= currentTime) {
                    // Timer fired. Transfer to the task queue.
                    pop(timerQueue);
                    timer.sortIndex = timer.expirationTime;
                    push(taskQueue, timer);
                } else {
                    // Remaining timers are pending.
                    return;
                }
                timer = peek(timerQueue);
            }
        }
        function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
                if (peek(taskQueue) !== null) {
                    isHostCallbackScheduled = true;
                    requestHostCallback(flushWork);
                } else {
                    var firstTimer = peek(timerQueue);
                    if (firstTimer !== null) {
                        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                    }
                }
            }
        }
        function flushWork(hasTimeRemaining, initialTime) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
                // We scheduled a timeout but it's no longer needed. Cancel it.
                isHostTimeoutScheduled = false;
                cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                {
                    var currentTime;
                } else {
                    // No catch in prod code path.
                    return workLoop(hasTimeRemaining, initialTime);
                }
            } finally{
                currentTask = null;
                currentPriorityLevel = previousPriorityLevel;
                isPerformingWork = false;
            }
        }
        function workLoop(hasTimeRemaining, initialTime) {
            var currentTime = initialTime;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while(currentTask !== null && !enableSchedulerDebugging){
                if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                    break;
                }
                var callback = currentTask.callback;
                if (typeof callback === 'function') {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                    var continuationCallback = callback(didUserCallbackTimeout);
                    currentTime = exports.unstable_now();
                    if (typeof continuationCallback === 'function') {
                        currentTask.callback = continuationCallback;
                    } else {
                        if (currentTask === peek(taskQueue)) {
                            pop(taskQueue);
                        }
                    }
                    advanceTimers(currentTime);
                } else {
                    pop(taskQueue);
                }
                currentTask = peek(taskQueue);
            } // Return whether there's additional work
            if (currentTask !== null) {
                return true;
            } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
                return false;
            }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch(priorityLevel){
                case ImmediatePriority:
                case UserBlockingPriority:
                case NormalPriority:
                case LowPriority:
                case IdlePriority:
                    break;
                default:
                    priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
                return eventHandler();
            } finally{
                currentPriorityLevel = previousPriorityLevel;
            }
        }
        function unstable_next(eventHandler) {
            var priorityLevel;
            switch(currentPriorityLevel){
                case ImmediatePriority:
                case UserBlockingPriority:
                case NormalPriority:
                    // Shift down to normal priority
                    priorityLevel = NormalPriority;
                    break;
                default:
                    // Anything lower than normal priority should remain at the current level.
                    priorityLevel = currentPriorityLevel;
                    break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
                return eventHandler();
            } finally{
                currentPriorityLevel = previousPriorityLevel;
            }
        }
        function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
                // This is a fork of runWithPriority, inlined for performance.
                var previousPriorityLevel = currentPriorityLevel;
                currentPriorityLevel = parentPriorityLevel;
                try {
                    return callback.apply(this, arguments);
                } finally{
                    currentPriorityLevel = previousPriorityLevel;
                }
            };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
            var currentTime = exports.unstable_now();
            var startTime;
            if (typeof options === 'object' && options !== null) {
                var delay = options.delay;
                if (typeof delay === 'number' && delay > 0) {
                    startTime = currentTime + delay;
                } else {
                    startTime = currentTime;
                }
            } else {
                startTime = currentTime;
            }
            var timeout;
            switch(priorityLevel){
                case ImmediatePriority:
                    timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                    break;
                case UserBlockingPriority:
                    timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                    break;
                case IdlePriority:
                    timeout = IDLE_PRIORITY_TIMEOUT;
                    break;
                case LowPriority:
                    timeout = LOW_PRIORITY_TIMEOUT;
                    break;
                case NormalPriority:
                default:
                    timeout = NORMAL_PRIORITY_TIMEOUT;
                    break;
            }
            var expirationTime = startTime + timeout;
            var newTask = {
                id: taskIdCounter++,
                callback: callback,
                priorityLevel: priorityLevel,
                startTime: startTime,
                expirationTime: expirationTime,
                sortIndex: -1
            };
            if (startTime > currentTime) {
                // This is a delayed task.
                newTask.sortIndex = startTime;
                push(timerQueue, newTask);
                if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                    // All tasks are delayed, and this is the task with the earliest delay.
                    if (isHostTimeoutScheduled) {
                        // Cancel an existing timeout.
                        cancelHostTimeout();
                    } else {
                        isHostTimeoutScheduled = true;
                    } // Schedule a timeout.
                    requestHostTimeout(handleTimeout, startTime - currentTime);
                }
            } else {
                newTask.sortIndex = expirationTime;
                push(taskQueue, newTask);
                // wait until the next time we yield.
                if (!isHostCallbackScheduled && !isPerformingWork) {
                    isHostCallbackScheduled = true;
                    requestHostCallback(flushWork);
                }
            }
            return newTask;
        }
        function unstable_pauseExecution() {}
        function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
            }
        }
        function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
            // remove from the queue because you can't remove arbitrary nodes from an
            // array based heap, only the first one.)
            task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
        // thread, like user events. By default, it yields multiple times per frame.
        // It does not attempt to align with frame boundaries, since most tasks don't
        // need to be frame aligned; for those that do, use requestAnimationFrame.
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
            var timeElapsed = exports.unstable_now() - startTime;
            if (timeElapsed < frameInterval) {
                // The main thread has only been blocked for a really short amount of time;
                // smaller than a single frame. Don't yield yet.
                return false;
            } // The main thread has been blocked for a non-negligible amount of time. We
            return true;
        }
        function requestPaint() {}
        function forceFrameRate(fps) {
            if (fps < 0 || fps > 125) {
                // Using console['error'] to evade Babel and ESLint
                console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
                return;
            }
            if (fps > 0) {
                frameInterval = Math.floor(1000 / fps);
            } else {
                // reset the framerate
                frameInterval = frameYieldMs;
            }
        }
        var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
                var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread
                // has been blocked.
                startTime = currentTime;
                var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the
                // error can be observed.
                //
                // Intentionally not using a try-catch, since that makes some debugging
                // techniques harder. Instead, if `scheduledHostCallback` errors, then
                // `hasMoreWork` will remain true, and we'll continue the work loop.
                var hasMoreWork = true;
                try {
                    hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                } finally{
                    if (hasMoreWork) {
                        // If there's more work, schedule the next message event at the end
                        // of the preceding one.
                        schedulePerformWorkUntilDeadline();
                    } else {
                        isMessageLoopRunning = false;
                        scheduledHostCallback = null;
                    }
                }
            } else {
                isMessageLoopRunning = false;
            } // Yielding to the browser will give it a chance to paint, so we can
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === 'function') {
            // Node.js and old IE.
            // There's a few reasons for why we prefer setImmediate.
            //
            // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.
            // (Even though this is a DOM fork of the Scheduler, you could get here
            // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)
            // https://github.com/facebook/react/issues/20756
            //
            // But also, it runs earlier which is the semantic we want.
            // If other browsers ever implement it, it's better to use it.
            // Although both of these would be inferior to native scheduling.
            schedulePerformWorkUntilDeadline = function() {
                localSetImmediate(performWorkUntilDeadline);
            };
        } else if (typeof MessageChannel !== 'undefined') {
            // DOM and Worker environments.
            // We prefer MessageChannel because of the 4ms setTimeout clamping.
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function() {
                port.postMessage(null);
            };
        } else {
            // We should only fallback here in non-browser environments.
            schedulePerformWorkUntilDeadline = function() {
                localSetTimeout(performWorkUntilDeadline, 0);
            };
        }
        function requestHostCallback(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
                isMessageLoopRunning = true;
                schedulePerformWorkUntilDeadline();
            }
        }
        function requestHostTimeout(callback, ms) {
            taskTimeoutID = localSetTimeout(function() {
                callback(exports.unstable_now());
            }, ms);
        }
        function cancelHostTimeout() {
            localClearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
    })();
}
}),
"[project]/node_modules/scheduler/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/scheduler/cjs/scheduler.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/@udecode/plate-core/node_modules/zustand-x/node_modules/use-context-selector/dist/index.modern.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BridgeProvider",
    ()=>BridgeProvider,
    "createContext",
    ()=>createContext,
    "useBridgeValue",
    ()=>useBridgeValue,
    "useContext",
    ()=>useContext,
    "useContextSelector",
    ()=>useContextSelector,
    "useContextUpdate",
    ()=>useContextUpdate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$scheduler$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/scheduler/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
;
;
;
const CONTEXT_VALUE = Symbol();
const ORIGINAL_PROVIDER = Symbol();
const isSSR = typeof window === 'undefined' || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent);
const useIsomorphicLayoutEffect = isSSR ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"];
// for preact that doesn't have runWithPriority
const runWithNormalPriority = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$scheduler$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unstable_runWithPriority"] ? (thunk)=>{
    try {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$scheduler$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unstable_runWithPriority"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$scheduler$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unstable_NormalPriority"], thunk);
    } catch (e) {
        if (e.message === 'Not implemented.') {
            thunk();
        } else {
            throw e;
        }
    }
} : (thunk)=>thunk();
const createProvider = (ProviderOrig)=>{
    const ContextProvider = ({ value, children })=>{
        const valueRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(value);
        const versionRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(0);
        const [resolve, setResolve] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
        if (resolve) {
            resolve(value);
            setResolve(null);
        }
        const contextValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
        if (!contextValue.current) {
            const listeners = new Set();
            const update = (thunk, options)=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unstable_batchedUpdates"])(()=>{
                    versionRef.current += 1;
                    const action = {
                        n: versionRef.current
                    };
                    if (options != null && options.suspense) {
                        action.n *= -1; // this is intentional to make it temporary version
                        action.p = new Promise((r)=>{
                            setResolve(()=>(v)=>{
                                    action.v = v;
                                    delete action.p;
                                    r(v);
                                });
                        });
                    }
                    listeners.forEach((listener)=>listener(action));
                    thunk();
                });
            };
            contextValue.current = {
                [CONTEXT_VALUE]: {
                    /* "v"alue     */ v: valueRef,
                    /* versio"n"   */ n: versionRef,
                    /* "l"isteners */ l: listeners,
                    /* "u"pdate    */ u: update
                }
            };
        }
        useIsomorphicLayoutEffect({
            "createProvider.ContextProvider.useIsomorphicLayoutEffect": ()=>{
                valueRef.current = value;
                versionRef.current += 1;
                runWithNormalPriority({
                    "createProvider.ContextProvider.useIsomorphicLayoutEffect": ()=>{
                        contextValue.current[CONTEXT_VALUE].l.forEach({
                            "createProvider.ContextProvider.useIsomorphicLayoutEffect": (listener)=>{
                                listener({
                                    n: versionRef.current,
                                    v: value
                                });
                            }
                        }["createProvider.ContextProvider.useIsomorphicLayoutEffect"]);
                    }
                }["createProvider.ContextProvider.useIsomorphicLayoutEffect"]);
            }
        }["createProvider.ContextProvider.useIsomorphicLayoutEffect"], [
            value
        ]);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(ProviderOrig, {
            value: contextValue.current
        }, children);
    };
    return ContextProvider;
};
const identity = (x)=>x;
/**
 * This creates a special context for `useContextSelector`.
 *
 * @example
 * import { createContext } from 'use-context-selector';
 *
 * const PersonContext = createContext({ firstName: '', familyName: '' });
 */ function createContext(defaultValue) {
    const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])({
        [CONTEXT_VALUE]: {
            /* "v"alue     */ v: {
                current: defaultValue
            },
            /* versio"n"   */ n: {
                current: -1
            },
            /* "l"isteners */ l: new Set(),
            /* "u"pdate    */ u: (f)=>f()
        }
    });
    context[ORIGINAL_PROVIDER] = context.Provider;
    context.Provider = createProvider(context.Provider);
    delete context.Consumer; // no support for Consumer
    return context;
}
/**
 * This hook returns context selected value by selector.
 *
 * It will only accept context created by `createContext`.
 * It will trigger re-render if only the selected value is referentially changed.
 *
 * The selector should return referentially equal result for same input for better performance.
 *
 * @example
 * import { useContextSelector } from 'use-context-selector';
 *
 * const firstName = useContextSelector(PersonContext, state => state.firstName);
 */ function useContextSelector(context, selector) {
    const contextValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(context)[CONTEXT_VALUE];
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && ("TURBOPACK compile-time value", "development") !== 'production') {
        if (!contextValue) {
            throw new Error('useContextSelector requires special context');
        }
    }
    const { /* "v"alue     */ v: { current: value }, /* versio"n"   */ n: { current: version }, /* "l"isteners */ l: listeners } = contextValue;
    const selected = selector(value);
    const [state, dispatch] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useReducer"])({
        "useContextSelector.useReducer": (prev, action)=>{
            if (!action) {
                // case for `dispatch()` below
                return [
                    value,
                    selected
                ];
            }
            if ('p' in action) {
                throw action.p;
            }
            if (action.n === version) {
                if (Object.is(prev[1], selected)) {
                    return prev; // bail out
                }
                return [
                    value,
                    selected
                ];
            }
            try {
                if ('v' in action) {
                    if (Object.is(prev[0], action.v)) {
                        return prev; // do not update
                    }
                    const nextSelected = selector(action.v);
                    if (Object.is(prev[1], nextSelected)) {
                        return prev; // do not update
                    }
                    return [
                        action.v,
                        nextSelected
                    ];
                }
            } catch (e) {
            // ignored (stale props or some other reason)
            }
            return [
                ...prev
            ]; // schedule update
        }
    }["useContextSelector.useReducer"], [
        value,
        selected
    ]);
    if (!Object.is(state[1], selected)) {
        // schedule re-render
        // this is safe because it's self contained
        dispatch();
    }
    useIsomorphicLayoutEffect({
        "useContextSelector.useIsomorphicLayoutEffect": ()=>{
            listeners.add(dispatch);
            return ({
                "useContextSelector.useIsomorphicLayoutEffect": ()=>{
                    listeners.delete(dispatch);
                }
            })["useContextSelector.useIsomorphicLayoutEffect"];
        }
    }["useContextSelector.useIsomorphicLayoutEffect"], [
        listeners
    ]);
    return state[1];
}
/**
 * This hook returns the entire context value.
 * Use this instead of React.useContext for consistent behavior.
 *
 * @example
 * import { useContext } from 'use-context-selector';
 *
 * const person = useContext(PersonContext);
 */ function useContext(context) {
    return useContextSelector(context, identity);
}
/**
 * This hook returns an update function that accepts a thunk function
 *
 * Use this for a function that will change a value in
 * concurrent rendering in React 18.
 * Otherwise, there's no need to use this hook.
 *
 * @example
 * import { useContextUpdate } from 'use-context-selector';
 *
 * const update = useContextUpdate();
 *
 * // Wrap set state function
 * update(() => setState(...));
 *
 * // Experimental suspense mode
 * update(() => setState(...), { suspense: true });
 */ function useContextUpdate(context) {
    const contextValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(context)[CONTEXT_VALUE];
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && ("TURBOPACK compile-time value", "development") !== 'production') {
        if (!contextValue) {
            throw new Error('useContextUpdate requires special context');
        }
    }
    const { u: update } = contextValue;
    return update;
}
/**
 * This is a Provider component for bridging multiple react roots
 *
 * @example
 * const valueToBridge = useBridgeValue(PersonContext);
 * return (
 *   <Renderer>
 *     <BridgeProvider context={PersonContext} value={valueToBridge}>
 *       {children}
 *     </BridgeProvider>
 *   </Renderer>
 * );
 */ const BridgeProvider = ({ context, value, children })=>{
    const { [ORIGINAL_PROVIDER]: ProviderOrig } = context;
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && ("TURBOPACK compile-time value", "development") !== 'production') {
        if (!ProviderOrig) {
            throw new Error('BridgeProvider requires special context');
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(ProviderOrig, {
        value
    }, children);
};
/**
 * This hook return a value for BridgeProvider
 */ const useBridgeValue = (context)=>{
    const bridgeValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(context);
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && ("TURBOPACK compile-time value", "development") !== 'production') {
        if (!bridgeValue[CONTEXT_VALUE]) {
            throw new Error('useBridgeValue requires special context');
        }
    }
    return bridgeValue;
};
;
 //# sourceMappingURL=index.modern.mjs.map
}),
"[project]/node_modules/proxy-compare/dist/index.modern.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "affectedToPathList",
    ()=>w,
    "createProxy",
    ()=>a,
    "getUntracked",
    ()=>y,
    "isChanged",
    ()=>p,
    "markToTrack",
    ()=>h,
    "replaceNewProxy",
    ()=>O,
    "trackMemo",
    ()=>g
]);
const e = Symbol(), t = Symbol(), r = "a", n = "w";
let o = (e, t)=>new Proxy(e, t);
const s = Object.getPrototypeOf, c = new WeakMap, l = (e)=>e && (c.has(e) ? c.get(e) : s(e) === Object.prototype || s(e) === Array.prototype), f = (e)=>"object" == typeof e && null !== e, i = (e)=>{
    if (Array.isArray(e)) return Array.from(e);
    const t = Object.getOwnPropertyDescriptors(e);
    return Object.values(t).forEach((e)=>{
        e.configurable = !0;
    }), Object.create(s(e), t);
}, u = (e)=>e[t] || e, a = (s, c, f, p)=>{
    if (!l(s)) return s;
    let g = p && p.get(s);
    if (!g) {
        const e = u(s);
        g = ((e)=>Object.values(Object.getOwnPropertyDescriptors(e)).some((e)=>!e.configurable && !e.writable))(e) ? [
            e,
            i(e)
        ] : [
            e
        ], null == p || p.set(s, g);
    }
    const [y, h] = g;
    let w = f && f.get(y);
    return w && w[1].f === !!h || (w = ((o, s)=>{
        const c = {
            f: s
        };
        let l = !1;
        const f = (e, t)=>{
            if (!l) {
                let s = c[r].get(o);
                if (s || (s = {}, c[r].set(o, s)), e === n) s[n] = !0;
                else {
                    let r = s[e];
                    r || (r = new Set, s[e] = r), r.add(t);
                }
            }
        }, i = {
            get: (e, n)=>n === t ? o : (f("k", n), a(Reflect.get(e, n), c[r], c.c, c.t)),
            has: (t, n)=>n === e ? (l = !0, c[r].delete(o), !0) : (f("h", n), Reflect.has(t, n)),
            getOwnPropertyDescriptor: (e, t)=>(f("o", t), Reflect.getOwnPropertyDescriptor(e, t)),
            ownKeys: (e)=>(f(n), Reflect.ownKeys(e))
        };
        return s && (i.set = i.deleteProperty = ()=>!1), [
            i,
            c
        ];
    })(y, !!h), w[1].p = o(h || y, w[0]), f && f.set(y, w)), w[1][r] = c, w[1].c = f, w[1].t = p, w[1].p;
}, p = (e, t, r, o, s = Object.is)=>{
    if (s(e, t)) return !1;
    if (!f(e) || !f(t)) return !0;
    const c = r.get(u(e));
    if (!c) return !0;
    if (o) {
        const r = o.get(e);
        if (r && r.n === t) return r.g;
        o.set(e, {
            n: t,
            g: !1
        });
    }
    let l = null;
    try {
        for (const r of c.h || [])if (l = Reflect.has(e, r) !== Reflect.has(t, r), l) return l;
        if (!0 === c[n]) {
            if (l = ((e, t)=>{
                const r = Reflect.ownKeys(e), n = Reflect.ownKeys(t);
                return r.length !== n.length || r.some((e, t)=>e !== n[t]);
            })(e, t), l) return l;
        } else for (const r of c.o || [])if (l = !!Reflect.getOwnPropertyDescriptor(e, r) != !!Reflect.getOwnPropertyDescriptor(t, r), l) return l;
        for (const n of c.k || [])if (l = p(e[n], t[n], r, o, s), l) return l;
        return null === l && (l = !0), l;
    } finally{
        o && o.set(e, {
            n: t,
            g: l
        });
    }
}, g = (t)=>!!l(t) && e in t, y = (e)=>l(e) && e[t] || null, h = (e, t = !0)=>{
    c.set(e, t);
}, w = (e, t, r)=>{
    const o = [], s = new WeakSet, c = (e, l)=>{
        if (s.has(e)) return;
        f(e) && s.add(e);
        const i = f(e) && t.get(u(e));
        if (i) {
            var a, p;
            if (null == (a = i.h) || a.forEach((e)=>{
                const t = `:has(${String(e)})`;
                o.push(l ? [
                    ...l,
                    t
                ] : [
                    t
                ]);
            }), !0 === i[n]) {
                const e = ":ownKeys";
                o.push(l ? [
                    ...l,
                    e
                ] : [
                    e
                ]);
            } else {
                var g;
                null == (g = i.o) || g.forEach((e)=>{
                    const t = `:hasOwn(${String(e)})`;
                    o.push(l ? [
                        ...l,
                        t
                    ] : [
                        t
                    ]);
                });
            }
            null == (p = i.k) || p.forEach((t)=>{
                r && !("value" in (Object.getOwnPropertyDescriptor(e, t) || {})) || c(e[t], l ? [
                    ...l,
                    t
                ] : [
                    t
                ]);
            });
        } else l && o.push(l);
    };
    return c(e), o;
}, O = (e)=>{
    o = e;
};
;
 //# sourceMappingURL=index.modern.mjs.map
}),
"[project]/node_modules/@udecode/plate-core/node_modules/zustand-x/node_modules/react-tracked/dist/index.modern.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createContainer",
    ()=>createContainer,
    "createTrackedSelector",
    ()=>createTrackedSelector,
    "memo",
    ()=>memo
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2d$x$2f$node_modules$2f$use$2d$context$2d$selector$2f$dist$2f$index$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@udecode/plate-core/node_modules/zustand-x/node_modules/use-context-selector/dist/index.modern.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$proxy$2d$compare$2f$dist$2f$index$2e$modern$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/proxy-compare/dist/index.modern.js [app-client] (ecmascript)");
;
;
;
;
const useAffectedDebugValue = (state, affected)=>{
    const pathList = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useAffectedDebugValue.useEffect": ()=>{
            pathList.current = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$proxy$2d$compare$2f$dist$2f$index$2e$modern$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["affectedToPathList"])(state, affected);
        }
    }["useAffectedDebugValue.useEffect"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDebugValue"])(state);
};
const createTrackedSelector = (useSelector)=>{
    const useTrackedSelector = ()=>{
        const [, forceUpdate] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useReducer"])({
            "createTrackedSelector.useTrackedSelector.useReducer": (c)=>c + 1
        }["createTrackedSelector.useTrackedSelector.useReducer"], 0);
        const affected = new WeakMap();
        const lastAffected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
        const prevState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
        const lastState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
            "createTrackedSelector.useTrackedSelector.useEffect": ()=>{
                lastAffected.current = affected;
                if (prevState.current !== lastState.current && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$proxy$2d$compare$2f$dist$2f$index$2e$modern$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isChanged"])(prevState.current, lastState.current, affected, new WeakMap())) {
                    prevState.current = lastState.current;
                    forceUpdate();
                }
            }
        }["createTrackedSelector.useTrackedSelector.useEffect"]);
        const selector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "createTrackedSelector.useTrackedSelector.useCallback[selector]": (nextState)=>{
                lastState.current = nextState;
                if (prevState.current && prevState.current !== nextState && lastAffected.current && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$proxy$2d$compare$2f$dist$2f$index$2e$modern$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isChanged"])(prevState.current, nextState, lastAffected.current, new WeakMap())) {
                    // not changed
                    return prevState.current;
                }
                prevState.current = nextState;
                return nextState;
            }
        }["createTrackedSelector.useTrackedSelector.useCallback[selector]"], []);
        const state = useSelector(selector);
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && ("TURBOPACK compile-time value", "development") !== 'production') {
            // eslint-disable-next-line react-hooks/rules-of-hooks
            useAffectedDebugValue(state, affected);
        }
        const proxyCache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
            "createTrackedSelector.useTrackedSelector.useMemo[proxyCache]": ()=>new WeakMap()
        }["createTrackedSelector.useTrackedSelector.useMemo[proxyCache]"], []); // per-hook proxyCache
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$proxy$2d$compare$2f$dist$2f$index$2e$modern$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createProxy"])(state, affected, proxyCache);
    };
    return useTrackedSelector;
};
/* eslint react/destructuring-assignment: off */ const createContainer = (useValue, options)=>{
    var _options, _options2;
    if (typeof options === 'boolean') {
        // eslint-disable-next-line no-console
        console.warn('boolean option is deprecated, please specify { concurrentMode: true }');
        options = {
            concurrentMode: options
        };
    }
    const { stateContextName = 'StateContainer', updateContextName = 'UpdateContainer', concurrentMode } = options || {};
    const StateContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2d$x$2f$node_modules$2f$use$2d$context$2d$selector$2f$dist$2f$index$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])((_options = options) == null ? void 0 : _options.defaultState);
    const UpdateContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])((_options2 = options) == null ? void 0 : _options2.defaultUpdate);
    StateContext.displayName = stateContextName;
    UpdateContext.displayName = updateContextName;
    const Provider = (props)=>{
        const [state, update] = useValue(props);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(UpdateContext.Provider, {
            value: update
        }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(StateContext.Provider, {
            value: state
        }, props.children));
    };
    const useSelector = (selector)=>{
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && ("TURBOPACK compile-time value", "development") !== 'production') {
            const selectorOrig = selector;
            selector = (state)=>{
                if (state === undefined) {
                    throw new Error('Please use <Provider>');
                }
                return selectorOrig(state);
            };
        }
        const selected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2d$x$2f$node_modules$2f$use$2d$context$2d$selector$2f$dist$2f$index$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContextSelector"])(StateContext, selector);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDebugValue"])(selected);
        return selected;
    };
    const useTrackedState = createTrackedSelector(useSelector);
    const useUpdate = concurrentMode ? ()=>{
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && ("TURBOPACK compile-time value", "development") !== 'production' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(UpdateContext) === undefined) {
            throw new Error('Please use <Provider>');
        }
        const contextUpdate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2d$x$2f$node_modules$2f$use$2d$context$2d$selector$2f$dist$2f$index$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContextUpdate"])(StateContext);
        const update = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(UpdateContext);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "createContainer.useCallback": (...args)=>{
                let result;
                contextUpdate({
                    "createContainer.useCallback": ()=>{
                        result = update(...args);
                    }
                }["createContainer.useCallback"]);
                return result;
            }
        }["createContainer.useCallback"], [
            contextUpdate,
            update
        ]);
    } : ()=>{
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && ("TURBOPACK compile-time value", "development") !== 'production' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(UpdateContext) === undefined) {
            throw new Error('Please use <Provider>');
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(UpdateContext);
    };
    const useTracked = ()=>[
            useTrackedState(),
            useUpdate()
        ];
    return {
        Provider,
        useTrackedState,
        useTracked,
        useUpdate,
        useSelector
    };
};
function _extends() {
    _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable";
    return _extends.apply(this, arguments);
}
function memo(Component, propsAreEqual) {
    const WrappedComponent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])((props, ref)=>{
        Object.values(props).forEach(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$proxy$2d$compare$2f$dist$2f$index$2e$modern$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trackMemo"]);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(Component, _extends({}, props, {
            ref
        }));
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(WrappedComponent, propsAreEqual);
}
;
 //# sourceMappingURL=index.modern.mjs.map
}),
"[project]/node_modules/@udecode/plate-core/node_modules/zustand/esm/middleware.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "combine",
    ()=>combine,
    "createJSONStorage",
    ()=>createJSONStorage,
    "devtools",
    ()=>devtools,
    "persist",
    ()=>persist,
    "redux",
    ()=>redux,
    "subscribeWithSelector",
    ()=>subscribeWithSelector
]);
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/@udecode/plate-core/node_modules/zustand/esm/middleware.mjs")}`;
    }
};
const reduxImpl = (reducer, initial)=>(set, _get, api)=>{
        api.dispatch = (action)=>{
            set((state)=>reducer(state, action), false, action);
            return action;
        };
        api.dispatchFromDevtools = true;
        return {
            dispatch: (...args)=>api.dispatch(...args),
            ...initial
        };
    };
const redux = reduxImpl;
const trackedConnections = /* @__PURE__ */ new Map();
const getTrackedConnectionState = (name)=>{
    const api = trackedConnections.get(name);
    if (!api) return {};
    return Object.fromEntries(Object.entries(api.stores).map(([key, api2])=>[
            key,
            api2.getState()
        ]));
};
const extractConnectionInformation = (store, extensionConnector, options)=>{
    if (store === void 0) {
        return {
            type: "untracked",
            connection: extensionConnector.connect(options)
        };
    }
    const existingConnection = trackedConnections.get(options.name);
    if (existingConnection) {
        return {
            type: "tracked",
            store,
            ...existingConnection
        };
    }
    const newConnection = {
        connection: extensionConnector.connect(options),
        stores: {}
    };
    trackedConnections.set(options.name, newConnection);
    return {
        type: "tracked",
        store,
        ...newConnection
    };
};
const removeStoreFromTrackedConnections = (name, store)=>{
    if (store === void 0) return;
    const connectionInfo = trackedConnections.get(name);
    if (!connectionInfo) return;
    delete connectionInfo.stores[store];
    if (Object.keys(connectionInfo.stores).length === 0) {
        trackedConnections.delete(name);
    }
};
const findCallerName = (stack)=>{
    var _a, _b;
    if (!stack) return void 0;
    const traceLines = stack.split("\n");
    const apiSetStateLineIndex = traceLines.findIndex((traceLine)=>traceLine.includes("api.setState"));
    if (apiSetStateLineIndex < 0) return void 0;
    const callerLine = ((_a = traceLines[apiSetStateLineIndex + 1]) == null ? void 0 : _a.trim()) || "";
    return (_b = /.+ (.+) .+/.exec(callerLine)) == null ? void 0 : _b[1];
};
const devtoolsImpl = (fn, devtoolsOptions = {})=>(set, get, api)=>{
        const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
        let extensionConnector;
        try {
            extensionConnector = (enabled != null ? enabled : (__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
        } catch (e) {}
        if (!extensionConnector) {
            return fn(set, get, api);
        }
        const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
        let isRecording = true;
        api.setState = (state, replace, nameOrAction)=>{
            const r = set(state, replace);
            if (!isRecording) return r;
            const action = nameOrAction === void 0 ? {
                type: anonymousActionType || findCallerName(new Error().stack) || "anonymous"
            } : typeof nameOrAction === "string" ? {
                type: nameOrAction
            } : nameOrAction;
            if (store === void 0) {
                connection == null ? void 0 : connection.send(action, get());
                return r;
            }
            connection == null ? void 0 : connection.send({
                ...action,
                type: `${store}/${action.type}`
            }, {
                ...getTrackedConnectionState(options.name),
                [store]: api.getState()
            });
            return r;
        };
        api.devtools = {
            cleanup: ()=>{
                if (connection && typeof connection.unsubscribe === "function") {
                    connection.unsubscribe();
                }
                removeStoreFromTrackedConnections(options.name, store);
            }
        };
        const setStateFromDevtools = (...a)=>{
            const originalIsRecording = isRecording;
            isRecording = false;
            set(...a);
            isRecording = originalIsRecording;
        };
        const initialState = fn(api.setState, get, api);
        if (connectionInformation.type === "untracked") {
            connection == null ? void 0 : connection.init(initialState);
        } else {
            connectionInformation.stores[connectionInformation.store] = api;
            connection == null ? void 0 : connection.init(Object.fromEntries(Object.entries(connectionInformation.stores).map(([key, store2])=>[
                    key,
                    key === connectionInformation.store ? initialState : store2.getState()
                ])));
        }
        if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
            let didWarnAboutReservedActionType = false;
            const originalDispatch = api.dispatch;
            api.dispatch = (...args)=>{
                if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production" && args[0].type === "__setState" && !didWarnAboutReservedActionType) {
                    console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.');
                    didWarnAboutReservedActionType = true;
                }
                originalDispatch(...args);
            };
        }
        connection.subscribe((message)=>{
            var _a;
            switch(message.type){
                case "ACTION":
                    if (typeof message.payload !== "string") {
                        console.error("[zustand devtools middleware] Unsupported action format");
                        return;
                    }
                    return parseJsonThen(message.payload, (action)=>{
                        if (action.type === "__setState") {
                            if (store === void 0) {
                                setStateFromDevtools(action.state);
                                return;
                            }
                            if (Object.keys(action.state).length !== 1) {
                                console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);
                            }
                            const stateFromDevtools = action.state[store];
                            if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                                return;
                            }
                            if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                                setStateFromDevtools(stateFromDevtools);
                            }
                            return;
                        }
                        if (!api.dispatchFromDevtools) return;
                        if (typeof api.dispatch !== "function") return;
                        api.dispatch(action);
                    });
                case "DISPATCH":
                    switch(message.payload.type){
                        case "RESET":
                            setStateFromDevtools(initialState);
                            if (store === void 0) {
                                return connection == null ? void 0 : connection.init(api.getState());
                            }
                            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                        case "COMMIT":
                            if (store === void 0) {
                                connection == null ? void 0 : connection.init(api.getState());
                                return;
                            }
                            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                        case "ROLLBACK":
                            return parseJsonThen(message.state, (state)=>{
                                if (store === void 0) {
                                    setStateFromDevtools(state);
                                    connection == null ? void 0 : connection.init(api.getState());
                                    return;
                                }
                                setStateFromDevtools(state[store]);
                                connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                            });
                        case "JUMP_TO_STATE":
                        case "JUMP_TO_ACTION":
                            return parseJsonThen(message.state, (state)=>{
                                if (store === void 0) {
                                    setStateFromDevtools(state);
                                    return;
                                }
                                if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                                    setStateFromDevtools(state[store]);
                                }
                            });
                        case "IMPORT_STATE":
                            {
                                const { nextLiftedState } = message.payload;
                                const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
                                if (!lastComputedState) return;
                                if (store === void 0) {
                                    setStateFromDevtools(lastComputedState);
                                } else {
                                    setStateFromDevtools(lastComputedState[store]);
                                }
                                connection == null ? void 0 : connection.send(null, // FIXME no-any
                                nextLiftedState);
                                return;
                            }
                        case "PAUSE_RECORDING":
                            return isRecording = !isRecording;
                    }
                    return;
            }
        });
        return initialState;
    };
const devtools = devtoolsImpl;
const parseJsonThen = (stringified, fn)=>{
    let parsed;
    try {
        parsed = JSON.parse(stringified);
    } catch (e) {
        console.error("[zustand devtools middleware] Could not parse the received json", e);
    }
    if (parsed !== void 0) fn(parsed);
};
const subscribeWithSelectorImpl = (fn)=>(set, get, api)=>{
        const origSubscribe = api.subscribe;
        api.subscribe = (selector, optListener, options)=>{
            let listener = selector;
            if (optListener) {
                const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
                let currentSlice = selector(api.getState());
                listener = (state)=>{
                    const nextSlice = selector(state);
                    if (!equalityFn(currentSlice, nextSlice)) {
                        const previousSlice = currentSlice;
                        optListener(currentSlice = nextSlice, previousSlice);
                    }
                };
                if (options == null ? void 0 : options.fireImmediately) {
                    optListener(currentSlice, currentSlice);
                }
            }
            return origSubscribe(listener);
        };
        const initialState = fn(set, get, api);
        return initialState;
    };
const subscribeWithSelector = subscribeWithSelectorImpl;
function combine(initialState, create) {
    return (...args)=>Object.assign({}, initialState, create(...args));
}
function createJSONStorage(getStorage, options) {
    let storage;
    try {
        storage = getStorage();
    } catch (e) {
        return;
    }
    const persistStorage = {
        getItem: (name)=>{
            var _a;
            const parse = (str2)=>{
                if (str2 === null) {
                    return null;
                }
                return JSON.parse(str2, options == null ? void 0 : options.reviver);
            };
            const str = (_a = storage.getItem(name)) != null ? _a : null;
            if (str instanceof Promise) {
                return str.then(parse);
            }
            return parse(str);
        },
        setItem: (name, newValue)=>storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer)),
        removeItem: (name)=>storage.removeItem(name)
    };
    return persistStorage;
}
const toThenable = (fn)=>(input)=>{
        try {
            const result = fn(input);
            if (result instanceof Promise) {
                return result;
            }
            return {
                then (onFulfilled) {
                    return toThenable(onFulfilled)(result);
                },
                catch (_onRejected) {
                    return this;
                }
            };
        } catch (e) {
            return {
                then (_onFulfilled) {
                    return this;
                },
                catch (onRejected) {
                    return toThenable(onRejected)(e);
                }
            };
        }
    };
const persistImpl = (config, baseOptions)=>(set, get, api)=>{
        let options = {
            storage: createJSONStorage(()=>localStorage),
            partialize: (state)=>state,
            version: 0,
            merge: (persistedState, currentState)=>({
                    ...currentState,
                    ...persistedState
                }),
            ...baseOptions
        };
        let hasHydrated = false;
        const hydrationListeners = /* @__PURE__ */ new Set();
        const finishHydrationListeners = /* @__PURE__ */ new Set();
        let storage = options.storage;
        if (!storage) {
            return config((...args)=>{
                console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);
                set(...args);
            }, get, api);
        }
        const setItem = ()=>{
            const state = options.partialize({
                ...get()
            });
            return storage.setItem(options.name, {
                state,
                version: options.version
            });
        };
        const savedSetState = api.setState;
        api.setState = (state, replace)=>{
            savedSetState(state, replace);
            return setItem();
        };
        const configResult = config((...args)=>{
            set(...args);
            return setItem();
        }, get, api);
        api.getInitialState = ()=>configResult;
        let stateFromStorage;
        const hydrate = ()=>{
            var _a, _b;
            if (!storage) return;
            hasHydrated = false;
            hydrationListeners.forEach((cb)=>{
                var _a2;
                return cb((_a2 = get()) != null ? _a2 : configResult);
            });
            const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
            return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue)=>{
                if (deserializedStorageValue) {
                    if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
                        if (options.migrate) {
                            const migration = options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);
                            if (migration instanceof Promise) {
                                return migration.then((result)=>[
                                        true,
                                        result
                                    ]);
                            }
                            return [
                                true,
                                migration
                            ];
                        }
                        console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);
                    } else {
                        return [
                            false,
                            deserializedStorageValue.state
                        ];
                    }
                }
                return [
                    false,
                    void 0
                ];
            }).then((migrationResult)=>{
                var _a2;
                const [migrated, migratedState] = migrationResult;
                stateFromStorage = options.merge(migratedState, (_a2 = get()) != null ? _a2 : configResult);
                set(stateFromStorage, true);
                if (migrated) {
                    return setItem();
                }
            }).then(()=>{
                postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
                stateFromStorage = get();
                hasHydrated = true;
                finishHydrationListeners.forEach((cb)=>cb(stateFromStorage));
            }).catch((e)=>{
                postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
            });
        };
        api.persist = {
            setOptions: (newOptions)=>{
                options = {
                    ...options,
                    ...newOptions
                };
                if (newOptions.storage) {
                    storage = newOptions.storage;
                }
            },
            clearStorage: ()=>{
                storage == null ? void 0 : storage.removeItem(options.name);
            },
            getOptions: ()=>options,
            rehydrate: ()=>hydrate(),
            hasHydrated: ()=>hasHydrated,
            onHydrate: (cb)=>{
                hydrationListeners.add(cb);
                return ()=>{
                    hydrationListeners.delete(cb);
                };
            },
            onFinishHydration: (cb)=>{
                finishHydrationListeners.add(cb);
                return ()=>{
                    finishHydrationListeners.delete(cb);
                };
            }
        };
        if (!options.skipHydration) {
            hydrate();
        }
        return stateFromStorage || configResult;
    };
const persist = persistImpl;
;
}),
"[project]/node_modules/@udecode/plate-core/node_modules/zustand/esm/vanilla.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createStore",
    ()=>createStore
]);
const createStoreImpl = (createState)=>{
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace)=>{
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
            const previousState = state;
            state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
            listeners.forEach((listener)=>listener(state, previousState));
        }
    };
    const getState = ()=>state;
    const getInitialState = ()=>initialState;
    const subscribe = (listener)=>{
        listeners.add(listener);
        return ()=>listeners.delete(listener);
    };
    const api = {
        setState,
        getState,
        getInitialState,
        subscribe
    };
    const initialState = state = createState(setState, getState, api);
    return api;
};
const createStore = (createState)=>createState ? createStoreImpl(createState) : createStoreImpl;
;
}),
"[project]/node_modules/@udecode/plate-core/node_modules/zustand/esm/traditional.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createWithEqualityFn",
    ()=>createWithEqualityFn,
    "useStoreWithEqualityFn",
    ()=>useStoreWithEqualityFn
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@udecode/plate-core/node_modules/use-sync-external-store/shim/with-selector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@udecode/plate-core/node_modules/zustand/esm/vanilla.mjs [app-client] (ecmascript)");
;
;
;
const { useSyncExternalStoreWithSelector } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
const identity = (arg)=>arg;
function useStoreWithEqualityFn(api, selector = identity, equalityFn) {
    const slice = useSyncExternalStoreWithSelector(api.subscribe, api.getState, api.getInitialState, selector, equalityFn);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useDebugValue(slice);
    return slice;
}
const createWithEqualityFnImpl = (createState, defaultEqualityFn)=>{
    const api = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"])(createState);
    const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn)=>useStoreWithEqualityFn(api, selector, equalityFn);
    Object.assign(useBoundStoreWithEqualityFn, api);
    return useBoundStoreWithEqualityFn;
};
const createWithEqualityFn = (createState, defaultEqualityFn)=>createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;
;
}),
"[project]/node_modules/@udecode/plate-core/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        }
        cachedValue = useState({
            inst: {
                value: value,
                getSnapshot: getSnapshot
            }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect({
            "useSyncExternalStore$2.useLayoutEffect": function() {
                inst.value = value;
                inst.getSnapshot = getSnapshot;
                checkIfSnapshotChanged(inst) && forceUpdate({
                    inst: inst
                });
            }
        }["useSyncExternalStore$2.useLayoutEffect"], [
            subscribe,
            value,
            getSnapshot
        ]);
        useEffect({
            "useSyncExternalStore$2.useEffect": function() {
                checkIfSnapshotChanged(inst) && forceUpdate({
                    inst: inst
                });
                return subscribe({
                    "useSyncExternalStore$2.useEffect": function() {
                        checkIfSnapshotChanged(inst) && forceUpdate({
                            inst: inst
                        });
                    }
                }["useSyncExternalStore$2.useEffect"]);
            }
        }["useSyncExternalStore$2.useEffect"], [
            subscribe
        ]);
        useDebugValue(value);
        return value;
    }
    function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
        } catch (error) {
            return !0;
        }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
    exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}),
"[project]/node_modules/@udecode/plate-core/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/@udecode/plate-core/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/@udecode/plate-core/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), shim = __turbopack_context__.r("[project]/node_modules/@udecode/plate-core/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
    exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef(null);
        if (null === instRef.current) {
            var inst = {
                hasValue: !1,
                value: null
            };
            instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(function() {
            function memoizedSelector(nextSnapshot) {
                if (!hasMemo) {
                    hasMemo = !0;
                    memoizedSnapshot = nextSnapshot;
                    nextSnapshot = selector(nextSnapshot);
                    if (void 0 !== isEqual && inst.hasValue) {
                        var currentSelection = inst.value;
                        if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
                    }
                    return memoizedSelection = nextSnapshot;
                }
                currentSelection = memoizedSelection;
                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
                var nextSelection = selector(nextSnapshot);
                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
                memoizedSnapshot = nextSnapshot;
                return memoizedSelection = nextSelection;
            }
            var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
                function() {
                    return memoizedSelector(getSnapshot());
                },
                null === maybeGetServerSnapshot ? void 0 : function() {
                    return memoizedSelector(maybeGetServerSnapshot());
                }
            ];
        }, [
            getSnapshot,
            getServerSnapshot,
            selector,
            isEqual
        ]);
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect(function() {
            inst.hasValue = !0;
            inst.value = value;
        }, [
            value
        ]);
        useDebugValue(value);
        return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}),
"[project]/node_modules/@udecode/plate-core/node_modules/use-sync-external-store/shim/with-selector.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/@udecode/plate-core/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/mutative/dist/mutative.esm.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "apply",
    ()=>apply,
    "castDraft",
    ()=>castDraft,
    "castImmutable",
    ()=>castImmutable,
    "castMutable",
    ()=>castMutable,
    "create",
    ()=>create,
    "current",
    ()=>current,
    "isDraft",
    ()=>isDraft,
    "isDraftable",
    ()=>isDraftable,
    "makeCreator",
    ()=>makeCreator,
    "markSimpleObject",
    ()=>markSimpleObject,
    "original",
    ()=>original,
    "rawReturn",
    ()=>rawReturn,
    "unsafe",
    ()=>unsafe
]);
const Operation = {
    Remove: 'remove',
    Replace: 'replace',
    Add: 'add'
};
// Don't use `Symbol()` just for 3rd party access the draft
const PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');
const RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');
const iteratorSymbol = Symbol.iterator;
const dataTypes = {
    mutable: 'mutable',
    immutable: 'immutable'
};
const internal = {};
function has(target, key) {
    return target instanceof Map ? target.has(key) : Object.prototype.hasOwnProperty.call(target, key);
}
function getDescriptor(target, key) {
    if (key in target) {
        let prototype = Reflect.getPrototypeOf(target);
        while(prototype){
            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);
            if (descriptor) return descriptor;
            prototype = Reflect.getPrototypeOf(prototype);
        }
    }
    return;
}
function isBaseSetInstance(obj) {
    return Object.getPrototypeOf(obj) === Set.prototype;
}
function isBaseMapInstance(obj) {
    return Object.getPrototypeOf(obj) === Map.prototype;
}
function latest(proxyDraft) {
    var _a;
    return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;
}
/**
 * Check if the value is a draft
 */ function isDraft(target) {
    return !!getProxyDraft(target);
}
function getProxyDraft(value) {
    if (typeof value !== 'object') return null;
    return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];
}
function getValue(value) {
    var _a;
    const proxyDraft = getProxyDraft(value);
    return proxyDraft ? (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original : value;
}
/**
 * Check if a value is draftable
 */ function isDraftable(value, options) {
    if (!value || typeof value !== 'object') return false;
    let markResult;
    return Object.getPrototypeOf(value) === Object.prototype || Array.isArray(value) || value instanceof Map || value instanceof Set || !!(options === null || options === void 0 ? void 0 : options.mark) && ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable || typeof markResult === 'function');
}
function getPath(target, path = []) {
    if (Object.hasOwnProperty.call(target, 'key')) {
        // check if the parent is a draft and the original value is not equal to the current value
        const parentCopy = target.parent.copy;
        const proxyDraft = getProxyDraft(get(parentCopy, target.key));
        if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {
            return null;
        }
        const isSet = target.parent.type === 3 /* DraftType.Set */ ;
        const key = isSet ? Array.from(target.parent.setMap.keys()).indexOf(target.key) : target.key;
        // check if the key is still in the next state parent
        if (!(isSet && parentCopy.size > key || has(parentCopy, key))) return null;
        path.push(key);
    }
    if (target.parent) {
        return getPath(target.parent, path);
    }
    // `target` is root draft.
    path.reverse();
    try {
        // check if the path is valid
        resolvePath(target.copy, path);
    } catch (e) {
        return null;
    }
    return path;
}
function getType(target) {
    if (Array.isArray(target)) return 1 /* DraftType.Array */ ;
    if (target instanceof Map) return 2 /* DraftType.Map */ ;
    if (target instanceof Set) return 3 /* DraftType.Set */ ;
    return 0 /* DraftType.Object */ ;
}
function get(target, key) {
    return getType(target) === 2 /* DraftType.Map */  ? target.get(key) : target[key];
}
function set(target, key, value) {
    const type = getType(target);
    if (type === 2 /* DraftType.Map */ ) {
        target.set(key, value);
    } else {
        target[key] = value;
    }
}
function peek(target, key) {
    const state = getProxyDraft(target);
    const source = state ? latest(state) : target;
    return source[key];
}
function isEqual(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function revokeProxy(proxyDraft) {
    if (!proxyDraft) return;
    while(proxyDraft.finalities.revoke.length > 0){
        const revoke = proxyDraft.finalities.revoke.pop();
        revoke();
    }
}
// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901
function escapePath(path, pathAsArray) {
    return pathAsArray ? path : [
        ''
    ].concat(path).map((_item)=>{
        const item = `${_item}`;
        if (item.indexOf('/') === -1 && item.indexOf('~') === -1) return item;
        return item.replace(/~/g, '~0').replace(/\//g, '~1');
    }).join('/');
}
function unescapePath(path) {
    if (Array.isArray(path)) return path;
    return path.split('/').map((_item)=>_item.replace(/~1/g, '/').replace(/~0/g, '~')).slice(1);
}
function resolvePath(base, path) {
    for(let index = 0; index < path.length - 1; index += 1){
        const key = path[index];
        // use `index` in Set draft
        base = get(getType(base) === 3 /* DraftType.Set */  ? Array.from(base) : base, key);
        if (typeof base !== 'object') {
            throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);
        }
    }
    return base;
}
function strictCopy(target) {
    const copy = Object.create(Object.getPrototypeOf(target));
    Reflect.ownKeys(target).forEach((key)=>{
        let desc = Reflect.getOwnPropertyDescriptor(target, key);
        if (desc.enumerable && desc.configurable && desc.writable) {
            copy[key] = target[key];
            return;
        }
        // for freeze
        if (!desc.writable) {
            desc.writable = true;
            desc.configurable = true;
        }
        if (desc.get || desc.set) desc = {
            configurable: true,
            writable: true,
            enumerable: desc.enumerable,
            value: target[key]
        };
        Reflect.defineProperty(copy, key, desc);
    });
    return copy;
}
const propIsEnum = Object.prototype.propertyIsEnumerable;
function shallowCopy(original, options) {
    let markResult;
    if (Array.isArray(original)) {
        return Array.prototype.concat.call(original);
    } else if (original instanceof Set) {
        if (!isBaseSetInstance(original)) {
            const SubClass = Object.getPrototypeOf(original).constructor;
            return new SubClass(original.values());
        }
        return Set.prototype.difference ? Set.prototype.difference.call(original, new Set()) : new Set(original.values());
    } else if (original instanceof Map) {
        if (!isBaseMapInstance(original)) {
            const SubClass = Object.getPrototypeOf(original).constructor;
            return new SubClass(original);
        }
        return new Map(original);
    } else if ((options === null || options === void 0 ? void 0 : options.mark) && (markResult = options.mark(original, dataTypes), markResult !== undefined) && markResult !== dataTypes.mutable) {
        if (markResult === dataTypes.immutable) {
            return strictCopy(original);
        } else if (typeof markResult === 'function') {
            if (options.enablePatches || options.enableAutoFreeze) {
                throw new Error(`You can't use mark and patches or auto freeze together.`);
            }
            return markResult();
        }
        throw new Error(`Unsupported mark result: ${markResult}`);
    } else if (typeof original === 'object' && Object.getPrototypeOf(original) === Object.prototype) {
        // For best performance with shallow copies,
        // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.
        const copy = {};
        Object.keys(original).forEach((key)=>{
            copy[key] = original[key];
        });
        Object.getOwnPropertySymbols(original).forEach((key)=>{
            if (propIsEnum.call(original, key)) {
                copy[key] = original[key];
            }
        });
        return copy;
    } else {
        throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);
    }
}
function ensureShallowCopy(target) {
    if (target.copy) return;
    target.copy = shallowCopy(target.original, target.options);
}
function deepClone(target) {
    if (!isDraftable(target)) return getValue(target);
    if (Array.isArray(target)) return target.map(deepClone);
    if (target instanceof Map) {
        const iterable = Array.from(target.entries()).map(([k, v])=>[
                k,
                deepClone(v)
            ]);
        if (!isBaseMapInstance(target)) {
            const SubClass = Object.getPrototypeOf(target).constructor;
            return new SubClass(iterable);
        }
        return new Map(iterable);
    }
    if (target instanceof Set) {
        const iterable = Array.from(target).map(deepClone);
        if (!isBaseSetInstance(target)) {
            const SubClass = Object.getPrototypeOf(target).constructor;
            return new SubClass(iterable);
        }
        return new Set(iterable);
    }
    const copy = Object.create(Object.getPrototypeOf(target));
    for(const key in target)copy[key] = deepClone(target[key]);
    return copy;
}
function cloneIfNeeded(target) {
    return isDraft(target) ? deepClone(target) : target;
}
function markChanged(proxyDraft) {
    var _a;
    proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : new Map();
    if (!proxyDraft.operated) {
        proxyDraft.operated = true;
        if (proxyDraft.parent) {
            markChanged(proxyDraft.parent);
        }
    }
}
function throwFrozenError() {
    throw new Error('Cannot modify frozen object');
}
function deepFreeze(target, subKey, updatedValues, stack, keys) {
    {
        updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : new WeakMap();
        stack = stack !== null && stack !== void 0 ? stack : [];
        keys = keys !== null && keys !== void 0 ? keys : [];
        const value = updatedValues.has(target) ? updatedValues.get(target) : target;
        if (stack.length > 0) {
            const index = stack.indexOf(value);
            if (value && typeof value === 'object' && index !== -1) {
                if (stack[0] === value) {
                    throw new Error(`Forbids circular reference`);
                }
                throw new Error(`Forbids circular reference: ~/${keys.slice(0, index).map((key, index)=>{
                    if (typeof key === 'symbol') return `[${key.toString()}]`;
                    const parent = stack[index];
                    if (typeof key === 'object' && (parent instanceof Map || parent instanceof Set)) return Array.from(parent.keys()).indexOf(key);
                    return key;
                }).join('/')}`);
            }
            stack.push(value);
            keys.push(subKey);
        } else {
            stack.push(value);
        }
    }
    if (Object.isFrozen(target) || isDraft(target)) {
        {
            stack.pop();
            keys.pop();
        }
        return;
    }
    const type = getType(target);
    switch(type){
        case 2 /* DraftType.Map */ :
            for (const [key, value] of target){
                deepFreeze(key, key, updatedValues, stack, keys);
                deepFreeze(value, key, updatedValues, stack, keys);
            }
            target.set = target.clear = target.delete = throwFrozenError;
            break;
        case 3 /* DraftType.Set */ :
            for (const value of target){
                deepFreeze(value, value, updatedValues, stack, keys);
            }
            target.add = target.clear = target.delete = throwFrozenError;
            break;
        case 1 /* DraftType.Array */ :
            Object.freeze(target);
            let index = 0;
            for (const value of target){
                deepFreeze(value, index, updatedValues, stack, keys);
                index += 1;
            }
            break;
        default:
            Object.freeze(target);
            // ignore non-enumerable or symbol properties
            Object.keys(target).forEach((name)=>{
                const value = target[name];
                deepFreeze(value, name, updatedValues, stack, keys);
            });
    }
    {
        stack.pop();
        keys.pop();
    }
}
function forEach(target, iter) {
    const type = getType(target);
    if (type === 0 /* DraftType.Object */ ) {
        Reflect.ownKeys(target).forEach((key)=>{
            iter(key, target[key], target);
        });
    } else if (type === 1 /* DraftType.Array */ ) {
        let index = 0;
        for (const entry of target){
            iter(index, entry, target);
            index += 1;
        }
    } else {
        target.forEach((entry, index)=>iter(index, entry, target));
    }
}
function handleValue(target, handledSet, options) {
    if (isDraft(target) || !isDraftable(target, options) || handledSet.has(target) || Object.isFrozen(target)) return;
    const isSet = target instanceof Set;
    const setMap = isSet ? new Map() : undefined;
    handledSet.add(target);
    forEach(target, (key, value)=>{
        var _a;
        if (isDraft(value)) {
            const proxyDraft = getProxyDraft(value);
            ensureShallowCopy(proxyDraft);
            // A draft where a child node has been changed, or assigned a value
            const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated ? proxyDraft.copy : proxyDraft.original;
            // final update value
            set(isSet ? setMap : target, key, updatedValue);
        } else {
            handleValue(value, handledSet, options);
        }
    });
    if (setMap) {
        const set = target;
        const values = Array.from(set);
        set.clear();
        values.forEach((value)=>{
            set.add(setMap.has(value) ? setMap.get(value) : value);
        });
    }
}
function finalizeAssigned(proxyDraft, key) {
    // handle the draftable assigned values and the value is not a draft
    const copy = proxyDraft.type === 3 /* DraftType.Set */  ? proxyDraft.setMap : proxyDraft.copy;
    if (proxyDraft.finalities.revoke.length > 1 && proxyDraft.assignedMap.get(key) && copy) {
        handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);
    }
}
function finalizeSetValue(target) {
    if (target.type === 3 /* DraftType.Set */  && target.copy) {
        target.copy.clear();
        target.setMap.forEach((value)=>{
            target.copy.add(getValue(value));
        });
    }
}
function finalizePatches(target, generatePatches, patches, inversePatches) {
    const shouldFinalize = target.operated && target.assignedMap && target.assignedMap.size > 0 && !target.finalized;
    if (shouldFinalize) {
        if (patches && inversePatches) {
            const basePath = getPath(target);
            if (basePath) {
                generatePatches(target, basePath, patches, inversePatches);
            }
        }
        target.finalized = true;
    }
}
function markFinalization(target, key, value, generatePatches) {
    const proxyDraft = getProxyDraft(value);
    if (proxyDraft) {
        // !case: assign the draft value
        if (!proxyDraft.callbacks) {
            proxyDraft.callbacks = [];
        }
        proxyDraft.callbacks.push((patches, inversePatches)=>{
            var _a;
            const copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            if (isEqual(get(copy, key), value)) {
                let updatedValue = proxyDraft.original;
                if (proxyDraft.copy) {
                    updatedValue = proxyDraft.copy;
                }
                finalizeSetValue(target);
                finalizePatches(target, generatePatches, patches, inversePatches);
                if (target.options.enableAutoFreeze) {
                    target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();
                    target.options.updatedValues.set(updatedValue, proxyDraft.original);
                }
                // final update value
                set(copy, key, updatedValue);
            }
        });
        if (target.options.enableAutoFreeze) {
            // !case: assign the draft value in cross draft tree
            if (proxyDraft.finalities !== target.finalities) {
                target.options.enableAutoFreeze = false;
            }
        }
    }
    if (isDraftable(value, target.options)) {
        // !case: assign the non-draft value
        target.finalities.draft.push(()=>{
            const copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            if (isEqual(get(copy, key), value)) {
                finalizeAssigned(target, key);
            }
        });
    }
}
function generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {
    let { original, assignedMap, options } = proxyState;
    let copy = proxyState.copy;
    if (copy.length < original.length) {
        [original, copy] = [
            copy,
            original
        ];
        [patches, inversePatches] = [
            inversePatches,
            patches
        ];
    }
    for(let index = 0; index < original.length; index += 1){
        if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Replace,
                path,
                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
                value: cloneIfNeeded(copy[index])
            });
            inversePatches.push({
                op: Operation.Replace,
                path,
                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
                value: cloneIfNeeded(original[index])
            });
        }
    }
    for(let index = original.length; index < copy.length; index += 1){
        const _path = basePath.concat([
            index
        ]);
        const path = escapePath(_path, pathAsArray);
        patches.push({
            op: Operation.Add,
            path,
            // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
            value: cloneIfNeeded(copy[index])
        });
    }
    if (original.length < copy.length) {
        // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4
        // For performance, here we only generate an operation that replaces the length of the array,
        // which is inconsistent with JSON Patch specification
        const { arrayLengthAssignment = true } = options.enablePatches;
        if (arrayLengthAssignment) {
            const _path = basePath.concat([
                'length'
            ]);
            const path = escapePath(_path, pathAsArray);
            inversePatches.push({
                op: Operation.Replace,
                path,
                value: original.length
            });
        } else {
            for(let index = copy.length; original.length < index; index -= 1){
                const _path = basePath.concat([
                    index - 1
                ]);
                const path = escapePath(_path, pathAsArray);
                inversePatches.push({
                    op: Operation.Remove,
                    path
                });
            }
        }
    }
}
function generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {
    assignedMap.forEach((assignedValue, key)=>{
        const originalValue = get(original, key);
        const value = cloneIfNeeded(get(copy, key));
        const op = !assignedValue ? Operation.Remove : has(original, key) ? Operation.Replace : Operation.Add;
        if (isEqual(originalValue, value) && op === Operation.Replace) return;
        const _path = basePath.concat(key);
        const path = escapePath(_path, pathAsArray);
        patches.push(op === Operation.Remove ? {
            op,
            path
        } : {
            op,
            path,
            value
        });
        inversePatches.push(op === Operation.Add ? {
            op: Operation.Remove,
            path
        } : op === Operation.Remove ? {
            op: Operation.Add,
            path,
            value: originalValue
        } : {
            op: Operation.Replace,
            path,
            value: originalValue
        });
    });
}
function generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {
    let index = 0;
    original.forEach((value)=>{
        if (!copy.has(value)) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Remove,
                path,
                value
            });
            inversePatches.unshift({
                op: Operation.Add,
                path,
                value
            });
        }
        index += 1;
    });
    index = 0;
    copy.forEach((value)=>{
        if (!original.has(value)) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Add,
                path,
                value
            });
            inversePatches.unshift({
                op: Operation.Remove,
                path,
                value
            });
        }
        index += 1;
    });
}
function generatePatches(proxyState, basePath, patches, inversePatches) {
    const { pathAsArray = true } = proxyState.options.enablePatches;
    switch(proxyState.type){
        case 0 /* DraftType.Object */ :
        case 2 /* DraftType.Map */ :
            return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);
        case 1 /* DraftType.Array */ :
            return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
        case 3 /* DraftType.Set */ :
            return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
    }
}
let readable = false;
const checkReadable = (value, options, ignoreCheckDraftable = false)=>{
    if (typeof value === 'object' && value !== null && (!isDraftable(value, options) || ignoreCheckDraftable) && !readable) {
        throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);
    }
};
/**
 * `unsafe(callback)` to access mutable data directly in strict mode.
 *
 * ## Example
 *
 * ```ts
 * import { create, unsafe } from '../index';
 *
 * class Foobar {
 *   bar = 1;
 * }
 *
 * const baseState = { foobar: new Foobar() };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *    unsafe(() => {
 *      draft.foobar.bar = 2;
 *    });
 *   },
 *   {
 *     strict: true,
 *   }
 * );
 *
 * expect(state).toBe(baseState);
 * expect(state.foobar).toBe(baseState.foobar);
 * expect(state.foobar.bar).toBe(2);
 * ```
 */ function unsafe(callback) {
    readable = true;
    let result;
    try {
        result = callback();
    } finally{
        readable = false;
    }
    return result;
}
const mapHandler = {
    get size () {
        const current = latest(getProxyDraft(this));
        return current.size;
    },
    has (key) {
        return latest(getProxyDraft(this)).has(key);
    },
    set (key, value) {
        const target = getProxyDraft(this);
        const source = latest(target);
        if (!source.has(key) || !isEqual(source.get(key), value)) {
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(key, true);
            target.copy.set(key, value);
            markFinalization(target, key, value, generatePatches);
        }
        return this;
    },
    delete (key) {
        if (!this.has(key)) {
            return false;
        }
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        if (target.original.has(key)) {
            target.assignedMap.set(key, false);
        } else {
            target.assignedMap.delete(key);
        }
        target.copy.delete(key);
        return true;
    },
    clear () {
        const target = getProxyDraft(this);
        if (!this.size) return;
        ensureShallowCopy(target);
        markChanged(target);
        target.assignedMap = new Map();
        for (const [key] of target.original){
            target.assignedMap.set(key, false);
        }
        target.copy.clear();
    },
    forEach (callback, thisArg) {
        const target = getProxyDraft(this);
        latest(target).forEach((_value, _key)=>{
            callback.call(thisArg, this.get(_key), _key, this);
        });
    },
    get (key) {
        var _a, _b;
        const target = getProxyDraft(this);
        const value = latest(target).get(key);
        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
        if (target.options.strict) {
            checkReadable(value, target.options, mutable);
        }
        if (mutable) {
            return value;
        }
        if (target.finalized || !isDraftable(value, target.options)) {
            return value;
        }
        // drafted or reassigned
        if (value !== target.original.get(key)) {
            return value;
        }
        const draft = internal.createDraft({
            original: value,
            parentDraft: target,
            key,
            finalities: target.finalities,
            options: target.options
        });
        ensureShallowCopy(target);
        target.copy.set(key, draft);
        return draft;
    },
    keys () {
        return latest(getProxyDraft(this)).keys();
    },
    values () {
        const iterator = this.keys();
        return {
            [iteratorSymbol]: ()=>this.values(),
            next: ()=>{
                const result = iterator.next();
                if (result.done) return result;
                const value = this.get(result.value);
                return {
                    done: false,
                    value
                };
            }
        };
    },
    entries () {
        const iterator = this.keys();
        return {
            [iteratorSymbol]: ()=>this.entries(),
            next: ()=>{
                const result = iterator.next();
                if (result.done) return result;
                const value = this.get(result.value);
                return {
                    done: false,
                    value: [
                        result.value,
                        value
                    ]
                };
            }
        };
    },
    [iteratorSymbol] () {
        return this.entries();
    }
};
const mapHandlerKeys = Reflect.ownKeys(mapHandler);
const getNextIterator = (target, iterator, { isValuesIterator })=>()=>{
        var _a, _b;
        const result = iterator.next();
        if (result.done) return result;
        const key = result.value;
        let value = target.setMap.get(key);
        const currentDraft = getProxyDraft(value);
        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
        if (target.options.strict) {
            checkReadable(key, target.options, mutable);
        }
        if (!mutable && !currentDraft && isDraftable(key, target.options) && !target.finalized && target.original.has(key)) {
            // draft a draftable original set item
            const proxy = internal.createDraft({
                original: key,
                parentDraft: target,
                key,
                finalities: target.finalities,
                options: target.options
            });
            target.setMap.set(key, proxy);
            value = proxy;
        } else if (currentDraft) {
            // drafted
            value = currentDraft.proxy;
        }
        return {
            done: false,
            value: isValuesIterator ? value : [
                value,
                value
            ]
        };
    };
const setHandler = {
    get size () {
        const target = getProxyDraft(this);
        return target.setMap.size;
    },
    has (value) {
        const target = getProxyDraft(this);
        // reassigned or non-draftable values
        if (target.setMap.has(value)) return true;
        ensureShallowCopy(target);
        const valueProxyDraft = getProxyDraft(value);
        // drafted
        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) return true;
        return false;
    },
    add (value) {
        const target = getProxyDraft(this);
        if (!this.has(value)) {
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(value, true);
            target.setMap.set(value, value);
            markFinalization(target, value, value, generatePatches);
        }
        return this;
    },
    delete (value) {
        if (!this.has(value)) {
            return false;
        }
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        const valueProxyDraft = getProxyDraft(value);
        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {
            // delete drafted
            target.assignedMap.set(valueProxyDraft.original, false);
            return target.setMap.delete(valueProxyDraft.original);
        }
        if (!valueProxyDraft && target.setMap.has(value)) {
            // non-draftable values
            target.assignedMap.set(value, false);
        } else {
            // reassigned
            target.assignedMap.delete(value);
        }
        // delete reassigned or non-draftable values
        return target.setMap.delete(value);
    },
    clear () {
        if (!this.size) return;
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        for (const value of target.original){
            target.assignedMap.set(value, false);
        }
        target.setMap.clear();
    },
    values () {
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        const iterator = target.setMap.keys();
        return {
            [Symbol.iterator]: ()=>this.values(),
            next: getNextIterator(target, iterator, {
                isValuesIterator: true
            })
        };
    },
    entries () {
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        const iterator = target.setMap.keys();
        return {
            [Symbol.iterator]: ()=>this.entries(),
            next: getNextIterator(target, iterator, {
                isValuesIterator: false
            })
        };
    },
    keys () {
        return this.values();
    },
    [iteratorSymbol] () {
        return this.values();
    },
    forEach (callback, thisArg) {
        const iterator = this.values();
        let result = iterator.next();
        while(!result.done){
            callback.call(thisArg, result.value, result.value, this);
            result = iterator.next();
        }
    }
};
if (Set.prototype.difference) {
    // for compatibility with new Set methods
    // https://github.com/tc39/proposal-set-methods
    // And `https://github.com/tc39/proposal-set-methods/blob/main/details.md#symbolspecies` has some details about the `@@species` symbol.
    // So we can't use SubSet instance constructor to get the constructor of the SubSet instance.
    Object.assign(setHandler, {
        intersection (other) {
            return Set.prototype.intersection.call(new Set(this.values()), other);
        },
        union (other) {
            return Set.prototype.union.call(new Set(this.values()), other);
        },
        difference (other) {
            return Set.prototype.difference.call(new Set(this.values()), other);
        },
        symmetricDifference (other) {
            return Set.prototype.symmetricDifference.call(new Set(this.values()), other);
        },
        isSubsetOf (other) {
            return Set.prototype.isSubsetOf.call(new Set(this.values()), other);
        },
        isSupersetOf (other) {
            return Set.prototype.isSupersetOf.call(new Set(this.values()), other);
        },
        isDisjointFrom (other) {
            return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);
        }
    });
}
const setHandlerKeys = Reflect.ownKeys(setHandler);
const draftsCache = new WeakSet();
const proxyHandler = {
    get (target, key, receiver) {
        var _a, _b;
        const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];
        // Improve draft reading performance by caching the draft copy.
        if (copy && draftsCache.has(copy)) {
            return copy;
        }
        if (key === PROXY_DRAFT) return target;
        let markResult;
        if (target.options.mark) {
            // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`
            // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`
            const value = key === 'size' && (target.original instanceof Map || target.original instanceof Set) ? Reflect.get(target.original, key) : Reflect.get(target.original, key, receiver);
            markResult = target.options.mark(value, dataTypes);
            if (markResult === dataTypes.mutable) {
                if (target.options.strict) {
                    checkReadable(value, target.options, true);
                }
                return value;
            }
        }
        const source = latest(target);
        if (source instanceof Map && mapHandlerKeys.includes(key)) {
            if (key === 'size') {
                return Object.getOwnPropertyDescriptor(mapHandler, 'size').get.call(target.proxy);
            }
            const handle = mapHandler[key];
            if (handle) {
                return handle.bind(target.proxy);
            }
        }
        if (source instanceof Set && setHandlerKeys.includes(key)) {
            if (key === 'size') {
                return Object.getOwnPropertyDescriptor(setHandler, 'size').get.call(target.proxy);
            }
            const handle = setHandler[key];
            if (handle) {
                return handle.bind(target.proxy);
            }
        }
        if (!has(source, key)) {
            const desc = getDescriptor(source, key);
            return desc ? `value` in desc ? desc.value : (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy) : undefined;
        }
        const value = source[key];
        if (target.options.strict) {
            checkReadable(value, target.options);
        }
        if (target.finalized || !isDraftable(value, target.options)) {
            return value;
        }
        // Ensure that the assigned values are not drafted
        if (value === peek(target.original, key)) {
            ensureShallowCopy(target);
            target.copy[key] = createDraft({
                original: target.original[key],
                parentDraft: target,
                key: target.type === 1 /* DraftType.Array */  ? Number(key) : key,
                finalities: target.finalities,
                options: target.options
            });
            // !case: support for custom shallow copy function
            if (typeof markResult === 'function') {
                const subProxyDraft = getProxyDraft(target.copy[key]);
                ensureShallowCopy(subProxyDraft);
                // Trigger a custom shallow copy to update to a new copy
                markChanged(subProxyDraft);
                return subProxyDraft.copy;
            }
            return target.copy[key];
        }
        return value;
    },
    set (target, key, value) {
        var _a;
        if (target.type === 3 /* DraftType.Set */  || target.type === 2 /* DraftType.Map */ ) {
            throw new Error(`Map/Set draft does not support any property assignment.`);
        }
        let _key;
        if (target.type === 1 /* DraftType.Array */  && key !== 'length' && !(Number.isInteger(_key = Number(key)) && _key >= 0 && (key === 0 || _key === 0 || String(_key) === String(key)))) {
            throw new Error(`Only supports setting array indices and the 'length' property.`);
        }
        const desc = getDescriptor(latest(target), key);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
            // !case: cover the case of setter
            desc.set.call(target.proxy, value);
            return true;
        }
        const current = peek(latest(target), key);
        const currentProxyDraft = getProxyDraft(current);
        if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {
            // !case: ignore the case of assigning the original draftable value to a draft
            target.copy[key] = value;
            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();
            target.assignedMap.set(key, false);
            return true;
        }
        // !case: handle new props with value 'undefined'
        if (isEqual(value, current) && (value !== undefined || has(target.original, key))) return true;
        ensureShallowCopy(target);
        markChanged(target);
        if (has(target.original, key) && isEqual(value, target.original[key])) {
            // !case: handle the case of assigning the original non-draftable value to a draft
            target.assignedMap.delete(key);
        } else {
            target.assignedMap.set(key, true);
        }
        target.copy[key] = value;
        markFinalization(target, key, value, generatePatches);
        return true;
    },
    has (target, key) {
        return key in latest(target);
    },
    ownKeys (target) {
        return Reflect.ownKeys(latest(target));
    },
    getOwnPropertyDescriptor (target, key) {
        const source = latest(target);
        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
        if (!descriptor) return descriptor;
        return {
            writable: true,
            configurable: target.type !== 1 /* DraftType.Array */  || key !== 'length',
            enumerable: descriptor.enumerable,
            value: source[key]
        };
    },
    getPrototypeOf (target) {
        return Reflect.getPrototypeOf(target.original);
    },
    setPrototypeOf () {
        throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);
    },
    defineProperty () {
        throw new Error(`Cannot call 'defineProperty()' on drafts`);
    },
    deleteProperty (target, key) {
        var _a;
        if (target.type === 1 /* DraftType.Array */ ) {
            return proxyHandler.set.call(this, target, key, undefined, target.proxy);
        }
        if (peek(target.original, key) !== undefined || key in target.original) {
            // !case: delete an existing key
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(key, false);
        } else {
            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();
            // The original non-existent key has been deleted
            target.assignedMap.delete(key);
        }
        if (target.copy) delete target.copy[key];
        return true;
    }
};
function createDraft(createDraftOptions) {
    const { original, parentDraft, key, finalities, options } = createDraftOptions;
    const type = getType(original);
    const proxyDraft = {
        type,
        finalized: false,
        parent: parentDraft,
        original,
        copy: null,
        proxy: null,
        finalities,
        options,
        // Mapping of draft Set items to their corresponding draft values.
        setMap: type === 3 /* DraftType.Set */  ? new Map(original.entries()) : undefined
    };
    // !case: undefined as a draft map key
    if (key || 'key' in createDraftOptions) {
        proxyDraft.key = key;
    }
    const { proxy, revoke } = Proxy.revocable(type === 1 /* DraftType.Array */  ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);
    finalities.revoke.push(revoke);
    draftsCache.add(proxy);
    proxyDraft.proxy = proxy;
    if (parentDraft) {
        const target = parentDraft;
        target.finalities.draft.push((patches, inversePatches)=>{
            var _a, _b;
            const oldProxyDraft = getProxyDraft(proxy);
            // if target is a Set draft, `setMap` is the real Set copies proxy mapping.
            let copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            const draft = get(copy, key);
            const proxyDraft = getProxyDraft(draft);
            if (proxyDraft) {
                // assign the updated value to the copy object
                let updatedValue = proxyDraft.original;
                if (proxyDraft.operated) {
                    updatedValue = getValue(draft);
                }
                finalizeSetValue(proxyDraft);
                finalizePatches(proxyDraft, generatePatches, patches, inversePatches);
                if (target.options.enableAutoFreeze) {
                    target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();
                    target.options.updatedValues.set(updatedValue, proxyDraft.original);
                }
                // final update value
                set(copy, key, updatedValue);
            }
            // !case: handle the deleted key
            (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback)=>{
                callback(patches, inversePatches);
            });
        });
    } else {
        // !case: handle the root draft
        const target = getProxyDraft(proxy);
        target.finalities.draft.push((patches, inversePatches)=>{
            finalizeSetValue(target);
            finalizePatches(target, generatePatches, patches, inversePatches);
        });
    }
    return proxy;
}
internal.createDraft = createDraft;
function finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {
    var _a;
    const proxyDraft = getProxyDraft(result);
    const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;
    const hasReturnedValue = !!returnedValue.length;
    if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {
        while(proxyDraft.finalities.draft.length > 0){
            const finalize = proxyDraft.finalities.draft.pop();
            finalize(patches, inversePatches);
        }
    }
    const state = hasReturnedValue ? returnedValue[0] : proxyDraft ? proxyDraft.operated ? proxyDraft.copy : proxyDraft.original : result;
    if (proxyDraft) revokeProxy(proxyDraft);
    if (enableAutoFreeze) {
        deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);
    }
    return [
        state,
        patches && hasReturnedValue ? [
            {
                op: Operation.Replace,
                path: [],
                value: returnedValue[0]
            }
        ] : patches,
        inversePatches && hasReturnedValue ? [
            {
                op: Operation.Replace,
                path: [],
                value: original
            }
        ] : inversePatches
    ];
}
function draftify(baseState, options) {
    var _a;
    const finalities = {
        draft: [],
        revoke: [],
        handledSet: new WeakSet()
    };
    let patches;
    let inversePatches;
    if (options.enablePatches) {
        patches = [];
        inversePatches = [];
    }
    const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable || !isDraftable(baseState, options);
    const draft = isMutable ? baseState : createDraft({
        original: baseState,
        parentDraft: null,
        finalities,
        options
    });
    return [
        draft,
        (returnedValue = [])=>{
            const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);
            return options.enablePatches ? [
                finalizedState,
                finalizedPatches,
                finalizedInversePatches
            ] : finalizedState;
        }
    ];
}
function handleReturnValue(options) {
    const { rootDraft, value, useRawReturn = false, isRoot = true } = options;
    forEach(value, (key, item, source)=>{
        const proxyDraft = getProxyDraft(item);
        // just handle the draft which is created by the same rootDraft
        if (proxyDraft && rootDraft && proxyDraft.finalities === rootDraft.finalities) {
            options.isContainDraft = true;
            const currentValue = proxyDraft.original;
            // final update value, but just handle return value
            if (source instanceof Set) {
                const arr = Array.from(source);
                source.clear();
                arr.forEach((_item)=>source.add(key === _item ? currentValue : _item));
            } else {
                set(source, key, currentValue);
            }
        } else if (typeof item === 'object' && item !== null) {
            options.value = item;
            options.isRoot = false;
            handleReturnValue(options);
        }
    });
    if (isRoot) {
        if (!options.isContainDraft) console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);
        if (useRawReturn) {
            console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);
        }
    }
}
function getCurrent(target) {
    var _a;
    const proxyDraft = getProxyDraft(target);
    if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options)) return target;
    const type = getType(target);
    if (proxyDraft && !proxyDraft.operated) return proxyDraft.original;
    let currentValue;
    function ensureShallowCopy() {
        currentValue = type === 2 /* DraftType.Map */  ? !isBaseMapInstance(target) ? new (Object.getPrototypeOf(target)).constructor(target) : new Map(target) : type === 3 /* DraftType.Set */  ? Array.from(proxyDraft.setMap.values()) : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);
    }
    if (proxyDraft) {
        // It's a proxy draft, let's create a shallow copy eagerly
        proxyDraft.finalized = true;
        try {
            ensureShallowCopy();
        } finally{
            proxyDraft.finalized = false;
        }
    } else {
        // It's not a proxy draft, let's use the target directly and let's see
        // lazily if we need to create a shallow copy
        currentValue = target;
    }
    forEach(currentValue, (key, value)=>{
        if (proxyDraft && isEqual(get(proxyDraft.original, key), value)) return;
        const newValue = getCurrent(value);
        if (newValue !== value) {
            if (currentValue === target) ensureShallowCopy();
            set(currentValue, key, newValue);
        }
    });
    if (type === 3 /* DraftType.Set */ ) {
        const value = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : currentValue;
        return !isBaseSetInstance(value) ? new (Object.getPrototypeOf(value)).constructor(currentValue) : new Set(currentValue);
    }
    return currentValue;
}
function current(target) {
    if (!isDraft(target)) {
        throw new Error(`current() is only used for Draft, parameter: ${target}`);
    }
    return getCurrent(target);
}
/**
 * `makeCreator(options)` to make a creator function.
 *
 * ## Example
 *
 * ```ts
 * import { makeCreator } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const create = makeCreator({ enableAutoFreeze: true });
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 * );
 *
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(state).not.toBe(baseState);
 * expect(state.foo).not.toBe(baseState.foo);
 * expect(state.arr).toBe(baseState.arr);
 * expect(Object.isFrozen(state)).toBeTruthy();
 * ```
 */ const makeCreator = (arg)=>{
    if (arg !== undefined && Object.prototype.toString.call(arg) !== '[object Object]') {
        throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);
    }
    return function create(arg0, arg1, arg2) {
        var _a, _b, _c;
        if (typeof arg0 === 'function' && typeof arg1 !== 'function') {
            return function(base, ...args) {
                return create(base, (draft)=>arg0.call(this, draft, ...args), arg1);
            };
        }
        const base = arg0;
        const mutate = arg1;
        let options = arg2;
        if (typeof arg1 !== 'function') {
            options = arg1;
        }
        if (options !== undefined && Object.prototype.toString.call(options) !== '[object Object]') {
            throw new Error(`Invalid options: ${options}, 'options' should be an object.`);
        }
        options = Object.assign(Object.assign({}, arg), options);
        const state = isDraft(base) ? current(base) : base;
        const mark = Array.isArray(options.mark) ? (value, types)=>{
            for (const mark of options.mark){
                if (typeof mark !== 'function') {
                    throw new Error(`Invalid mark: ${mark}, 'mark' should be a function.`);
                }
                const result = mark(value, types);
                if (result) {
                    return result;
                }
            }
            return;
        } : options.mark;
        const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;
        const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;
        const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;
        const _options = {
            enableAutoFreeze,
            mark,
            strict,
            enablePatches
        };
        if (!isDraftable(state, _options) && typeof state === 'object' && state !== null) {
            throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
        }
        const [draft, finalize] = draftify(state, _options);
        if (typeof arg1 !== 'function') {
            if (!isDraftable(state, _options)) {
                throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
            }
            return [
                draft,
                finalize
            ];
        }
        let result;
        try {
            result = mutate(draft);
        } catch (error) {
            revokeProxy(getProxyDraft(draft));
            throw error;
        }
        const returnValue = (value)=>{
            const proxyDraft = getProxyDraft(draft);
            if (!isDraft(value)) {
                if (value !== undefined && !isEqual(value, draft) && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {
                    throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);
                }
                const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];
                if (rawReturnValue) {
                    const _value = rawReturnValue[0];
                    if (_options.strict && typeof value === 'object' && value !== null) {
                        handleReturnValue({
                            rootDraft: proxyDraft,
                            value,
                            useRawReturn: true
                        });
                    }
                    return finalize([
                        _value
                    ]);
                }
                if (value !== undefined) {
                    if (typeof value === 'object' && value !== null) {
                        handleReturnValue({
                            rootDraft: proxyDraft,
                            value
                        });
                    }
                    return finalize([
                        value
                    ]);
                }
            }
            if (value === draft || value === undefined) {
                return finalize([]);
            }
            const returnedProxyDraft = getProxyDraft(value);
            if (_options === returnedProxyDraft.options) {
                if (returnedProxyDraft.operated) {
                    throw new Error(`Cannot return a modified child draft.`);
                }
                return finalize([
                    current(value)
                ]);
            }
            return finalize([
                value
            ]);
        };
        if (result instanceof Promise) {
            return result.then(returnValue, (error)=>{
                revokeProxy(getProxyDraft(draft));
                throw error;
            });
        }
        return returnValue(result);
    };
};
/**
 * `create(baseState, callback, options)` to create the next state
 *
 * ## Example
 *
 * ```ts
 * import { create } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 * );
 *
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(state).not.toBe(baseState);
 * expect(state.foo).not.toBe(baseState.foo);
 * expect(state.arr).toBe(baseState.arr);
 * ```
 */ const create = makeCreator();
/**
 * `apply(state, patches)` to apply patches to state
 *
 * ## Example
 *
 * ```ts
 * import { create, apply } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const [state, patches] = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 *   { enablePatches: true }
 * );
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);
 * expect(state).toEqual(apply(baseState, patches));
 * ```
 */ function apply(state, patches, applyOptions) {
    let i;
    for(i = patches.length - 1; i >= 0; i -= 1){
        const { value, op, path } = patches[i];
        if (!path.length && op === Operation.Replace || path === '' && op === Operation.Add) {
            state = value;
            break;
        }
    }
    if (i > -1) {
        patches = patches.slice(i + 1);
    }
    const mutate = (draft)=>{
        patches.forEach((patch)=>{
            const { path: _path, op } = patch;
            const path = unescapePath(_path);
            let base = draft;
            for(let index = 0; index < path.length - 1; index += 1){
                const parentType = getType(base);
                let key = path[index];
                if (typeof key !== 'string' && typeof key !== 'number') {
                    key = String(key);
                }
                if ((parentType === 0 /* DraftType.Object */  || parentType === 1 /* DraftType.Array */ ) && (key === '__proto__' || key === 'constructor') || typeof base === 'function' && key === 'prototype') {
                    throw new Error(`Patching reserved attributes like __proto__ and constructor is not allowed.`);
                }
                // use `index` in Set draft
                base = get(parentType === 3 /* DraftType.Set */  ? Array.from(base) : base, key);
                if (typeof base !== 'object') {
                    throw new Error(`Cannot apply patch at '${path.join('/')}'.`);
                }
            }
            const type = getType(base);
            // ensure the original patch is not modified.
            const value = deepClone(patch.value);
            const key = path[path.length - 1];
            switch(op){
                case Operation.Replace:
                    switch(type){
                        case 2 /* DraftType.Map */ :
                            return base.set(key, value);
                        case 3 /* DraftType.Set */ :
                            throw new Error(`Cannot apply replace patch to set.`);
                        default:
                            return base[key] = value;
                    }
                case Operation.Add:
                    switch(type){
                        case 1 /* DraftType.Array */ :
                            // If the "-" character is used to
                            // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),
                            // this has the effect of appending the value to the array.
                            return key === '-' ? base.push(value) : base.splice(key, 0, value);
                        case 2 /* DraftType.Map */ :
                            return base.set(key, value);
                        case 3 /* DraftType.Set */ :
                            return base.add(value);
                        default:
                            return base[key] = value;
                    }
                case Operation.Remove:
                    switch(type){
                        case 1 /* DraftType.Array */ :
                            return base.splice(key, 1);
                        case 2 /* DraftType.Map */ :
                            return base.delete(key);
                        case 3 /* DraftType.Set */ :
                            return base.delete(patch.value);
                        default:
                            return delete base[key];
                    }
                default:
                    throw new Error(`Unsupported patch operation: ${op}.`);
            }
        });
    };
    if (isDraft(state)) {
        if (applyOptions !== undefined) {
            throw new Error(`Cannot apply patches with options to a draft.`);
        }
        mutate(state);
        return state;
    }
    return create(state, mutate, Object.assign(Object.assign({}, applyOptions), {
        enablePatches: false
    }));
}
/**
 * `original(draft)` to get original state in the draft mutation function.
 *
 * ## Example
 *
 * ```ts
 * import { create, original } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *     expect(original(draft.foo)).toEqual({ bar: 'str' });
 *   }
 * );
 * ```
 */ function original(target) {
    const proxyDraft = getProxyDraft(target);
    if (!proxyDraft) {
        throw new Error(`original() is only used for a draft, parameter: ${target}`);
    }
    return proxyDraft.original;
}
/**
 * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.
 *
 * ## Example
 *
 * ```ts
 * import { create, rawReturn } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     return rawReturn(baseState);
 *   },
 * );
 * expect(state).toBe(baseState);
 * ```
 */ function rawReturn(value) {
    if (arguments.length === 0) {
        throw new Error('rawReturn() must be called with a value.');
    }
    if (arguments.length > 1) {
        throw new Error('rawReturn() must be called with one argument.');
    }
    if (value !== undefined && (typeof value !== 'object' || value === null)) {
        console.warn('rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().');
    }
    return {
        [RAW_RETURN_SYMBOL]: [
            value
        ]
    };
}
const constructorString = Object.prototype.constructor.toString();
/**
 * Check if the value is a simple object(No prototype chain object or iframe same-origin object),
 * support case: https://github.com/unadlib/mutative/issues/17
 */ const isSimpleObject = (value)=>{
    if (!value || typeof value !== 'object') return false;
    const prototype = Object.getPrototypeOf(value);
    if (prototype === null) {
        return true;
    }
    const constructor = Object.hasOwnProperty.call(prototype, 'constructor') && prototype.constructor;
    if (constructor === Object) return true;
    return typeof constructor === 'function' && Function.toString.call(constructor) === constructorString;
};
const markSimpleObject = (value)=>{
    if (isSimpleObject(value)) {
        return dataTypes.immutable;
    }
    return;
};
/**
 * Cast a value to an Draft type value.
 */ function castDraft(value) {
    return value;
}
/**
 * Cast a value to an Immutable type value.
 */ function castImmutable(value) {
    return value;
}
/**
 * Cast a value to an Mutable type value.
 */ function castMutable(draft) {
    return draft;
}
;
 //# sourceMappingURL=mutative.esm.mjs.map
}),
"[project]/node_modules/@udecode/plate-core/node_modules/zustand-x/dist/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createStore",
    ()=>createStore,
    "createZustandStore",
    ()=>createZustandStore,
    "extendActions",
    ()=>extendActions,
    "extendSelectors",
    ()=>extendSelectors,
    "getOptions",
    ()=>getOptions,
    "immerMiddleware",
    ()=>immerMiddleware,
    "mutativeMiddleware",
    ()=>mutativeMiddleware,
    "storeFactory",
    ()=>storeFactory,
    "useStoreSelect",
    ()=>useStoreSelect,
    "useStoreState",
    ()=>useStoreState,
    "useStoreValue",
    ()=>useStoreValue,
    "useTracked",
    ()=>useTracked,
    "useTrackedStore",
    ()=>useTrackedStore
]);
// src/createStore.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2d$x$2f$node_modules$2f$react$2d$tracked$2f$dist$2f$index$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@udecode/plate-core/node_modules/zustand-x/node_modules/react-tracked/dist/index.modern.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2f$esm$2f$middleware$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@udecode/plate-core/node_modules/zustand/esm/middleware.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2f$esm$2f$traditional$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@udecode/plate-core/node_modules/zustand/esm/traditional.mjs [app-client] (ecmascript)");
// src/middlewares/immer.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)");
// src/middlewares/mutative.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mutative/dist/mutative.esm.mjs [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
;
;
;
;
;
var immerImpl = (initializer)=>(set, get, store)=>{
        store.setState = (updater, replace, ...a)=>{
            const nextState = typeof updater === "function" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["produce"])(updater) : updater;
            return set(nextState, typeof replace === "boolean" ? replace : true, ...a);
        };
        return initializer(store.setState, get, store);
    };
var immerMiddleware = immerImpl;
;
var mutativeImpl = (initializer, options)=>(set, get, store)=>{
        store.setState = (updater, replace, ...a)=>{
            const nextState = typeof updater === "function" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])(updater, options ? __spreadProps(__spreadValues({}, options), {
                enablePatches: false
            }) : options) : updater;
            return set(nextState, typeof replace === "boolean" ? replace : true, ...a);
        };
        return initializer(store.setState, get, store);
    };
var mutativeMiddleware = mutativeImpl;
;
// src/utils/helpers.ts
var getOptions = (option, fallbackEnabled = false)=>{
    const isBooleanValue = typeof option === "boolean";
    const _a = isBooleanValue ? {} : option || {}, { enabled } = _a, config = __objRest(_a, [
        "enabled"
    ]);
    const isValueProvided = isBooleanValue ? option : enabled;
    return __spreadValues({
        enabled: isValueProvided != null ? isValueProvided : fallbackEnabled
    }, config);
};
// src/utils/extendActions.ts
var extendActions = (builder, api)=>{
    const newActions = builder(api);
    const actions = __spreadValues(__spreadValues({}, api.actions), newActions);
    return __spreadProps(__spreadValues({}, api), {
        actions,
        set: (key, ...args)=>{
            if (key in actions) {
                const action = actions[key];
                return action(...args);
            }
            return api.set(key, args[0]);
        }
    });
};
// src/utils/extendSelectors.ts
var identity = (arg)=>arg;
var extendSelectors = (builder, api)=>{
    const newSelectors = builder(api);
    const selectors = __spreadValues(__spreadValues({}, api.selectors), newSelectors);
    return __spreadProps(__spreadValues({}, api), {
        get: (key, ...args)=>{
            if (key in selectors) {
                const selector = selectors[key];
                return selector(...args);
            }
            return api.get(key);
        },
        subscribe: (key, ...args)=>{
            if (key in selectors) {
                let options;
                let selector;
                let listener;
                const lastArg1 = args.at(-1);
                const lastArg2 = args.at(-2);
                const lastArg3 = args.at(-3);
                let argsEndIdx = -1;
                if (typeof lastArg1 === "function") {
                    listener = lastArg1;
                    selector = typeof lastArg2 === "function" ? lastArg2 : identity;
                    argsEndIdx = typeof lastArg2 === "function" ? -2 : -1;
                } else {
                    options = lastArg1;
                    listener = lastArg2;
                    selector = lastArg3;
                    argsEndIdx = -3;
                }
                return api.subscribe(// The key `state` does not matter, as selectors are closures over the `api`
                "state", ()=>selector(selectors[key](...args.slice(0, argsEndIdx))), listener, options);
            }
            return api.subscribe(key, ...args);
        },
        selectors,
        useValue: (key, ...args)=>{
            if (key in selectors) {
                const selector = selectors[key];
                const lastArg = args.at(-1);
                const equalityFn = typeof lastArg === "function" ? lastArg : void 0;
                const selectorArgs = equalityFn ? args.slice(0, -1) : args;
                return api.useStore({
                    "extendSelectors.useStore": ()=>selector(...selectorArgs)
                }["extendSelectors.useStore"], equalityFn);
            }
            return api.useValue(key, args[0]);
        }
    });
};
// src/utils/storeFactory.ts
var storeFactory = (api)=>{
    return __spreadProps(__spreadValues({}, api), {
        actions: api.actions || {},
        extendSelectors: (builder)=>storeFactory(extendSelectors(builder, api)),
        extendActions: (builder)=>storeFactory(extendActions(builder, api))
    });
};
// src/createStore.ts
var createStore = (initializer, options)=>{
    const { name, devtools: devtoolsOptions, immer: immerOptions, mutative: mutativeOptions, persist: persistOptions, isMutativeState } = options;
    const middlewares = [];
    const _devtoolsOptionsInternal = getOptions(devtoolsOptions);
    if (_devtoolsOptionsInternal.enabled) {
        middlewares.push((config)=>{
            var _a;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2f$esm$2f$middleware$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["devtools"])(config, __spreadProps(__spreadValues({}, _devtoolsOptionsInternal), {
                name: (_a = _devtoolsOptionsInternal == null ? void 0 : _devtoolsOptionsInternal.name) != null ? _a : name
            }));
        });
    }
    const _persistOptionsInternal = getOptions(persistOptions);
    if (_persistOptionsInternal.enabled) {
        middlewares.push((config)=>{
            var _a;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2f$esm$2f$middleware$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["persist"])(config, __spreadProps(__spreadValues({}, _persistOptionsInternal), {
                name: (_a = _persistOptionsInternal.name) != null ? _a : name
            }));
        });
    }
    const _immerOptionsInternal = getOptions(immerOptions);
    if (_immerOptionsInternal.enabled) {
        middlewares.push((config)=>immerMiddleware(config, _immerOptionsInternal));
    }
    const _mutativeOptionsInternal = getOptions(mutativeOptions);
    if (_mutativeOptionsInternal.enabled) {
        middlewares.push((config)=>mutativeMiddleware(config, _mutativeOptionsInternal));
    }
    const stateMutators = middlewares.reverse().reduce((y, fn)=>fn(y), typeof initializer === "function" ? initializer : ()=>initializer);
    const store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2f$esm$2f$traditional$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createWithEqualityFn"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2f$esm$2f$middleware$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subscribeWithSelector"])(stateMutators));
    const useTrackedStore2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2d$x$2f$node_modules$2f$react$2d$tracked$2f$dist$2f$index$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createTrackedSelector"])(store);
    const useTracked2 = (key)=>{
        return useTrackedStore2()[key];
    };
    const getFn = (key)=>{
        if (key === "state") {
            return store.getState();
        }
        return store.getState()[key];
    };
    const subscribeFn = (key, selector, listener, subscribeOptions)=>{
        if (key === "state") {
            return store.subscribe(selector, listener, subscribeOptions);
        }
        let wrappedSelector;
        if (listener) {
            wrappedSelector = (state)=>selector(state[key]);
        } else {
            listener = selector;
            wrappedSelector = (state)=>state[key];
        }
        return store.subscribe(wrappedSelector, listener, subscribeOptions);
    };
    const isMutative = isMutativeState || _immerOptionsInternal.enabled || _mutativeOptionsInternal.enabled;
    const setFn = (key, value)=>{
        var _a;
        if (key === "state") {
            return store.setState(value);
        }
        const typedKey = key;
        const prevValue = store.getState()[typedKey];
        if (prevValue === value) return;
        const actionKey = key.replace(/^\S/, (s)=>s.toUpperCase());
        const debugLog = name ? `@@${name}/set${actionKey}` : void 0;
        (_a = store.setState) == null ? void 0 : _a.call(store, isMutative ? (draft)=>{
            draft[typedKey] = value;
        } : {
            [typedKey]: value
        }, void 0, debugLog);
    };
    const useValue = (key, equalityFn)=>{
        return store((state)=>state[key], equalityFn);
    };
    const useState = (key, equalityFn)=>{
        const value = useValue(key, equalityFn);
        return [
            value,
            (val)=>setFn(key, val)
        ];
    };
    const apiInternal = {
        get: getFn,
        name,
        set: setFn,
        subscribe: subscribeFn,
        store,
        useStore: store,
        useValue,
        useState,
        useTracked: useTracked2,
        useTrackedStore: useTrackedStore2,
        actions: {},
        selectors: {}
    };
    return storeFactory(apiInternal);
};
var createZustandStore = createStore;
// src/useStore.ts
function useStoreValue(store, key, ...args) {
    return store.useValue(key, ...args);
}
function useStoreState(store, key, equalityFn) {
    return store.useState(key, equalityFn);
}
function useTrackedStore(store) {
    return store.useTrackedStore();
}
function useTracked(store, key) {
    return store.useTracked(key);
}
var useStoreSelect = (store, selector, equalityFn)=>{
    return store.useStore(selector, equalityFn);
};
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/is-plain-object/dist/is-plain-object.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ __turbopack_context__.s([
    "isPlainObject",
    ()=>isPlainObject
]);
function isObject(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
}
function isPlainObject(o) {
    var ctor, prot;
    if (isObject(o) === false) return false;
    // If has modified constructor
    ctor = o.constructor;
    if (ctor === undefined) return true;
    // If has modified prototype
    prot = ctor.prototype;
    if (isObject(prot) === false) return false;
    // If constructor does not have an Object-specific method
    if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
    }
    // Most likely a plain Object
    return true;
}
;
}),
"[project]/node_modules/@udecode/plate-core/node_modules/nanoid/url-alphabet/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "urlAlphabet",
    ()=>urlAlphabet
]);
const urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
}),
"[project]/node_modules/@udecode/plate-core/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/* @ts-self-types="./index.d.ts" */ __turbopack_context__.s([
    "customAlphabet",
    ()=>customAlphabet,
    "customRandom",
    ()=>customRandom,
    "nanoid",
    ()=>nanoid,
    "random",
    ()=>random
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$nanoid$2f$url$2d$alphabet$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@udecode/plate-core/node_modules/nanoid/url-alphabet/index.js [app-client] (ecmascript)");
;
;
let random = (bytes)=>crypto.getRandomValues(new Uint8Array(bytes));
let customRandom = (alphabet, defaultSize, getRandom)=>{
    let mask = (2 << Math.log2(alphabet.length - 1)) - 1;
    let step = -~(1.6 * mask * defaultSize / alphabet.length);
    return (size = defaultSize)=>{
        let id = '';
        while(true){
            let bytes = getRandom(step);
            let j = step | 0;
            while(j--){
                id += alphabet[bytes[j] & mask] || '';
                if (id.length >= size) return id;
            }
        }
    };
};
let customAlphabet = (alphabet, size = 21)=>customRandom(alphabet, size | 0, random);
let nanoid = (size = 21)=>{
    let id = '';
    let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
    while(size--){
        id += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$nanoid$2f$url$2d$alphabet$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["urlAlphabet"][bytes[size] & 63];
    }
    return id;
};
}),
"[project]/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clsx",
    ()=>clsx,
    "default",
    ()=>__TURBOPACK__default__export__
]);
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}),
"[project]/node_modules/slate-hyperscript/dist/index.es.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createEditor",
    ()=>createEditor,
    "createHyperscript",
    ()=>createHyperscript,
    "createText",
    ()=>createText,
    "jsx",
    ()=>jsx
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-object/dist/is-plain-object.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/slate/dist/index.es.js [app-client] (ecmascript)");
;
;
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * A weak map to hold anchor tokens.
 */ var ANCHOR = new WeakMap();
/**
 * A weak map to hold focus tokens.
 */ var FOCUS = new WeakMap();
/**
 * All tokens inherit from a single constructor for `instanceof` checking.
 */ class Token {
}
/**
 * Anchor tokens represent the selection's anchor point.
 */ class AnchorToken extends Token {
    constructor(){
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        super();
        _defineProperty(this, "offset", void 0);
        _defineProperty(this, "path", void 0);
        var { offset, path } = props;
        this.offset = offset;
        this.path = path;
    }
}
/**
 * Focus tokens represent the selection's focus point.
 */ class FocusToken extends Token {
    constructor(){
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        super();
        _defineProperty(this, "offset", void 0);
        _defineProperty(this, "path", void 0);
        var { offset, path } = props;
        this.offset = offset;
        this.path = path;
    }
}
/**
 * Add an anchor token to the end of a text node.
 */ var addAnchorToken = (text, token)=>{
    var offset = text.text.length;
    ANCHOR.set(text, [
        offset,
        token
    ]);
};
/**
 * Get the offset if a text node has an associated anchor token.
 */ var getAnchorOffset = (text)=>{
    return ANCHOR.get(text);
};
/**
 * Add a focus token to the end of a text node.
 */ var addFocusToken = (text, token)=>{
    var offset = text.text.length;
    FOCUS.set(text, [
        offset,
        token
    ]);
};
/**
 * Get the offset if a text node has an associated focus token.
 */ var getFocusOffset = (text)=>{
    return FOCUS.get(text);
};
function ownKeys$1(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$1(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$1(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
/**
 * Resolve the descedants of a node by normalizing the children that can be
 * passed into a hyperscript creator function.
 */ var STRINGS = new WeakSet();
var resolveDescendants = (children)=>{
    var nodes = [];
    var addChild = (child)=>{
        if (child == null) {
            return;
        }
        var prev = nodes[nodes.length - 1];
        if (typeof child === 'string') {
            var text = {
                text: child
            };
            STRINGS.add(text);
            child = text;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(child)) {
            var c = child; // HACK: fix typescript complaining
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(prev) && STRINGS.has(prev) && STRINGS.has(c) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].equals(prev, c, {
                loose: true
            })) {
                prev.text += c.text;
            } else {
                nodes.push(c);
            }
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(child)) {
            nodes.push(child);
        } else if (child instanceof Token) {
            var n = nodes[nodes.length - 1];
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(n)) {
                addChild('');
                n = nodes[nodes.length - 1];
            }
            if (child instanceof AnchorToken) {
                addAnchorToken(n, child);
            } else if (child instanceof FocusToken) {
                addFocusToken(n, child);
            }
        } else {
            throw new Error("Unexpected hyperscript child object: ".concat(child));
        }
    };
    for (var child of children.flat(Infinity)){
        addChild(child);
    }
    return nodes;
};
/**
 * Create an anchor token.
 */ function createAnchor(tagName, attributes, children) {
    return new AnchorToken(attributes);
}
/**
 * Create an anchor and a focus token.
 */ function createCursor(tagName, attributes, children) {
    return [
        new AnchorToken(attributes),
        new FocusToken(attributes)
    ];
}
/**
 * Create an `Element` object.
 */ function createElement(tagName, attributes, children) {
    return _objectSpread$1(_objectSpread$1({}, attributes), {}, {
        children: resolveDescendants(children)
    });
}
/**
 * Create a focus token.
 */ function createFocus(tagName, attributes, children) {
    return new FocusToken(attributes);
}
/**
 * Create a fragment.
 */ function createFragment(tagName, attributes, children) {
    return resolveDescendants(children);
}
/**
 * Create a `Selection` object.
 */ function createSelection(tagName, attributes, children) {
    var anchor = children.find((c)=>c instanceof AnchorToken);
    var focus = children.find((c)=>c instanceof FocusToken);
    if (!anchor || anchor.offset == null || anchor.path == null) {
        throw new Error("The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.");
    }
    if (!focus || focus.offset == null || focus.path == null) {
        throw new Error("The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.");
    }
    return _objectSpread$1({
        anchor: {
            offset: anchor.offset,
            path: anchor.path
        },
        focus: {
            offset: focus.offset,
            path: focus.path
        }
    }, attributes);
}
/**
 * Create a `Text` object.
 */ function createText(tagName, attributes, children) {
    var nodes = resolveDescendants(children);
    if (nodes.length > 1) {
        throw new Error("The <text> hyperscript tag must only contain a single node's worth of children.");
    }
    var [node] = nodes;
    if (node == null) {
        node = {
            text: ''
        };
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(node)) {
        throw new Error("\n    The <text> hyperscript tag can only contain text content as children.");
    }
    // COMPAT: If they used the <text> tag we want to guarantee that it won't be
    // merge with other string children.
    STRINGS.delete(node);
    Object.assign(node, attributes);
    return node;
}
/**
 * Create a top-level `Editor` object.
 */ var createEditor = (makeEditor)=>(tagName, attributes, children)=>{
        var otherChildren = [];
        var selectionChild;
        for (var child of children){
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isRange(child)) {
                selectionChild = child;
            } else {
                otherChildren.push(child);
            }
        }
        var descendants = resolveDescendants(otherChildren);
        var selection = {};
        var editor = makeEditor();
        Object.assign(editor, attributes);
        editor.children = descendants;
        // Search the document's texts to see if any of them have tokens associated
        // that need incorporated into the selection.
        for (var [node, path] of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].texts(editor)){
            var anchor = getAnchorOffset(node);
            var focus = getFocusOffset(node);
            if (anchor != null) {
                var [offset] = anchor;
                selection.anchor = {
                    path,
                    offset
                };
            }
            if (focus != null) {
                var [_offset] = focus;
                selection.focus = {
                    path,
                    offset: _offset
                };
            }
        }
        if (selection.anchor && !selection.focus) {
            throw new Error("Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.");
        }
        if (!selection.anchor && selection.focus) {
            throw new Error("Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.");
        }
        if (selectionChild != null) {
            editor.selection = selectionChild;
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isRange(selection)) {
            editor.selection = selection;
        }
        return editor;
    };
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
/**
 * The default creators for Slate objects.
 */ var DEFAULT_CREATORS = {
    anchor: createAnchor,
    cursor: createCursor,
    editor: createEditor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEditor"]),
    element: createElement,
    focus: createFocus,
    fragment: createFragment,
    selection: createSelection,
    text: createText
};
/**
 * Create a Slate hyperscript function with `options`.
 */ var createHyperscript = function createHyperscript() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var { elements = {} } = options;
    var elementCreators = normalizeElements(elements);
    var creators = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CREATORS), elementCreators), options.creators);
    var jsx = createFactory(creators);
    return jsx;
};
/**
 * Create a Slate hyperscript function with `options`.
 */ var createFactory = (creators)=>{
    var jsx = function jsx(tagName, attributes) {
        for(var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            children[_key - 2] = arguments[_key];
        }
        var creator = creators[tagName];
        if (!creator) {
            throw new Error("No hyperscript creator found for tag: <".concat(tagName, ">"));
        }
        if (attributes == null) {
            attributes = {};
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$object$2f$dist$2f$is$2d$plain$2d$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(attributes)) {
            children = [
                attributes
            ].concat(children);
            attributes = {};
        }
        children = children.filter((child)=>Boolean(child)).flat();
        var ret = creator(tagName, attributes, children);
        return ret;
    };
    return jsx;
};
/**
 * Normalize a dictionary of element shorthands into creator functions.
 */ var normalizeElements = (elements)=>{
    var creators = {};
    var _loop = function _loop() {
        var props = elements[tagName];
        if (typeof props !== 'object') {
            throw new Error("Properties specified for a hyperscript shorthand should be an object, but for the custom element <".concat(tagName, ">  tag you passed: ").concat(props));
        }
        creators[tagName] = (tagName, attributes, children)=>{
            return createElement('element', _objectSpread(_objectSpread({}, props), attributes), children);
        };
    };
    for(var tagName in elements){
        _loop();
    }
    return creators;
};
/**
 * The default hyperscript factory that ships with Slate, without custom tags.
 */ var jsx = createHyperscript();
;
 //# sourceMappingURL=index.es.js.map
}),
"[project]/node_modules/dequal/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "dequal",
    ()=>dequal
]);
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
    for (key of iter.keys()){
        if (dequal(key, tar)) return key;
    }
}
function dequal(foo, bar) {
    var ctor, len, tmp;
    if (foo === bar) return true;
    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
        if (ctor === Date) return foo.getTime() === bar.getTime();
        if (ctor === RegExp) return foo.toString() === bar.toString();
        if (ctor === Array) {
            if ((len = foo.length) === bar.length) {
                while(len-- && dequal(foo[len], bar[len]));
            }
            return len === -1;
        }
        if (ctor === Set) {
            if (foo.size !== bar.size) {
                return false;
            }
            for (len of foo){
                tmp = len;
                if (tmp && typeof tmp === 'object') {
                    tmp = find(bar, tmp);
                    if (!tmp) return false;
                }
                if (!bar.has(tmp)) return false;
            }
            return true;
        }
        if (ctor === Map) {
            if (foo.size !== bar.size) {
                return false;
            }
            for (len of foo){
                tmp = len[0];
                if (tmp && typeof tmp === 'object') {
                    tmp = find(bar, tmp);
                    if (!tmp) return false;
                }
                if (!dequal(len[1], bar.get(tmp))) {
                    return false;
                }
            }
            return true;
        }
        if (ctor === ArrayBuffer) {
            foo = new Uint8Array(foo);
            bar = new Uint8Array(bar);
        } else if (ctor === DataView) {
            if ((len = foo.byteLength) === bar.byteLength) {
                while(len-- && foo.getInt8(len) === bar.getInt8(len));
            }
            return len === -1;
        }
        if (ArrayBuffer.isView(foo)) {
            if ((len = foo.byteLength) === bar.byteLength) {
                while(len-- && foo[len] === bar[len]);
            }
            return len === -1;
        }
        if (!ctor || typeof foo === 'object') {
            len = 0;
            for(ctor in foo){
                if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
                if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
            }
            return Object.keys(bar).length === len;
        }
    }
    return foo !== foo && bar !== bar;
}
}),
"[project]/node_modules/use-deep-compare/dist-web/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useDeepCompareCallback",
    ()=>useDeepCompareCallback,
    "useDeepCompareEffect",
    ()=>useDeepCompareEffect,
    "useDeepCompareImperativeHandle",
    ()=>useDeepCompareImperativeHandle,
    "useDeepCompareLayoutEffect",
    ()=>useDeepCompareLayoutEffect,
    "useDeepCompareMemo",
    ()=>useDeepCompareMemo
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dequal$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dequal/dist/index.mjs [app-client] (ecmascript)");
;
;
function useDeepCompareMemoize(dependencies) {
    const dependenciesRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(dependencies);
    const signalRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(0);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dequal$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dequal"])(dependencies, dependenciesRef.current)) {
        dependenciesRef.current = dependencies;
        signalRef.current += 1;
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "useDeepCompareMemoize.useMemo": ()=>dependenciesRef.current
    }["useDeepCompareMemoize.useMemo"], [
        signalRef.current
    ]);
}
/**
 * `useDeepCompareCallback` will return a memoized version of the callback that
 * only changes if one of the `dependencies` has changed.
 *
 * Warning: `useDeepCompareCallback` should not be used with dependencies that
 * are all primitive values. Use `React.useCallback` instead.
 *
 * @see {@link https://react.dev/reference/react/useCallback}
 */ function useDeepCompareCallback(callback, dependencies) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useCallback(callback, useDeepCompareMemoize(dependencies));
}
/**
 * Accepts a function that contains imperative, possibly effectful code.
 *
 * Warning: `useDeepCompareEffect` should not be used with dependencies that
 * are all primitive values. Use `React.useEffect` instead.
 *
 * @see {@link https://react.dev/reference/react/useEffect}
 */ function useDeepCompareEffect(effect, dependencies) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect(effect, useDeepCompareMemoize(dependencies));
}
/**
 * `useDeepCompareImperativeHandle` customizes the instance value that is exposed to parent components when using `ref`.
 * As always, imperative code using refs should be avoided in most cases.
 *
 * `useDeepCompareImperativeHandle` should be used with `React.forwardRef`.
 *
 * It's similar to `useImperativeHandle`, but uses deep comparison on the dependencies.
 *
 * Warning: `useDeepCompareImperativeHandle` should not be used with dependencies that
 * are all primitive values. Use `React.useImperativeHandle` instead.
 *
 * @see {@link https://react.dev/reference/react/useImperativeHandle}
 */ function useDeepCompareImperativeHandle(ref, init, dependencies) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useImperativeHandle(ref, init, useDeepCompareMemoize(dependencies));
}
/**
 * The signature is identical to `useDeepCompareEffect`, but it fires synchronously after all DOM mutations.
 * Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside
 * `useDeepCompareLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.
 *
 * Prefer the standard `useDeepCompareEffect` when possible to avoid blocking visual updates.
 *
 * If youre migrating code from a class component, `useDeepCompareLayoutEffect` fires in the same phase as
 * `componentDidMount` and `componentDidUpdate`.
 *
 * Warning: `useDeepCompareLayoutEffect` should not be used with dependencies that
 * are all primitive values. Use `React.useLayoutEffect` instead.
 *
 * @see {@link https://react.dev/reference/react/useLayoutEffect}
 */ function useDeepCompareLayoutEffect(effect, dependencies) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useLayoutEffect(effect, useDeepCompareMemoize(dependencies));
}
/**
 * `useDeepCompareMemo` will only recompute the memoized value when one of the
 * `dependencies` has changed.
 *
 * Warning: `useDeepCompareMemo` should not be used with dependencies that
 * are all primitive values. Use `React.useMemo` instead.
 *
 * @see {@link https://react.dev/reference/react/useMemo}
 */ function useDeepCompareMemo(factory, dependencies) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo(factory, useDeepCompareMemoize(dependencies));
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// packages/react/compose-refs/src/compose-refs.tsx
__turbopack_context__.s([
    "composeRefs",
    ()=>composeRefs,
    "useComposedRefs",
    ()=>useComposedRefs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
function setRef(ref, value) {
    if (typeof ref === "function") {
        return ref(value);
    } else if (ref !== null && ref !== void 0) {
        ref.current = value;
    }
}
function composeRefs(...refs) {
    return (node)=>{
        let hasCleanup = false;
        const cleanups = refs.map((ref)=>{
            const cleanup = setRef(ref, node);
            if (!hasCleanup && typeof cleanup == "function") {
                hasCleanup = true;
            }
            return cleanup;
        });
        if (hasCleanup) {
            return ()=>{
                for(let i = 0; i < cleanups.length; i++){
                    const cleanup = cleanups[i];
                    if (typeof cleanup == "function") {
                        cleanup();
                    } else {
                        setRef(refs[i], null);
                    }
                }
            };
        }
    };
}
function useComposedRefs(...refs) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"](composeRefs(...refs), refs);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@radix-ui/react-slot/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/slot.tsx
__turbopack_context__.s([
    "Root",
    ()=>Slot,
    "Slot",
    ()=>Slot,
    "Slottable",
    ()=>Slottable,
    "createSlot",
    ()=>createSlot,
    "createSlottable",
    ()=>createSlottable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
;
;
;
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var use = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[" use ".trim().toString()];
function isPromiseLike(value) {
    return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element) {
    return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
}
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
    const Slot2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.forwardRef((props, forwardedRef)=>{
        let { children, ...slotProps } = props;
        if (isLazyComponent(children) && typeof use === "function") {
            children = use(children._payload);
        }
        const childrenArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Children.toArray(children);
        const slottable = childrenArray.find(isSlottable);
        if (slottable) {
            const newElement = slottable.props.children;
            const newChildren = childrenArray.map((child)=>{
                if (child === slottable) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Children.count(newElement) > 1) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Children.only(null);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isValidElement(newElement) ? newElement.props.children : null;
                } else {
                    return child;
                }
            });
            return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
                ...slotProps,
                ref: forwardedRef,
                children: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isValidElement(newElement) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.cloneElement(newElement, void 0, newChildren) : null
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
            ...slotProps,
            ref: forwardedRef,
            children
        });
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
    const SlotClone = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.forwardRef((props, forwardedRef)=>{
        let { children, ...slotProps } = props;
        if (isLazyComponent(children) && typeof use === "function") {
            children = use(children._payload);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isValidElement(children)) {
            const childrenRef = getElementRef(children);
            const props2 = mergeProps(slotProps, children.props);
            if (children.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Fragment) {
                props2.ref = forwardedRef ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeRefs"])(forwardedRef, childrenRef) : childrenRef;
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.cloneElement(children, props2);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Children.count(children) > 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Children.only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
    const Slottable2 = ({ children })=>{
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
            children
        });
    };
    Slottable2.displayName = `${ownerName}.Slottable`;
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
    return Slottable2;
}
var Slottable = /* @__PURE__ */ createSlottable("Slottable");
function isSlottable(child) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
    const overrideProps = {
        ...childProps
    };
    for(const propName in childProps){
        const slotPropValue = slotProps[propName];
        const childPropValue = childProps[propName];
        const isHandler = /^on[A-Z]/.test(propName);
        if (isHandler) {
            if (slotPropValue && childPropValue) {
                overrideProps[propName] = (...args)=>{
                    const result = childPropValue(...args);
                    slotPropValue(...args);
                    return result;
                };
            } else if (slotPropValue) {
                overrideProps[propName] = slotPropValue;
            }
        } else if (propName === "style") {
            overrideProps[propName] = {
                ...slotPropValue,
                ...childPropValue
            };
        } else if (propName === "className") {
            overrideProps[propName] = [
                slotPropValue,
                childPropValue
            ].filter(Boolean).join(" ");
        }
    }
    return {
        ...slotProps,
        ...overrideProps
    };
}
function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.props.ref;
    }
    return element.props.ref || element.ref;
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@udecode/react-utils/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/createSlotComponent.tsx
__turbopack_context__.s([
    "Box",
    ()=>Box,
    "CAN_USE_DOM",
    ()=>CAN_USE_DOM,
    "DEFAULT_IGNORE_CLASS",
    ()=>DEFAULT_IGNORE_CLASS,
    "MemoizedChildren",
    ()=>MemoizedChildren,
    "PortalBody",
    ()=>PortalBody,
    "Text",
    ()=>Text,
    "composeEventHandlers",
    ()=>composeEventHandlers,
    "composeRefs",
    ()=>composeRefs,
    "createPrimitiveComponent",
    ()=>createPrimitiveComponent,
    "createPrimitiveElement",
    ()=>createPrimitiveElement,
    "createSlotComponent",
    ()=>createSlotComponent,
    "useComposedRef",
    ()=>useComposedRef,
    "useEffectOnce",
    ()=>useEffectOnce,
    "useIsomorphicLayoutEffect",
    ()=>useIsomorphicLayoutEffect,
    "useMemoOnce",
    ()=>useMemoOnce,
    "useMemoizedSelector",
    ()=>useMemoizedSelector,
    "useOnClickOutside",
    ()=>useOnClickOutside,
    "useStableFn",
    ()=>useStableFn,
    "useStableMemo",
    ()=>useStableMemo,
    "withProviders",
    ()=>withProviders,
    "withRef",
    ()=>withRef
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-slot/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@udecode/utils/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)");
;
;
var createSlotComponent = (element)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(({ as, asChild = false, ...props }, ref)=>{
        const Comp = asChild ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Slot"] : as || element;
        return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Comp, {
            ref,
            ...props
        });
    });
// src/Box.tsx
var Box = createSlotComponent("div");
;
var MemoizedChildren = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].memo(({ children })=>{
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, children);
});
;
;
var PortalBody = ({ children, element })=>{
    const container = element || typeof window !== "undefined" ? document.body : void 0;
    if (!container) return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, children);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createPortal(children, element || document.body);
};
// src/Text.tsx
var Text = createSlotComponent("span");
// src/composeEventHandlers.ts
var composeEventHandlers = (originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {})=>(event)=>{
        originalEventHandler?.(event);
        if (checkForDefaultPrevented === false || !event.defaultPrevented) {
            return ourEventHandler?.(event);
        }
    };
;
;
;
;
var setRef = (ref, value)=>{
    if (typeof ref === "function") {
        ref(value);
    } else if (ref !== null && ref !== void 0) {
        ref.current = value;
    }
};
var composeRefs = (...refs)=>(node)=>refs.forEach((ref)=>setRef(ref, node));
var useComposedRef = (...refs)=>{
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useCallback(composeRefs(...refs), refs);
};
// src/createPrimitiveComponent.tsx
var createPrimitiveComponent = (element)=>{
    const Comp = createSlotComponent(element);
    return ({ propsHook, stateHook } = {})=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(({ asChild, className: classNameProp, getClassName, options, state: stateProp, ...props }, ref)=>{
            const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(stateProp) ? stateProp : stateHook ? stateHook(options) : void 0;
            const { hidden, props: hookProps, ref: hookRef } = propsHook ? propsHook(state) : {
                hidden: false,
                props: {},
                ref: null
            };
            const _ref = useComposedRef(ref, hookRef);
            const className = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(hookProps?.className) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(classNameProp) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clsx"])(hookProps?.className, classNameProp) : void 0;
            const style = hookProps?.style || props.style ? {
                ...hookProps?.style,
                ...props.style
            } : void 0;
            if (!asChild && hidden) return null;
            return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Comp, {
                ref: _ref,
                asChild,
                ...hookProps,
                className,
                style,
                ...props,
                ...props.setProps?.(hookProps ?? {}) ?? {}
            });
        });
    };
};
;
function createPrimitiveElement(tag) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(function CreateComponent(props, ref) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(tag, {
            ...props,
            ref
        });
    });
}
;
function useEffectOnce(effect, deps) {
    const initialized = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(false);
    const prevDepsRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(deps);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "useEffectOnce.useEffect": ()=>{
            const depsChanged = deps.some({
                "useEffectOnce.useEffect.depsChanged": (dep, i)=>dep !== prevDepsRef.current[i]
            }["useEffectOnce.useEffect.depsChanged"]);
            if (!initialized.current || depsChanged) {
                initialized.current = true;
                prevDepsRef.current = deps;
                effect();
            }
        }
    }["useEffectOnce.useEffect"], deps);
}
;
var CAN_USE_DOM = typeof window !== "undefined" && window.document?.createElement !== void 0;
var useIsomorphicLayoutEffect = CAN_USE_DOM ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useLayoutEffect : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect;
;
function useMemoOnce(factory, deps) {
    const initialized = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(false);
    const prevDepsRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(deps);
    const memoizedValueRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(void 0);
    if (!initialized.current || deps.some((dep, i)=>dep !== prevDepsRef.current[i])) {
        initialized.current = true;
        prevDepsRef.current = deps;
        memoizedValueRef.current = factory();
    }
    return memoizedValueRef.current;
}
;
function useMemoizedSelector(selector, deps, equalityFn = (a, b)=>a === b) {
    const [memoizedValue, setMemoizedValue] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState({
        "useMemoizedSelector.useState": ()=>selector()
    }["useMemoizedSelector.useState"]);
    const previousValueRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(memoizedValue);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "useMemoizedSelector.useEffect": ()=>{
            const newValue = selector();
            if (!equalityFn(previousValueRef.current, newValue)) {
                setMemoizedValue(newValue);
                previousValueRef.current = newValue;
            }
        }
    }["useMemoizedSelector.useEffect"], deps);
    return memoizedValue;
}
;
var canUsePassiveEvents = ()=>{
    if (typeof window === "undefined" || typeof window.addEventListener !== "function") return false;
    let passive = false;
    const options = Object.defineProperty({}, "passive", {
        get () {
            passive = true;
        }
    });
    const noop = ()=>null;
    window.addEventListener("test", noop, options);
    window.removeEventListener("test", noop, options);
    return passive;
};
var DEFAULT_IGNORE_CLASS = "ignore-onclickoutside";
var checkClass = (el, cl)=>el.classList?.contains(cl);
var hasIgnoreClass = (e, ignoreClass)=>{
    let el = e.target || e;
    while(el){
        if (Array.isArray(ignoreClass)) {
            if (ignoreClass.some((c)=>checkClass(el, c))) return true;
        } else if (checkClass(el, ignoreClass)) {
            return true;
        }
        el = el.parentElement;
    }
    return false;
};
var clickedOnScrollbar = (e)=>document.documentElement.clientWidth <= e.clientX || document.documentElement.clientHeight <= e.clientY;
var getEventOptions = (type)=>type.includes("touch") && canUsePassiveEvents() ? {
        passive: true
    } : false;
var useOnClickOutside = (callback, { detectIFrame = true, disabled, eventTypes = [
    "mousedown",
    "touchstart"
], excludeScrollbar, ignoreClass = DEFAULT_IGNORE_CLASS, refs: refsOpt } = {})=>{
    const [refsState, setRefsState] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState([]);
    const callbackRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(callback);
    callbackRef.current = callback;
    const ref = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useCallback({
        "useOnClickOutside.useCallback[ref]": (el)=>setRefsState({
                "useOnClickOutside.useCallback[ref]": (prevState)=>[
                        ...prevState,
                        {
                            current: el
                        }
                    ]
            }["useOnClickOutside.useCallback[ref]"])
    }["useOnClickOutside.useCallback[ref]"], []);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "useOnClickOutside.useEffect": ()=>{
            if (!refsOpt?.length && refsState.length === 0) return;
            const getEls = {
                "useOnClickOutside.useEffect.getEls": ()=>{
                    const els = [];
                    (refsOpt || refsState).forEach({
                        "useOnClickOutside.useEffect.getEls": ({ current })=>current && els.push(current)
                    }["useOnClickOutside.useEffect.getEls"]);
                    return els;
                }
            }["useOnClickOutside.useEffect.getEls"];
            const handler = {
                "useOnClickOutside.useEffect.handler": (e)=>{
                    if (!hasIgnoreClass(e, ignoreClass) && !(excludeScrollbar && clickedOnScrollbar(e)) && getEls().every({
                        "useOnClickOutside.useEffect.handler": (el)=>!el.contains(e.target)
                    }["useOnClickOutside.useEffect.handler"])) callbackRef.current(e);
                }
            }["useOnClickOutside.useEffect.handler"];
            const blurHandler = {
                "useOnClickOutside.useEffect.blurHandler": (e)=>// On firefox the iframe becomes document.activeElement in the next event loop
                    setTimeout({
                        "useOnClickOutside.useEffect.blurHandler": ()=>{
                            const { activeElement } = document;
                            if (activeElement?.tagName === "IFRAME" && !hasIgnoreClass(activeElement, ignoreClass) && !getEls().includes(activeElement)) callbackRef.current(e);
                        }
                    }["useOnClickOutside.useEffect.blurHandler"], 0)
            }["useOnClickOutside.useEffect.blurHandler"];
            const removeEventListener = {
                "useOnClickOutside.useEffect.removeEventListener": ()=>{
                    eventTypes.forEach({
                        "useOnClickOutside.useEffect.removeEventListener": (type)=>document.removeEventListener(type, handler, getEventOptions(type))
                    }["useOnClickOutside.useEffect.removeEventListener"]);
                    if (detectIFrame) window.removeEventListener("blur", blurHandler);
                }
            }["useOnClickOutside.useEffect.removeEventListener"];
            if (disabled) {
                removeEventListener();
                return;
            }
            eventTypes.forEach({
                "useOnClickOutside.useEffect": (type)=>document.addEventListener(type, handler, getEventOptions(type))
            }["useOnClickOutside.useEffect"]);
            if (detectIFrame) window.addEventListener("blur", blurHandler);
            return ({
                "useOnClickOutside.useEffect": ()=>removeEventListener()
            })["useOnClickOutside.useEffect"];
        }
    }["useOnClickOutside.useEffect"], // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        refsState,
        ignoreClass,
        excludeScrollbar,
        disabled,
        detectIFrame,
        // eslint-disable-next-line react-hooks/exhaustive-deps
        JSON.stringify(eventTypes)
    ]);
    return ref;
};
;
var useStableFn = (fn, deps = [])=>{
    const fnRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(fn);
    fnRef.current = fn;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useCallback({
        "useStableFn.useCallback": (...args)=>fnRef.current(...args)
    }["useStableFn.useCallback"], deps);
};
;
var useStableMemo = (producer, deps)=>{
    const [value, setValue] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(producer);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useLayoutEffect({
        "useStableMemo.useLayoutEffect": ()=>{
            setValue(producer);
        }
    }["useStableMemo.useLayoutEffect"], deps);
    return value;
};
;
var withProviders = (...providers)=>(WrappedComponent)=>(props)=>providers.reduceRight((acc, prov)=>{
                let Provider = prov;
                if (Array.isArray(prov)) {
                    [Provider] = prov;
                    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Provider, {
                        ...prov[1]
                    }, acc);
                }
                return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Provider, null, acc);
            }, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(WrappedComponent, {
                ...props
            }));
;
function withRef(renderFunction) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(renderFunction);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/optics-ts/dist/mjs/internals.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Optic",
    ()=>Optic,
    "appendTo",
    ()=>appendTo,
    "at",
    ()=>at,
    "atKey",
    ()=>atKey,
    "chars",
    ()=>chars,
    "collect",
    ()=>collect,
    "compositionType",
    ()=>compositionType,
    "elems",
    ()=>elems,
    "eq",
    ()=>eq,
    "filter",
    ()=>filter,
    "find",
    ()=>find,
    "get",
    ()=>get,
    "guard",
    ()=>guard,
    "id",
    ()=>id,
    "indexed",
    ()=>indexed,
    "iso",
    ()=>iso,
    "lens",
    ()=>lens,
    "modify",
    ()=>modify,
    "nth",
    ()=>nth,
    "optic",
    ()=>optic,
    "optional",
    ()=>optional,
    "partsOf",
    ()=>partsOf,
    "pick",
    ()=>pick,
    "prependTo",
    ()=>prependTo,
    "preview",
    ()=>preview,
    "prop",
    ()=>prop,
    "remove",
    ()=>remove,
    "reread",
    ()=>reread,
    "rewrite",
    ()=>rewrite,
    "set",
    ()=>set,
    "to",
    ()=>to,
    "valueOr",
    ()=>valueOr,
    "when",
    ()=>when,
    "words",
    ()=>words
]);
var __rest = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
const id = (x)=>x;
const Left = (value)=>({
        _tag: 'Left',
        value
    });
const Right = (value)=>({
        _tag: 'Right',
        value
    });
const either = (mapLeft, mapRight, e)=>e._tag === 'Left' ? mapLeft(e.value) : mapRight(e.value);
const profunctorFn = {
    dimap: (f, g, fn)=>(x)=>g(fn(f(x))),
    first: (f)=>([x, y])=>[
                f(x),
                y
            ],
    right: (f)=>(e)=>e._tag === 'Left' ? e : Right(f(e.value)),
    wander: (f)=>(xs)=>xs.map(f)
};
const monoidFirst = {
    empty: ()=>undefined,
    foldMap: (f, xs)=>{
        for(let i = 0; i < xs.length; i++){
            const x = f(xs[i]);
            if (x != undefined) return x;
        }
        return undefined;
    }
};
const monoidArray = {
    empty: ()=>[],
    foldMap: (f, xs)=>{
        let acc = [];
        xs.forEach((x)=>{
            acc = acc.concat(f(x));
        });
        return acc;
    }
};
const profunctorConst = (monoid)=>({
        dimap: (f, _g, toF)=>(x)=>toF(f(x)),
        first: (toF)=>([x, _y])=>toF(x),
        right: (toF)=>(e)=>e._tag === 'Left' ? monoid.empty() : toF(e.value),
        wander: (toF)=>(xs)=>monoid.foldMap(toF, xs)
    });
const compositionType = {
    Equivalence: {
        Equivalence: 'Equivalence',
        Iso: 'Iso',
        Lens: 'Lens',
        Prism: 'Prism',
        Traversal: 'Traversal',
        Getter: 'Getter',
        AffineFold: 'AffineFold',
        Fold: 'Fold',
        Setter: 'Setter'
    },
    Iso: {
        Equivalence: 'Iso',
        Iso: 'Iso',
        Lens: 'Lens',
        Prism: 'Prism',
        Traversal: 'Traversal',
        Getter: 'Getter',
        AffineFold: 'AffineFold',
        Fold: 'Fold',
        Setter: 'Setter'
    },
    Lens: {
        Equivalence: 'Lens',
        Iso: 'Lens',
        Lens: 'Lens',
        Prism: 'Prism',
        Traversal: 'Traversal',
        Getter: 'Getter',
        AffineFold: 'AffineFold',
        Fold: 'Fold',
        Setter: 'Setter'
    },
    Prism: {
        Equivalence: 'Prism',
        Iso: 'Prism',
        Lens: 'Prism',
        Prism: 'Prism',
        Traversal: 'Traversal',
        Getter: 'AffineFold',
        AffineFold: 'AffineFold',
        Fold: 'Fold',
        Setter: 'Setter'
    },
    Traversal: {
        Equivalence: 'Traversal',
        Iso: 'Traversal',
        Lens: 'Traversal',
        Prism: 'Traversal',
        Traversal: 'Traversal',
        Getter: 'Fold',
        AffineFold: 'Fold',
        Fold: 'Fold',
        Setter: 'Setter'
    },
    Getter: {
        Equivalence: 'Getter',
        Iso: 'Getter',
        Lens: 'Getter',
        Prism: 'AffineFold',
        Traversal: 'Fold',
        Getter: 'Getter',
        AffineFold: 'AffineFold',
        Fold: 'Fold',
        Setter: undefined
    },
    AffineFold: {
        Equivalence: 'AffineFold',
        Iso: 'AffineFold',
        Lens: 'AffineFold',
        Prism: 'AffineFold',
        Traversal: 'Fold',
        Getter: 'AffineFold',
        AffineFold: 'AffineFold',
        Fold: 'Fold',
        Setter: undefined
    },
    Fold: {
        Equivalence: 'Fold',
        Iso: 'Fold',
        Lens: 'Fold',
        Prism: 'Fold',
        Traversal: 'Fold',
        Getter: 'Fold',
        AffineFold: 'Fold',
        Fold: 'Fold',
        Setter: undefined
    },
    Setter: {
        Equivalence: undefined,
        Iso: undefined,
        Lens: undefined,
        Prism: undefined,
        Traversal: undefined,
        Getter: undefined,
        AffineFold: undefined,
        Fold: undefined,
        Setter: undefined
    }
};
const withTag = (tag, optic)=>{
    const result = optic;
    result._tag = tag;
    return result;
};
const removable = (optic)=>{
    optic._removable = true;
    return optic;
};
function compose(optic1, optic2, optic3) {
    switch(arguments.length){
        case 2:
            {
                const next = (P, optic)=>optic1(P, optic2(P, optic));
                next._tag = compositionType[optic1._tag][optic2._tag];
                next._removable = optic2._removable || false;
                return next;
            }
        default:
            {
                const tag1 = compositionType[optic1._tag][optic2._tag];
                const next = (P, optic)=>optic1(P, optic2(P, optic3(P, optic)));
                next._tag = compositionType[tag1][optic3._tag];
                next._removable = optic3._removable || false;
                return next;
            }
    }
}
const eq = /* @__PURE__ */ withTag('Equivalence', (_P, optic)=>optic);
const iso = (there, back)=>withTag('Iso', (P, optic)=>P.dimap(there, back, optic));
const lens = (view, update)=>withTag('Lens', (P, optic)=>P.dimap((x)=>[
                view(x),
                x
            ], update, P.first(optic)));
const prism = (match, build)=>withTag('Prism', (P, optic)=>P.dimap(match, (x)=>either(id, build, x), P.right(optic)));
const elems = /* @__PURE__ */ withTag('Traversal', (P, optic)=>P.dimap(id, id, P.wander(optic)));
const to = (fn)=>withTag('Getter', (P, optic)=>P.dimap(fn, id, optic));
const modify = (optic, fn, source)=>optic(profunctorFn, fn)(source);
const set = (optic, value, source)=>optic(profunctorFn, ()=>value)(source);
const remove = (optic, source)=>set(optic, removeMe, source);
const get = (optic, source)=>optic(profunctorConst({}), id)(source);
const preview = (optic, source)=>optic(profunctorConst(monoidFirst), id)(source);
const collect = (optic, source)=>optic(profunctorConst(monoidArray), (x)=>[
            x
        ])(source);
const indexed = /* @__PURE__ */ iso((value)=>value.map((v, k)=>[
            k,
            v
        ]), (value)=>{
    const sorted = [
        ...value
    ].sort((a, b)=>a[0] - b[0]);
    const result = [];
    for(let i = 0; i < sorted.length; ++i){
        if (i === sorted.length - 1 || sorted[i][0] !== sorted[i + 1][0]) {
            result.push(sorted[i][1]);
        }
    }
    return result;
});
const prop = (key)=>lens((source)=>source[key], ([value, source])=>Object.assign(Object.assign({}, source), {
            [key]: value
        }));
const pick = (keys)=>lens((source)=>{
        const value = {};
        for (const key of keys){
            value[key] = source[key];
        }
        return value;
    }, ([value, source])=>{
        const result = Object.assign({}, source);
        for (const key of keys){
            delete result[key];
        }
        return Object.assign(result, value);
    });
const nth = (n)=>lens((value)=>value[n], ([value, source])=>{
        const result = source.slice();
        result[n] = value;
        return result;
    });
const fst = /* @__PURE__ */ nth(0);
const when = (pred)=>prism((x)=>pred(x) ? Right(x) : Left(x), id);
const noMatch = /* @__PURE__ */ Symbol('__no_match__');
const mustMatch = /* @__PURE__ */ when((source)=>source !== noMatch);
const removeMe = /* @__PURE__ */ Symbol('__remove_me__');
const at = (i)=>removable(compose(lens((source)=>0 <= i && i < source.length ? source[i] : noMatch, ([value, source])=>{
        if (value === noMatch) {
            return source;
        }
        if (value === removeMe) {
            if (typeof source === 'string') {
                return source.substring(0, i) + source.substring(i + 1);
            } else {
                return [
                    ...source.slice(0, i),
                    ...source.slice(i + 1)
                ];
            }
        }
        if (typeof source === 'string') {
            if (i === 0) {
                return value + source.substring(1);
            }
            if (i === source.length) {
                return source.substring(0, i - 1) + value;
            }
            return source.substring(0, i) + value + source.substring(i + 1);
        } else {
            const result = source.slice();
            result[i] = value;
            return result;
        }
    }), mustMatch));
const atKey = (key)=>removable(compose(lens((source)=>{
        const value = source[key];
        return value !== undefined ? value : noMatch;
    }, ([value, source])=>{
        if (value === noMatch) {
            return source;
        }
        if (value === removeMe) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const _a = source, _b = key, _ = _a[_b], rest = __rest(_a, [
                typeof _b === "symbol" ? _b : _b + ""
            ]);
            return rest;
        }
        return Object.assign(Object.assign({}, source), {
            [key]: value
        });
    }), mustMatch));
const optional = /* @__PURE__ */ prism((source)=>source === undefined ? Left(undefined) : Right(source), id);
const guard = (fn)=>prism((source)=>fn(source) ? Right(source) : Left(source), id);
const find = (predicate)=>removable(compose(lens((source)=>{
        const index = source.findIndex(predicate);
        if (index === -1) {
            return [
                noMatch,
                -1
            ];
        }
        return [
            source[index],
            index
        ];
    }, ([[value, index], source])=>{
        if (value === noMatch) {
            return source;
        }
        if (value === removeMe) {
            return [
                ...source.slice(0, index),
                ...source.slice(index + 1)
            ];
        }
        const result = source.slice();
        result[index] = value;
        return result;
    }), fst, mustMatch));
const filter = (predicate)=>compose(lens((source)=>{
        const indexes = source.map((item, index)=>predicate(item) ? index : null).filter((index)=>index != null);
        return [
            indexes.map((index)=>source[index]),
            indexes
        ];
    }, ([[values, indexes], source])=>{
        const sn = source.length, vn = values.length;
        let si = 0, ii = 0, vi = 0;
        const result = [];
        while(si < sn){
            if (indexes[ii] === si) {
                ++ii;
                if (vi < vn) {
                    result.push(values[vi]);
                    ++vi;
                }
            } else {
                result.push(source[si]);
            }
            ++si;
        }
        while(vi < vn){
            result.push(values[vi++]);
        }
        return result;
    }), fst);
const valueOr = (defaultValue)=>lens((source)=>source === undefined ? defaultValue : source, ([value, _source])=>value);
const partsOf = (traversal)=>compose(lens((source)=>{
        const value = collect(traversal, source);
        return [
            value,
            value.length
        ];
    }, ([[value, originalLength], source])=>{
        if (value.length !== originalLength) {
            throw new Error('cannot add/remove elements through partsOf');
        }
        let i = 0;
        return modify(traversal, ()=>value[i++], source);
    }), fst);
const reread = (fn)=>lens((source)=>fn(source), ([value, _])=>value);
const rewrite = (fn)=>lens((source)=>source, ([value, _])=>fn(value));
const prependTo = /* @__PURE__ */ lens((_source)=>undefined, ([value, source])=>{
    if (value === undefined) return source;
    return [
        value,
        ...source
    ];
});
const appendTo = /* @__PURE__ */ lens((_source)=>undefined, ([value, source])=>{
    if (value === undefined) return source;
    return [
        ...source,
        value
    ];
});
const chars = /* @__PURE__ */ compose(iso((s)=>s.split(''), (a)=>a.join('')), elems);
const words = /* @__PURE__ */ compose(iso((s)=>s.split(/\b/), (a)=>a.join('')), elems, when((s)=>!/\s+/.test(s)));
class Optic {
    constructor(_ref){
        this._ref = _ref;
    }
    get _tag() {
        return this._ref._tag;
    }
    get _removable() {
        return this._ref._removable;
    }
    compose(other) {
        return new Optic(compose(this._ref, other._ref));
    }
    iso(there, back) {
        return new Optic(compose(this._ref, iso(there, back)));
    }
    lens(view, set) {
        return new Optic(compose(this._ref, lens(view, ([value, source])=>set(source, value))));
    }
    indexed() {
        return new Optic(compose(this._ref, indexed));
    }
    prop(key) {
        return new Optic(compose(this._ref, prop(key)));
    }
    path(...keys) {
        if (keys.length === 1) {
            keys = keys[0].split('.');
        }
        return new Optic(keys.reduce((ref, key)=>compose(ref, prop(key)), this._ref));
    }
    pick(keys) {
        return new Optic(compose(this._ref, pick(keys)));
    }
    nth(n) {
        return new Optic(compose(this._ref, nth(n)));
    }
    filter(predicate) {
        return new Optic(compose(this._ref, filter(predicate)));
    }
    valueOr(defaultValue) {
        return new Optic(compose(this._ref, valueOr(defaultValue)));
    }
    partsOf(traversalOrFn) {
        const traversal = typeof traversalOrFn === 'function' ? traversalOrFn(optic) : traversalOrFn;
        return new Optic(compose(this._ref, partsOf(traversal._ref)));
    }
    reread(fn) {
        return new Optic(compose(this._ref, reread(fn)));
    }
    rewrite(fn) {
        return new Optic(compose(this._ref, rewrite(fn)));
    }
    optional() {
        return new Optic(compose(this._ref, optional));
    }
    guard_() {
        return (fn)=>this.guard(fn);
    }
    guard(fn) {
        return new Optic(compose(this._ref, guard(fn)));
    }
    at(i) {
        return new Optic(compose(this._ref, at(i)));
    }
    head() {
        return new Optic(compose(this._ref, at(0)));
    }
    index(i) {
        return new Optic(compose(this._ref, at(i)));
    }
    find(predicate) {
        return new Optic(compose(this._ref, find(predicate)));
    }
    elems() {
        return new Optic(compose(this._ref, elems));
    }
    to(fn) {
        return new Optic(compose(this._ref, to(fn)));
    }
    when(predicate) {
        return new Optic(compose(this._ref, when(predicate)));
    }
    chars() {
        return new Optic(compose(this._ref, chars));
    }
    words() {
        return new Optic(compose(this._ref, words));
    }
    prependTo() {
        return new Optic(compose(this._ref, prependTo));
    }
    appendTo() {
        return new Optic(compose(this._ref, appendTo));
    }
}
const optic = /* @__PURE__ */ new Optic(eq);
}),
"[project]/node_modules/optics-ts/dist/mjs/standalone/pipe.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/no-non-null-assertion, @typescript-eslint/ban-types */ __turbopack_context__.s([
    "pipe",
    ()=>pipe
]);
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi, ij) {
    switch(arguments.length){
        case 1:
            return a;
        case 2:
            return ab(a);
        case 3:
            return bc(ab(a));
        case 4:
            return cd(bc(ab(a)));
        case 5:
            return de(cd(bc(ab(a))));
        case 6:
            return ef(de(cd(bc(ab(a)))));
        case 7:
            return fg(ef(de(cd(bc(ab(a))))));
        case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        case 10:
            return ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))));
    }
    return;
}
}),
"[project]/node_modules/optics-ts/dist/mjs/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/adjacent-overload-signatures, @typescript-eslint/no-unused-vars */ // This file is generated, do not edit! See ../scripts/generate-index.ts
__turbopack_context__.s([
    "collect",
    ()=>collect,
    "compose",
    ()=>compose,
    "get",
    ()=>get,
    "modify",
    ()=>modify,
    "optic",
    ()=>optic,
    "optic_",
    ()=>optic_,
    "preview",
    ()=>preview,
    "remove",
    ()=>remove,
    "set",
    ()=>set
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/optics-ts/dist/mjs/internals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$standalone$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/optics-ts/dist/mjs/standalone/pipe.js [app-client] (ecmascript)");
;
function compose(optic1, optic2) {
    return optic1.compose(optic2);
}
function optic() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optic"];
}
function optic_() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optic"];
}
function get(optic) {
    return (source)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["get"](optic._ref, source);
}
function preview(optic) {
    return (source)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["preview"](optic._ref, source);
}
function collect(optic) {
    return (source)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collect"](optic._ref, source);
}
function modify(optic) {
    return (f)=>(source)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["modify"](optic._ref, f, source);
}
function set(optic) {
    return (value)=>(source)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"](optic._ref, value, source);
}
function remove(optic) {
    return (source)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["remove"](optic._ref, source);
}
;
}),
"[project]/node_modules/jotai-optics/dist/focusAtom.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */ __turbopack_context__.s([
    "focusAtom",
    ()=>focusAtom
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jotai/esm/vanilla.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/optics-ts/dist/mjs/index.js [app-client] (ecmascript) <locals>");
;
;
const getCached = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);
const cache1 = new WeakMap();
const memo2 = (create, dep1, dep2)=>{
    const cache2 = getCached(()=>new WeakMap(), cache1, dep1);
    return getCached(create, cache2, dep2);
};
const isFunction = (x)=>typeof x === 'function';
function focusAtom(baseAtom, callback) {
    return memo2(()=>{
        const focus = callback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["optic"]());
        const derivedAtom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jotai$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])((get)=>{
            const base = get(baseAtom);
            return base instanceof Promise ? base.then((v)=>getValueUsingOptic(focus, v)) : getValueUsingOptic(focus, base);
        }, (get, set, update)=>{
            const newValueProducer = isFunction(update) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["modify"](focus)(update) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["set"](focus)(update);
            const base = get(baseAtom);
            return set(baseAtom, base instanceof Promise ? base.then(newValueProducer) : newValueProducer(base));
        });
        return derivedAtom;
    }, baseAtom, callback);
}
const getValueUsingOptic = (focus, bigValue)=>{
    if (focus._tag === 'Traversal') {
        const values = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["collect"](focus)(bigValue);
        return values;
    }
    if (focus._tag === 'Prism') {
        const value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["preview"](focus)(bigValue);
        return value;
    }
    const value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$optics$2d$ts$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"](focus)(bigValue);
    return value;
};
}),
]);

//# sourceMappingURL=node_modules_9d70a98f._.js.map