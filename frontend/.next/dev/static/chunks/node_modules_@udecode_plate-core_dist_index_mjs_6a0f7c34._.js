(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@udecode/plate-core/dist/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// src/lib/editor/withSlate.ts
__turbopack_context__.s([
    "AUTO_SCROLL",
    ()=>AUTO_SCROLL,
    "AffinityPlugin",
    ()=>AffinityPlugin,
    "AstPlugin",
    ()=>AstPlugin,
    "BaseParagraphPlugin",
    ()=>BaseParagraphPlugin,
    "CARRIAGE_RETURN",
    ()=>CARRIAGE_RETURN,
    "DOMPlugin",
    ()=>DOMPlugin,
    "DebugPlugin",
    ()=>DebugPlugin,
    "ElementStatic",
    ()=>ElementStatic,
    "HistoryPlugin",
    ()=>HistoryPlugin,
    "Hotkeys",
    ()=>Hotkeys,
    "HtmlPlugin",
    ()=>HtmlPlugin,
    "LINE_FEED",
    ()=>LINE_FEED,
    "LeafStatic",
    ()=>LeafStatic,
    "LengthPlugin",
    ()=>LengthPlugin,
    "NO_BREAK_SPACE",
    ()=>NO_BREAK_SPACE,
    "NodeIdPlugin",
    ()=>NodeIdPlugin,
    "OverridePlugin",
    ()=>OverridePlugin,
    "ParserPlugin",
    ()=>ParserPlugin,
    "PlateError",
    ()=>PlateError,
    "PlateStatic",
    ()=>PlateStatic,
    "SPACE",
    ()=>SPACE,
    "SlateElement",
    ()=>SlateElement,
    "SlateExtensionPlugin",
    ()=>SlateExtensionPlugin,
    "SlateLeaf",
    ()=>SlateLeaf,
    "SlateText",
    ()=>SlateText,
    "TAB",
    ()=>TAB,
    "ZERO_WIDTH_SPACE",
    ()=>ZERO_WIDTH_SPACE,
    "applyDeepToNodes",
    ()=>applyDeepToNodes,
    "cleanHtmlBrElements",
    ()=>cleanHtmlBrElements,
    "cleanHtmlCrLf",
    ()=>cleanHtmlCrLf,
    "cleanHtmlEmptyElements",
    ()=>cleanHtmlEmptyElements,
    "cleanHtmlFontElements",
    ()=>cleanHtmlFontElements,
    "cleanHtmlLinkElements",
    ()=>cleanHtmlLinkElements,
    "cleanHtmlTextNodes",
    ()=>cleanHtmlTextNodes,
    "collapseString",
    ()=>collapseString,
    "collapseWhiteSpace",
    ()=>collapseWhiteSpace,
    "collapseWhiteSpaceChildren",
    ()=>collapseWhiteSpaceChildren,
    "collapseWhiteSpaceElement",
    ()=>collapseWhiteSpaceElement,
    "collapseWhiteSpaceNode",
    ()=>collapseWhiteSpaceNode,
    "collapseWhiteSpaceText",
    ()=>collapseWhiteSpaceText,
    "copyBlockMarksToSpanChild",
    ()=>copyBlockMarksToSpanChild,
    "createHotkey",
    ()=>createHotkey,
    "createSlateEditor",
    ()=>createSlateEditor,
    "createSlatePlugin",
    ()=>createSlatePlugin,
    "createStaticString",
    ()=>createStaticString,
    "createTSlatePlugin",
    ()=>createTSlatePlugin,
    "defaultsDeepToNodes",
    ()=>defaultsDeepToNodes,
    "deserializeHtml",
    ()=>deserializeHtml,
    "deserializeHtmlElement",
    ()=>deserializeHtmlElement,
    "deserializeHtmlNode",
    ()=>deserializeHtmlNode,
    "deserializeHtmlNodeChildren",
    ()=>deserializeHtmlNodeChildren,
    "endInlineFormattingContext",
    ()=>endInlineFormattingContext,
    "findHtmlElement",
    ()=>findHtmlElement,
    "getContainerTypes",
    ()=>getContainerTypes,
    "getCorePlugins",
    ()=>getCorePlugins,
    "getDataNodeProps",
    ()=>getDataNodeProps,
    "getEdgeNodes",
    ()=>getEdgeNodes,
    "getEditorDOMFromHtmlString",
    ()=>getEditorDOMFromHtmlString,
    "getEditorPlugin",
    ()=>getEditorPlugin,
    "getHtmlComments",
    ()=>getHtmlComments,
    "getInjectMatch",
    ()=>getInjectMatch,
    "getInjectedPlugins",
    ()=>getInjectedPlugins,
    "getKeyByType",
    ()=>getKeyByType,
    "getKeysByTypes",
    ()=>getKeysByTypes,
    "getMarkBoundaryAffinity",
    ()=>getMarkBoundaryAffinity,
    "getNodeDataAttributeKeys",
    ()=>getNodeDataAttributeKeys,
    "getNodeDataAttributes",
    ()=>getNodeDataAttributes,
    "getPluginByType",
    ()=>getPluginByType,
    "getPluginDataAttributes",
    ()=>getPluginDataAttributes,
    "getPluginKey",
    ()=>getPluginKey,
    "getPluginNodeProps",
    ()=>getPluginNodeProps,
    "getPluginType",
    ()=>getPluginType,
    "getPluginTypes",
    ()=>getPluginTypes,
    "getRenderNodeStaticProps",
    ()=>getRenderNodeStaticProps,
    "getSlateClass",
    ()=>getSlateClass,
    "getSlateElements",
    ()=>getSlateElements,
    "getSlatePlugin",
    ()=>getSlatePlugin,
    "htmlBodyToFragment",
    ()=>htmlBodyToFragment,
    "htmlBrToNewLine",
    ()=>htmlBrToNewLine,
    "htmlElementToElement",
    ()=>htmlElementToElement,
    "htmlElementToLeaf",
    ()=>htmlElementToLeaf,
    "htmlStringToDOMNode",
    ()=>htmlStringToDOMNode,
    "htmlTextNodeToString",
    ()=>htmlTextNodeToString,
    "inferWhiteSpaceRule",
    ()=>inferWhiteSpaceRule,
    "init",
    ()=>init,
    "inlineTagNames",
    ()=>inlineTagNames,
    "insertExitBreak",
    ()=>insertExitBreak,
    "isHtmlBlockElement",
    ()=>isHtmlBlockElement,
    "isHtmlComment",
    ()=>isHtmlComment,
    "isHtmlElement",
    ()=>isHtmlElement,
    "isHtmlFragmentHref",
    ()=>isHtmlFragmentHref,
    "isHtmlInlineElement",
    ()=>isHtmlInlineElement,
    "isHtmlTable",
    ()=>isHtmlTable,
    "isHtmlText",
    ()=>isHtmlText,
    "isLastNonEmptyTextOfInlineFormattingContext",
    ()=>isLastNonEmptyTextOfInlineFormattingContext,
    "isNodeAffinity",
    ()=>isNodeAffinity,
    "isNodesAffinity",
    ()=>isNodesAffinity,
    "isOlSymbol",
    ()=>isOlSymbol,
    "isSlateEditor",
    ()=>isSlateEditor,
    "isSlateElement",
    ()=>isSlateElement,
    "isSlateLeaf",
    ()=>isSlateLeaf,
    "isSlateNode",
    ()=>isSlateNode,
    "isSlatePluginElement",
    ()=>isSlatePluginElement,
    "isSlatePluginNode",
    ()=>isSlatePluginNode,
    "isSlateString",
    ()=>isSlateString,
    "isSlateText",
    ()=>isSlateText,
    "isSlateVoid",
    ()=>isSlateVoid,
    "isType",
    ()=>isType,
    "keyToDataAttribute",
    ()=>keyToDataAttribute,
    "mergeDeepToNodes",
    ()=>mergeDeepToNodes,
    "normalizeDescendantsToDocumentFragment",
    ()=>normalizeDescendantsToDocumentFragment,
    "omitPluginContext",
    ()=>omitPluginContext,
    "overridePluginsByKey",
    ()=>overridePluginsByKey,
    "parseHtmlDocument",
    ()=>parseHtmlDocument,
    "parseHtmlElement",
    ()=>parseHtmlElement,
    "pipeDecorate",
    ()=>pipeDecorate,
    "pipeDeserializeHtmlElement",
    ()=>pipeDeserializeHtmlElement,
    "pipeDeserializeHtmlLeaf",
    ()=>pipeDeserializeHtmlLeaf,
    "pipeInsertDataQuery",
    ()=>pipeInsertDataQuery,
    "pipeRenderElementStatic",
    ()=>pipeRenderElementStatic,
    "pipeRenderLeafStatic",
    ()=>pipeRenderLeafStatic,
    "pipeRenderTextStatic",
    ()=>pipeRenderTextStatic,
    "pluginDeserializeHtml",
    ()=>pluginDeserializeHtml,
    "pluginRenderElementStatic",
    ()=>pluginRenderElementStatic,
    "pluginRenderLeafStatic",
    ()=>pluginRenderLeafStatic,
    "pluginRenderTextStatic",
    ()=>pluginRenderTextStatic,
    "postCleanHtml",
    ()=>postCleanHtml,
    "preCleanHtml",
    ()=>preCleanHtml,
    "removeHtmlNodesBetweenComments",
    ()=>removeHtmlNodesBetweenComments,
    "removeHtmlSurroundings",
    ()=>removeHtmlSurroundings,
    "replaceTagName",
    ()=>replaceTagName,
    "resetBlock",
    ()=>resetBlock,
    "serializeHtml",
    ()=>serializeHtml,
    "setAffinitySelection",
    ()=>setAffinitySelection,
    "setValue",
    ()=>setValue,
    "someHtmlElement",
    ()=>someHtmlElement,
    "stripHtmlClassNames",
    ()=>stripHtmlClassNames,
    "stripSlateDataAttributes",
    ()=>stripSlateDataAttributes,
    "traverseHtmlComments",
    ()=>traverseHtmlComments,
    "traverseHtmlElements",
    ()=>traverseHtmlElements,
    "traverseHtmlNode",
    ()=>traverseHtmlNode,
    "traverseHtmlTexts",
    ()=>traverseHtmlTexts,
    "unwrapHtmlElement",
    ()=>unwrapHtmlElement,
    "upsertInlineFormattingContext",
    ()=>upsertInlineFormattingContext,
    "useNodeAttributes",
    ()=>useNodeAttributes,
    "withBreakRules",
    ()=>withBreakRules,
    "withDeleteRules",
    ()=>withDeleteRules,
    "withMergeRules",
    ()=>withMergeRules,
    "withNodeId",
    ()=>withNodeId,
    "withNormalizeRules",
    ()=>withNormalizeRules,
    "withOverrides",
    ()=>withOverrides,
    "withPlateHistory",
    ()=>withPlateHistory,
    "withScrolling",
    ()=>withScrolling,
    "withSlate",
    ()=>withSlate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@udecode/slate/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@udecode/plate-core/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@udecode/utils/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/merge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2d$x$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@udecode/plate-core/node_modules/zustand-x/dist/index.mjs [app-client] (ecmascript) <locals>");
// src/internal/utils/mergePlugins.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$mergeWith$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/mergeWith.js [app-client] (ecmascript)");
// src/lib/utils/defaultsDeepToNodes.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/defaults.js [app-client] (ecmascript)");
// src/lib/utils/getPluginNodeProps.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/pick.js [app-client] (ecmascript)");
// src/lib/static/pipeRenderElementStatic.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$kebabCase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/kebabCase.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@udecode/slate/node_modules/slate-dom/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$entities$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-entities/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$hotkey$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-hotkey/lib/index.js [app-client] (ecmascript)");
// src/lib/utils/isType.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$castArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/castArray.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isEqual.js [app-client] (ecmascript)");
// src/lib/plugins/dom/withScrolling.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isUndefined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omitBy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/omitBy.js [app-client] (ecmascript)");
// src/lib/plugins/html/utils/htmlBodyToFragment.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$hyperscript$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/slate-hyperscript/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$cloneDeep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/cloneDeep.js [app-client] (ecmascript)");
// src/lib/utils/overridePluginsByKey.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$defaultsDeep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/defaultsDeep.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
// src/internal/utils/isFunction.ts
function isFunction(value) {
    return typeof value === "function";
}
;
function mergePlugins(basePlugin, ...sourcePlugins) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$mergeWith$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, basePlugin, ...sourcePlugins, (objValue, srcValue, key)=>{
        if (Array.isArray(srcValue)) {
            return srcValue;
        }
        if (key === "options") {
            return {
                ...objValue,
                ...srcValue
            };
        }
    });
}
// src/lib/plugin/createSlatePlugin.ts
function createSlatePlugin(config = {}) {
    let baseConfig;
    let initialExtension;
    if (isFunction(config)) {
        baseConfig = {
            key: ""
        };
        initialExtension = (editor)=>config(editor);
    } else {
        baseConfig = config;
    }
    const key = baseConfig.key ?? "";
    const plugin = mergePlugins({
        key,
        __apiExtensions: [],
        __configuration: null,
        __extensions: initialExtension ? [
            initialExtension
        ] : [],
        __selectorExtensions: [],
        api: {},
        dependencies: [],
        editor: {},
        handlers: {},
        inject: {},
        node: {
            type: key
        },
        options: {},
        override: {},
        parser: {},
        parsers: {},
        plugins: [],
        priority: 100,
        render: {},
        rules: {},
        shortcuts: {},
        transforms: {}
    }, config);
    if (plugin.node.isLeaf && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(plugin.node.isDecoration)) {
        plugin.node.isDecoration = true;
    }
    plugin.configure = (config2)=>{
        const newPlugin = {
            ...plugin
        };
        newPlugin.__configuration = (ctx)=>isFunction(config2) ? config2(ctx) : config2;
        return createSlatePlugin(newPlugin);
    };
    plugin.configurePlugin = (p, config2)=>{
        const newPlugin = {
            ...plugin
        };
        const configureNestedPlugin = (plugins2)=>{
            let found = false;
            const updatedPlugins = plugins2.map((nestedPlugin)=>{
                if (nestedPlugin.key === p.key) {
                    found = true;
                    return createSlatePlugin({
                        ...nestedPlugin,
                        __configuration: (ctx)=>isFunction(config2) ? config2(ctx) : config2
                    });
                }
                if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {
                    const result2 = configureNestedPlugin(nestedPlugin.plugins);
                    if (result2.found) {
                        found = true;
                        return {
                            ...nestedPlugin,
                            plugins: result2.plugins
                        };
                    }
                }
                return nestedPlugin;
            });
            return {
                found,
                plugins: updatedPlugins
            };
        };
        const result = configureNestedPlugin(newPlugin.plugins);
        newPlugin.plugins = result.plugins;
        return createSlatePlugin(newPlugin);
    };
    plugin.extendEditorApi = (extension)=>{
        const newPlugin = {
            ...plugin
        };
        newPlugin.__apiExtensions = [
            ...newPlugin.__apiExtensions,
            {
                extension,
                isPluginSpecific: false
            }
        ];
        return createSlatePlugin(newPlugin);
    };
    plugin.extendSelectors = (extension)=>{
        const newPlugin = {
            ...plugin
        };
        newPlugin.__selectorExtensions = [
            ...newPlugin.__selectorExtensions,
            extension
        ];
        return createSlatePlugin(newPlugin);
    };
    plugin.extendApi = (extension)=>{
        const newPlugin = {
            ...plugin
        };
        newPlugin.__apiExtensions = [
            ...newPlugin.__apiExtensions,
            {
                extension,
                isPluginSpecific: true
            }
        ];
        return createSlatePlugin(newPlugin);
    };
    plugin.extendEditorTransforms = (extension)=>{
        const newPlugin = {
            ...plugin
        };
        newPlugin.__apiExtensions = [
            ...newPlugin.__apiExtensions,
            {
                extension,
                isPluginSpecific: false,
                isTransform: true
            }
        ];
        return createSlatePlugin(newPlugin);
    };
    plugin.extendTransforms = (extension)=>{
        const newPlugin = {
            ...plugin
        };
        newPlugin.__apiExtensions = [
            ...newPlugin.__apiExtensions,
            {
                extension,
                isPluginSpecific: true,
                isTransform: true
            }
        ];
        return createSlatePlugin(newPlugin);
    };
    plugin.overrideEditor = (extension)=>{
        const newPlugin = {
            ...plugin
        };
        newPlugin.__apiExtensions = [
            ...newPlugin.__apiExtensions,
            {
                extension,
                isOverride: true,
                isPluginSpecific: false,
                isTransform: true
            }
        ];
        return createSlatePlugin(newPlugin);
    };
    plugin.extend = (extendConfig)=>{
        let newPlugin = {
            ...plugin
        };
        if (isFunction(extendConfig)) {
            newPlugin.__extensions = [
                ...newPlugin.__extensions,
                extendConfig
            ];
        } else {
            newPlugin = mergePlugins(newPlugin, extendConfig);
        }
        return createSlatePlugin(newPlugin);
    };
    plugin.clone = ()=>mergePlugins(plugin);
    plugin.extendPlugin = (p, extendConfig)=>{
        const newPlugin = {
            ...plugin
        };
        const extendNestedPlugin = (plugins2)=>{
            let found = false;
            const updatedPlugins = plugins2.map((nestedPlugin)=>{
                if (nestedPlugin.key === p.key) {
                    found = true;
                    return createSlatePlugin({
                        ...nestedPlugin,
                        __extensions: [
                            ...nestedPlugin.__extensions,
                            (ctx)=>isFunction(extendConfig) ? extendConfig(ctx) : extendConfig
                        ]
                    });
                }
                if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {
                    const result2 = extendNestedPlugin(nestedPlugin.plugins);
                    if (result2.found) {
                        found = true;
                        return {
                            ...nestedPlugin,
                            plugins: result2.plugins
                        };
                    }
                }
                return nestedPlugin;
            });
            return {
                found,
                plugins: updatedPlugins
            };
        };
        const result = extendNestedPlugin(newPlugin.plugins);
        newPlugin.plugins = result.plugins;
        if (!result.found) {
            newPlugin.plugins.push(createSlatePlugin({
                key: p.key,
                __extensions: [
                    (ctx)=>isFunction(extendConfig) ? extendConfig(ctx) : extendConfig
                ]
            }));
        }
        return createSlatePlugin(newPlugin);
    };
    plugin.withComponent = (component)=>{
        return plugin.extend({
            node: {
                component
            },
            render: {
                node: component
            }
        });
    };
    return plugin;
}
function createTSlatePlugin(config = {}) {
    return createSlatePlugin(config);
}
// src/lib/plugin/getEditorPlugin.ts
function getEditorPlugin(editor, p) {
    const plugin = editor.getPlugin(p);
    return {
        api: editor.api,
        editor,
        plugin,
        setOption: (keyOrOptions, value)=>editor.setOption(plugin, keyOrOptions, value),
        setOptions: (options)=>editor.setOptions(plugin, options),
        tf: editor.transforms,
        type: plugin.node.type,
        getOption: (key, ...args)=>editor.getOption(plugin, key, ...args),
        getOptions: ()=>editor.getOptions(plugin)
    };
}
;
var resolvePlugin = (editor, _plugin)=>{
    let plugin = mergePlugins({}, _plugin);
    plugin.__resolved = true;
    if (plugin.__configuration) {
        const configResult = plugin.__configuration(getEditorPlugin(editor, plugin));
        plugin = mergePlugins(plugin, configResult);
        delete plugin.__configuration;
    }
    if (plugin.__extensions && plugin.__extensions.length > 0) {
        plugin.__extensions.forEach((extension)=>{
            plugin = mergePlugins(plugin, extension(getEditorPlugin(editor, plugin)));
        });
        plugin.__extensions = [];
    }
    const targetPluginToInject = plugin.inject?.targetPluginToInject;
    const targetPlugins = plugin.inject?.targetPlugins;
    if (targetPluginToInject && targetPlugins && targetPlugins.length > 0) {
        plugin.inject = plugin.inject || {};
        plugin.inject.plugins = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, plugin.inject.plugins, Object.fromEntries(targetPlugins.map((targetPlugin)=>{
            const injectedPlugin = targetPluginToInject({
                ...getEditorPlugin(editor, plugin),
                targetPlugin
            });
            return [
                targetPlugin,
                injectedPlugin
            ];
        })));
    }
    if (plugin.node?.component) {
        plugin.render.node = plugin.node.component;
    }
    if (plugin.render?.node) {
        plugin.node.component = plugin.render.node;
    }
    validatePlugin(editor, plugin);
    return plugin;
};
var validatePlugin = (editor, plugin)=>{
    if (!plugin.__extensions) {
        editor.api.debug.error(`Invalid plugin '${plugin.key}', you should use createSlatePlugin.`, "USE_CREATE_PLUGIN");
    }
    if (plugin.node.isElement && plugin.node.isLeaf) {
        editor.api.debug.error(`Plugin ${plugin.key} cannot be both an element and a leaf.`, "PLUGIN_NODE_TYPE");
    }
};
// src/lib/plugin/getSlatePlugin.ts
function getSlatePlugin(editor, p) {
    let plugin = p;
    const editorPlugin = editor.plugins[p.key];
    if (!editorPlugin) {
        if (!plugin.node) {
            plugin = createSlatePlugin(plugin);
        }
        return plugin.__resolved ? plugin : resolvePlugin(editor, plugin);
    }
    return editorPlugin;
}
function getPluginType(editor, key) {
    const p = editor.getPlugin({
        key
    });
    return p.node.type ?? p.key ?? "";
}
var getPluginTypes = (editor, keys)=>keys.map((key)=>editor.getType(key));
var getPluginKey = (editor, type)=>editor.meta.pluginCache.node.types[type];
var getPluginByType = (editor, type)=>{
    const key = getPluginKey(editor, type);
    if (!key) return null;
    return editor.getPlugin({
        key
    });
};
var getContainerTypes = (editor)=>{
    return getPluginTypes(editor, editor.meta.pluginCache.node.isContainer);
};
// src/internal/plugin/resolvePlugins.ts
var resolvePlugins = (editor, plugins2 = [])=>{
    editor.plugins = {};
    editor.meta.pluginList = [];
    editor.meta.shortcuts = {};
    editor.meta.components = {};
    editor.meta.pluginCache = {
        decorate: [],
        handlers: {
            onChange: []
        },
        inject: {
            nodeProps: []
        },
        node: {
            isContainer: [],
            isElement: [],
            isInline: [],
            isLeaf: [],
            isMarkableVoid: [],
            isNotSelectable: [],
            isStrictSiblings: [],
            isVoid: [],
            types: {}
        },
        normalizeInitialValue: [],
        render: {
            aboveEditable: [],
            aboveNodes: [],
            aboveSlate: [],
            afterContainer: [],
            afterEditable: [],
            beforeContainer: [],
            beforeEditable: [],
            belowNodes: [],
            belowRootNodes: []
        },
        rules: {
            match: []
        },
        useHooks: []
    };
    const resolvedPlugins = resolveAndSortPlugins(editor, plugins2);
    applyPluginsToEditor(editor, resolvedPlugins);
    resolvePluginOverrides(editor);
    resolvePluginStores(editor);
    editor.meta.pluginList.forEach((plugin)=>{
        if (plugin.extendEditor) {
            editor = plugin.extendEditor(getEditorPlugin(editor, plugin));
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["syncLegacyMethods"])(editor);
        }
        resolvePluginMethods(editor, plugin);
        if (plugin.node?.isContainer) {
            editor.meta.pluginCache.node.isContainer.push(plugin.key);
        }
        editor.meta.pluginCache.node.types[plugin.node.type] = plugin.key;
        if (plugin.inject?.nodeProps) {
            editor.meta.pluginCache.inject.nodeProps.push(plugin.key);
        }
        if (plugin.render?.node) {
            editor.meta.components[plugin.key] = plugin.render.node;
        }
        if (plugin.node?.isLeaf) {
            editor.meta.pluginCache.node.isLeaf.push(plugin.key);
        }
        if (plugin.node?.isElement) {
            editor.meta.pluginCache.node.isElement.push(plugin.key);
        }
        if (plugin.node?.isInline) {
            editor.meta.pluginCache.node.isInline.push(plugin.key);
        }
        if (plugin.node?.isVoid) {
            editor.meta.pluginCache.node.isVoid.push(plugin.key);
        }
        if (plugin.node?.isMarkableVoid) {
            editor.meta.pluginCache.node.isMarkableVoid.push(plugin.key);
        }
        if (plugin.node?.isStrictSiblings) {
            editor.meta.pluginCache.node.isStrictSiblings.push(plugin.key);
        }
        if (plugin.node?.isSelectable === false) {
            editor.meta.pluginCache.node.isNotSelectable.push(plugin.key);
        }
        if (plugin.render.aboveEditable) {
            editor.meta.pluginCache.render.aboveEditable.push(plugin.key);
        }
        if (plugin.render.aboveSlate) {
            editor.meta.pluginCache.render.aboveSlate.push(plugin.key);
        }
        if (plugin.render.afterEditable) {
            editor.meta.pluginCache.render.afterEditable.push(plugin.key);
        }
        if (plugin.render.beforeEditable) {
            editor.meta.pluginCache.render.beforeEditable.push(plugin.key);
        }
        if (plugin.rules?.match) {
            editor.meta.pluginCache.rules.match.push(plugin.key);
        }
        if (plugin.render.afterContainer) {
            editor.meta.pluginCache.render.afterContainer.push(plugin.key);
        }
        if (plugin.render.beforeContainer) {
            editor.meta.pluginCache.render.beforeContainer.push(plugin.key);
        }
        if (plugin.render.belowRootNodes) {
            editor.meta.pluginCache.render.belowRootNodes.push(plugin.key);
        }
        if (plugin.normalizeInitialValue) {
            editor.meta.pluginCache.normalizeInitialValue.push(plugin.key);
        }
        if (plugin.decorate) {
            editor.meta.pluginCache.decorate.push(plugin.key);
        }
        if (plugin.render.aboveNodes) {
            editor.meta.pluginCache.render.aboveNodes.push(plugin.key);
        }
        if (plugin.render.belowNodes) {
            editor.meta.pluginCache.render.belowNodes.push(plugin.key);
        }
        if (plugin.useHooks) {
            editor.meta.pluginCache.useHooks.push(plugin.key);
        }
        if (plugin.handlers?.onChange) {
            editor.meta.pluginCache.handlers.onChange.push(plugin.key);
        }
    });
    resolvePluginShortcuts(editor);
    return editor;
};
var resolvePluginStores = (editor)=>{
    editor.meta.pluginList.forEach((plugin)=>{
        let store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$zustand$2d$x$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createZustandStore"])(plugin.options, {
            mutative: true,
            name: plugin.key
        });
        if (plugin.__selectorExtensions && plugin.__selectorExtensions.length > 0) {
            plugin.__selectorExtensions.forEach((extension)=>{
                const extendedOptions = extension(getEditorPlugin(editor, plugin));
                store = store.extendSelectors(()=>extendedOptions);
            });
        }
        plugin.optionsStore = store;
    });
};
var resolvePluginMethods = (editor, plugin)=>{
    Object.entries(plugin.api).forEach(([apiKey, apiFunction])=>{
        editor.api[apiKey] = apiFunction;
    });
    if (plugin.__apiExtensions && plugin.__apiExtensions.length > 0) {
        plugin.__apiExtensions.forEach(({ extension, isOverride, isPluginSpecific, isTransform })=>{
            const newExtensions = extension(getEditorPlugin(editor, plugin));
            if (isOverride) {
                if (newExtensions.api) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(editor.api, newExtensions.api);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(plugin.api, newExtensions.api);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assignLegacyApi"])(editor, editor.api);
                }
                if (newExtensions.transforms) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(editor.transforms, newExtensions.transforms);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(plugin.transforms, newExtensions.transforms);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assignLegacyTransforms"])(editor, newExtensions.transforms);
                }
            } else if (isTransform) {
                if (isPluginSpecific) {
                    if (!editor.transforms[plugin.key]) {
                        editor.transforms[plugin.key] = {};
                    }
                    if (!plugin.transforms[plugin.key]) {
                        plugin.transforms[plugin.key] = {};
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(editor.transforms[plugin.key], newExtensions);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(plugin.transforms[plugin.key], newExtensions);
                } else {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(editor.transforms, newExtensions);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(plugin.transforms, newExtensions);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assignLegacyTransforms"])(editor, newExtensions);
                }
            } else {
                if (isPluginSpecific) {
                    if (!editor.api[plugin.key]) {
                        editor.api[plugin.key] = {};
                    }
                    if (!plugin.api[plugin.key]) {
                        plugin.api[plugin.key] = {};
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(editor.api[plugin.key], newExtensions);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(plugin.api[plugin.key], newExtensions);
                } else {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(editor.api, newExtensions);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(plugin.api, newExtensions);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assignLegacyApi"])(editor, editor.api);
                }
            }
        });
        delete plugin.__apiExtensions;
    }
};
var resolvePluginShortcuts = (editor)=>{
    editor.meta.shortcuts = {};
    editor.meta.pluginList.forEach((plugin)=>{
        Object.entries(plugin.shortcuts).forEach(([originalKey, hotkey])=>{
            const namespacedKey = `${plugin.key}.${originalKey}`;
            if (hotkey === null) {
                delete editor.meta.shortcuts[namespacedKey];
            } else if (hotkey && typeof hotkey === "object") {
                const resolvedHotkey = {
                    ...hotkey
                };
                if (!resolvedHotkey.handler) {
                    const pluginSpecificTransforms = plugin.transforms?.[plugin.key];
                    const pluginSpecificApi = plugin.api?.[plugin.key];
                    if (pluginSpecificTransforms?.[originalKey]) {
                        resolvedHotkey.handler = ()=>{
                            return pluginSpecificTransforms[originalKey]();
                        };
                    } else if (pluginSpecificApi?.[originalKey]) {
                        resolvedHotkey.handler = ()=>{
                            return pluginSpecificApi[originalKey]();
                        };
                    }
                }
                resolvedHotkey.priority = resolvedHotkey.priority ?? plugin.priority;
                editor.meta.shortcuts[namespacedKey] = resolvedHotkey;
            }
        });
    });
};
var flattenAndResolvePlugins = (editor, plugins2)=>{
    const pluginMap = /* @__PURE__ */ new Map();
    const processPlugin = (plugin)=>{
        const resolvedPlugin = resolvePlugin(editor, plugin);
        if (resolvedPlugin.key) {
            const existingPlugin = pluginMap.get(resolvedPlugin.key);
            if (existingPlugin) {
                pluginMap.set(resolvedPlugin.key, mergePlugins(existingPlugin, resolvedPlugin));
            } else {
                pluginMap.set(resolvedPlugin.key, resolvedPlugin);
            }
        } else {}
        if (resolvedPlugin.plugins && resolvedPlugin.plugins.length > 0) {
            resolvedPlugin.plugins.forEach(processPlugin);
        }
    };
    plugins2.forEach(processPlugin);
    return pluginMap;
};
var resolveAndSortPlugins = (editor, plugins2)=>{
    const pluginMap = flattenAndResolvePlugins(editor, plugins2);
    const enabledPlugins = Array.from(pluginMap.values()).filter((plugin)=>plugin.enabled !== false);
    enabledPlugins.sort((a, b)=>b.priority - a.priority);
    const orderedPlugins = [];
    const visited = /* @__PURE__ */ new Set();
    const visit = (plugin)=>{
        if (visited.has(plugin.key)) return;
        visited.add(plugin.key);
        plugin.dependencies?.forEach((depKey)=>{
            const depPlugin = pluginMap.get(depKey);
            if (depPlugin) {
                visit(depPlugin);
            } else {
                editor.api.debug.warn(`Plugin "${plugin.key}" depends on missing plugin "${depKey}"`, "PLUGIN_DEPENDENCY_MISSING");
            }
        });
        orderedPlugins.push(plugin);
    };
    enabledPlugins.forEach(visit);
    return orderedPlugins;
};
var applyPluginsToEditor = (editor, plugins2)=>{
    editor.meta.pluginList = plugins2;
    editor.plugins = Object.fromEntries(plugins2.map((plugin)=>[
            plugin.key,
            plugin
        ]));
};
var resolvePluginOverrides = (editor)=>{
    const applyOverrides = (plugins2)=>{
        let overriddenPlugins = [
            ...plugins2
        ];
        const enabledOverrides = {};
        const componentOverrides = {};
        const pluginOverrides = {};
        for (const plugin of plugins2){
            if (plugin.override.enabled) {
                Object.assign(enabledOverrides, plugin.override.enabled);
            }
            if (plugin.override.components) {
                Object.entries(plugin.override.components).forEach(([key, component])=>{
                    if (!componentOverrides[key] || plugin.priority > componentOverrides[key].priority) {
                        componentOverrides[key] = {
                            component,
                            priority: plugin.priority
                        };
                    }
                });
            }
            if (plugin.override.plugins) {
                Object.entries(plugin.override.plugins).forEach(([key, value])=>{
                    pluginOverrides[key] = mergePlugins(pluginOverrides[key], value);
                    if (value.enabled !== void 0) {
                        enabledOverrides[key] = value.enabled;
                    }
                });
            }
        }
        overriddenPlugins = overriddenPlugins.map((p)=>{
            let updatedPlugin = {
                ...p
            };
            if (pluginOverrides[p.key]) {
                updatedPlugin = mergePlugins(updatedPlugin, pluginOverrides[p.key]);
            }
            if (componentOverrides[p.key] && (!p.render.node && !p.node.component || componentOverrides[p.key].priority > p.priority)) {
                updatedPlugin.render.node = componentOverrides[p.key].component;
                updatedPlugin.node.component = componentOverrides[p.key].component;
            }
            const enabled = enabledOverrides[p.key] ?? updatedPlugin.enabled;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(enabled)) {
                updatedPlugin.enabled = enabled;
            }
            return updatedPlugin;
        });
        return overriddenPlugins.filter((p)=>p.enabled !== false).map((plugin)=>({
                ...plugin,
                plugins: applyOverrides(plugin.plugins || [])
            }));
    };
    applyPluginsToEditor;
    editor.meta.pluginList = applyOverrides(editor.meta.pluginList);
    editor.plugins = Object.fromEntries(editor.meta.pluginList.map((plugin)=>[
            plugin.key,
            plugin
        ]));
};
// src/lib/plugins/AstPlugin.ts
var AstPlugin = createSlatePlugin({
    key: "ast",
    parser: {
        format: "application/x-slate-fragment",
        deserialize: ({ data })=>{
            const decoded = decodeURIComponent(window.atob(data));
            let parsed;
            try {
                parsed = JSON.parse(decoded);
            } catch  {}
            return parsed;
        }
    }
});
;
var withPlateHistory = ({ editor })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["withHistory"])(editor);
var HistoryPlugin = createSlatePlugin({
    key: "history",
    extendEditor: withPlateHistory
});
// src/lib/plugins/paragraph/BaseParagraphPlugin.ts
var BaseParagraphPlugin = createSlatePlugin({
    key: "p",
    node: {
        isElement: true
    },
    parsers: {
        html: {
            deserializer: {
                rules: [
                    {
                        validNodeName: "P"
                    }
                ],
                query: ({ element })=>element.style.fontFamily !== "Consolas"
            }
        }
    },
    rules: {
        merge: {
            removeEmpty: true
        }
    }
});
;
var withBreakRules = (ctx)=>{
    const { editor, tf: { insertBreak } } = ctx;
    const checkMatchRulesOverride = (rule, blockNode, blockPath)=>{
        const matchRulesKeys = editor.meta.pluginCache.rules.match;
        for (const key of matchRulesKeys){
            const overridePlugin = editor.getPlugin({
                key
            });
            if (overridePlugin.rules?.break && overridePlugin.rules?.match?.({
                ...ctx,
                node: blockNode,
                path: blockPath,
                rule
            })) {
                return overridePlugin.rules.break;
            }
        }
        return null;
    };
    const executeBreakAction = (action, blockPath)=>{
        if (action === "reset") {
            editor.tf.resetBlock({
                at: blockPath
            });
            return true;
        }
        if (action === "exit") {
            editor.tf.insertExitBreak();
            return true;
        }
        if (action === "deleteExit") {
            editor.tf.deleteBackward("character");
            editor.tf.insertExitBreak();
            return true;
        }
        if (action === "lineBreak") {
            editor.tf.insertSoftBreak();
            return true;
        }
        return false;
    };
    return {
        transforms: {
            insertBreak () {
                if (editor.selection && editor.api.isCollapsed()) {
                    const block = editor.api.block();
                    if (block) {
                        const [blockNode, blockPath] = block;
                        const plugin = getPluginByType(editor, blockNode.type);
                        const breakRules = plugin?.rules.break;
                        if (editor.api.isEmpty(editor.selection, {
                            block: true
                        })) {
                            const overrideBreakRules = checkMatchRulesOverride("break.empty", blockNode, blockPath);
                            const effectiveBreakRules = overrideBreakRules || breakRules;
                            const emptyAction = effectiveBreakRules?.empty;
                            if (executeBreakAction(emptyAction, blockPath)) return;
                        }
                        if (!editor.api.isEmpty(editor.selection, {
                            block: true
                        }) && editor.api.isAt({
                            end: true
                        })) {
                            const range = editor.api.range("before", editor.selection);
                            if (range) {
                                const char = editor.api.string(range);
                                if (char === "\n") {
                                    const overrideBreakRules = checkMatchRulesOverride("break.emptyLineEnd", blockNode, blockPath);
                                    const effectiveBreakRules = overrideBreakRules || breakRules;
                                    const emptyLineEndAction = effectiveBreakRules?.emptyLineEnd;
                                    if (executeBreakAction(emptyLineEndAction, blockPath)) return;
                                }
                            }
                        }
                        const overrideDefaultBreakRules = checkMatchRulesOverride("break.default", blockNode, blockPath);
                        const defaultAction = (overrideDefaultBreakRules || breakRules)?.default;
                        if (executeBreakAction(defaultAction, blockPath)) return;
                        const overrideSplitResetBreakRules = checkMatchRulesOverride("break.splitReset", blockNode, blockPath);
                        const splitReset = overrideSplitResetBreakRules?.splitReset ?? breakRules?.splitReset;
                        if (splitReset) {
                            const isAtStart = editor.api.isAt({
                                start: true
                            });
                            insertBreak();
                            editor.tf.resetBlock({
                                at: isAtStart ? blockPath : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["PathApi"].next(blockPath)
                            });
                            return;
                        }
                    }
                }
                insertBreak();
            }
        }
    };
};
;
var withDeleteRules = (ctx)=>{
    const { editor, tf: { deleteBackward, deleteForward, deleteFragment } } = ctx;
    const resetMarks = ()=>{
        if (editor.api.isAt({
            start: true
        })) {
            editor.tf.removeMarks();
        }
    };
    const checkMatchRulesOverride = (rule, blockNode, blockPath)=>{
        const matchRulesKeys = editor.meta.pluginCache.rules.match;
        for (const key of matchRulesKeys){
            const overridePlugin = editor.getPlugin({
                key
            });
            if (overridePlugin.rules?.delete && overridePlugin.rules?.match?.({
                ...ctx,
                node: blockNode,
                path: blockPath,
                rule
            })) {
                return overridePlugin.rules.delete;
            }
        }
        return null;
    };
    const executeDeleteAction = (action, blockPath)=>{
        if (action === "reset") {
            editor.tf.resetBlock({
                at: blockPath
            });
            return true;
        }
        return false;
    };
    return {
        transforms: {
            deleteBackward (unit) {
                if (editor.selection && editor.api.isCollapsed()) {
                    const block = editor.api.block();
                    if (block) {
                        const [blockNode, blockPath] = block;
                        const plugin = getPluginByType(editor, blockNode.type);
                        const deleteRules = plugin?.rules.delete;
                        if (editor.api.isAt({
                            start: true
                        })) {
                            const overrideDeleteRules = checkMatchRulesOverride("delete.start", blockNode, blockPath);
                            const effectiveDeleteRules = overrideDeleteRules || deleteRules;
                            const startAction = effectiveDeleteRules?.start;
                            if (executeDeleteAction(startAction, blockPath)) {
                                return;
                            }
                        }
                        if (editor.api.isEmpty(editor.selection, {
                            block: true
                        })) {
                            const overrideDeleteRules = checkMatchRulesOverride("delete.empty", blockNode, blockPath);
                            const effectiveDeleteRules = overrideDeleteRules || deleteRules;
                            const emptyAction = effectiveDeleteRules?.empty;
                            if (executeDeleteAction(emptyAction, blockPath)) return;
                        }
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["PointApi"].equals(editor.selection.anchor, editor.api.start([]))) {
                        editor.tf.resetBlock({
                            at: [
                                0
                            ]
                        });
                        return;
                    }
                }
                deleteBackward(unit);
                resetMarks();
            },
            deleteForward (unit) {
                deleteForward(unit);
                resetMarks();
            },
            deleteFragment (options) {
                if (editor.selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RangeApi"].equals(editor.selection, editor.api.range([]))) {
                    editor.tf.reset({
                        children: true,
                        select: true
                    });
                    return;
                }
                deleteFragment(options);
                resetMarks();
            }
        }
    };
};
;
var withMergeRules = (ctx)=>{
    const { editor, tf: { removeNodes } } = ctx;
    const checkMatchRulesOverride = (rule, blockNode, blockPath)=>{
        const matchRulesKeys = editor.meta.pluginCache.rules.match;
        for (const key of matchRulesKeys){
            const overridePlugin = editor.getPlugin({
                key
            });
            if (overridePlugin.rules.merge && overridePlugin.rules?.match?.({
                ...ctx,
                node: blockNode,
                path: blockPath,
                rule
            })) {
                return overridePlugin.rules.merge;
            }
        }
        return null;
    };
    return {
        api: {
            shouldMergeNodes (prevNodeEntry, nextNodeEntry, { reverse } = {}) {
                const [prevNode, prevPath] = prevNodeEntry;
                const [, nextPath] = nextNodeEntry;
                const [curNode, curPath] = reverse ? prevNodeEntry : nextNodeEntry;
                const [targetNode, targetPath] = reverse ? nextNodeEntry : prevNodeEntry;
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["TextApi"].isText(prevNode) && prevNode.text === "" && prevPath.at(-1) !== 0) {
                    editor.tf.removeNodes({
                        at: prevPath
                    });
                    return false;
                }
                const shouldRemove = (node, path)=>{
                    const plugin = getPluginByType(editor, node.type);
                    if (!plugin) {
                        return true;
                    }
                    const mergeRules = plugin.rules.merge;
                    if (!mergeRules?.removeEmpty) {
                        return false;
                    }
                    const overrideMergeRules = checkMatchRulesOverride("merge.removeEmpty", node, path);
                    if (overrideMergeRules?.removeEmpty === false) {
                        return false;
                    }
                    return true;
                };
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(targetNode) && editor.api.isVoid(targetNode)) {
                    if (shouldRemove(targetNode, targetPath)) {
                        editor.tf.removeNodes({
                            at: prevPath
                        });
                    } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(curNode) && editor.api.isEmpty(curNode)) {
                        editor.tf.removeNodes({
                            at: curPath
                        });
                    }
                    return false;
                }
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(prevNode) && editor.api.isEmpty(prevNode) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["PathApi"].isSibling(prevPath, nextPath) && shouldRemove(prevNode, prevPath)) {
                    editor.tf.removeNodes({
                        at: prevPath
                    });
                    return false;
                }
                return true;
            }
        },
        transforms: {
            removeNodes (options = {}) {
                if (options.event?.type === "mergeNodes" && options.at) {
                    const nodeEntry = editor.api.node(options.at);
                    if (nodeEntry) {
                        const [node, path] = nodeEntry;
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(node)) {
                            const plugin = getPluginByType(editor, node.type);
                            if (plugin) {
                                const mergeRules = plugin.rules.merge;
                                const overrideMergeRules = checkMatchRulesOverride("merge.removeEmpty", node, path);
                                const shouldNotRemove = overrideMergeRules?.removeEmpty === false || mergeRules?.removeEmpty === false;
                                if (shouldNotRemove) {
                                    return;
                                }
                            }
                        }
                    }
                }
                removeNodes(options);
            }
        }
    };
};
;
var withNormalizeRules = (ctx)=>{
    const { editor, tf: { normalizeNode } } = ctx;
    const checkMatchRulesOverride = (rule, node, path)=>{
        const matchRulesKeys = editor.meta.pluginCache.rules.match;
        for (const key of matchRulesKeys){
            const overridePlugin = editor.getPlugin({
                key
            });
            if (overridePlugin.rules?.normalize && overridePlugin.rules?.match?.({
                ...ctx,
                node,
                path,
                rule
            })) {
                return overridePlugin.rules.normalize;
            }
        }
        return null;
    };
    return {
        transforms: {
            normalizeNode ([node, path]) {
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(node) && node.type) {
                    const plugin = getPluginByType(editor, node.type);
                    const normalizeRules = plugin?.rules.normalize;
                    const overridenormalizeRules = checkMatchRulesOverride("normalize.removeEmpty", node, path);
                    const effectivenormalizeRules = overridenormalizeRules || normalizeRules;
                    if (effectivenormalizeRules?.removeEmpty && editor.api.isEmpty(node)) {
                        editor.tf.removeNodes({
                            at: path
                        });
                        return;
                    }
                }
                normalizeNode([
                    node,
                    path
                ]);
            }
        }
    };
};
// src/lib/plugins/override/OverridePlugin.ts
var withOverrides = ({ api: { isInline, isSelectable, isVoid, markableVoid }, editor })=>{
    const voidTypes = editor.meta.pluginCache.node.isVoid;
    const inlineTypes = editor.meta.pluginCache.node.isInline;
    const markableVoidTypes = editor.meta.pluginCache.node.isMarkableVoid;
    const notSelectableTypes = editor.meta.pluginCache.node.isNotSelectable;
    return {
        api: {
            create: {
                block: (node)=>({
                        children: [
                            {
                                text: ""
                            }
                        ],
                        type: editor.getType(BaseParagraphPlugin.key),
                        ...node
                    })
            },
            isInline (element) {
                return inlineTypes.includes(element.type) ? true : isInline(element);
            },
            isSelectable (element) {
                return notSelectableTypes.includes(element.type) ? false : isSelectable(element);
            },
            isVoid (element) {
                return voidTypes.includes(element.type) ? true : isVoid(element);
            },
            markableVoid (element) {
                return markableVoidTypes.includes(element.type) ? true : markableVoid(element);
            }
        }
    };
};
var OverridePlugin = createSlatePlugin({
    key: "override"
}).overrideEditor(withOverrides).overrideEditor(withBreakRules).overrideEditor(withDeleteRules).overrideEditor(withMergeRules).overrideEditor(withNormalizeRules);
// src/internal/plugin/pipeInsertFragment.ts
var pipeInsertFragment = (editor, injectedPlugins, { fragment, ...options })=>{
    editor.tf.withoutNormalizing(()=>{
        injectedPlugins.some((p)=>{
            return p.parser?.preInsert?.({
                ...getEditorPlugin(editor, p),
                fragment,
                ...options
            }) === true;
        });
        editor.tf.insertFragment(fragment);
    });
};
// src/internal/plugin/pipeTransformData.ts
var pipeTransformData = (editor, plugins2, { data, dataTransfer })=>{
    plugins2.forEach((p)=>{
        const transformData = p.parser?.transformData;
        if (!transformData) return;
        data = transformData({
            ...getEditorPlugin(editor, p),
            data,
            dataTransfer
        });
    });
    return data;
};
// src/internal/plugin/pipeTransformFragment.ts
var pipeTransformFragment = (editor, plugins2, { fragment, ...options })=>{
    plugins2.forEach((p)=>{
        const transformFragment = p.parser?.transformFragment;
        if (!transformFragment) return;
        fragment = transformFragment({
            fragment,
            ...options,
            ...getEditorPlugin(editor, p)
        });
    });
    return fragment;
};
;
var applyDeepToNodes = ({ apply, node, path = [], query, source })=>{
    const entry = [
        node,
        path
    ];
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryNode"])(entry, query)) {
        if (typeof source === "function") {
            apply(node, source());
        } else {
            apply(node, source);
        }
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].isAncestor(node)) return;
    node.children.forEach((child, index)=>{
        applyDeepToNodes({
            apply,
            node: child,
            path: path.concat([
                index
            ]),
            query,
            source
        });
    });
};
;
var defaultsDeepToNodes = (options)=>{
    applyDeepToNodes({
        ...options,
        apply: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
    });
};
;
// src/lib/utils/getKeysByTypes.ts
var getKeysByTypes = (editor, types)=>{
    return Object.values(editor.plugins).filter((plugin)=>types.includes(plugin.node.type)).map((plugin)=>plugin.key);
};
var getKeyByType = (editor, type)=>{
    const plugin = Object.values(editor.plugins).find((plugin2)=>plugin2.node.type === type);
    return plugin?.key ?? type;
};
// src/lib/utils/getInjectMatch.ts
var getInjectMatch = (editor, plugin)=>{
    return (node, path)=>{
        const { inject: { excludeBelowPlugins, excludePlugins, isBlock: _isBlock, isElement: _isElement, isLeaf, maxLevel, targetPlugins } } = plugin;
        const element = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(node) ? node : void 0;
        if (_isElement && !element) return false;
        if (_isBlock && (!element || !editor.api.isBlock(element))) return false;
        if (isLeaf && element) return false;
        if (element?.type) {
            if (excludePlugins?.includes(getKeyByType(editor, element.type))) {
                return false;
            }
            if (targetPlugins && !targetPlugins.includes(getKeyByType(editor, element.type))) {
                return false;
            }
        }
        if (excludeBelowPlugins || maxLevel) {
            if (maxLevel && path.length > maxLevel) {
                return false;
            }
            if (excludeBelowPlugins) {
                const excludeTypes = getKeysByTypes(editor, excludeBelowPlugins);
                const isBelow = editor.api.above({
                    at: path,
                    match: (n)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(n) && excludeTypes.includes(n.type)
                });
                if (isBelow) return false;
            }
        }
        return true;
    };
};
// src/lib/utils/getInjectedPlugins.ts
var getInjectedPlugins = (editor, plugin)=>{
    const injectedPlugins = [];
    [
        ...editor.meta.pluginList
    ].reverse().forEach((p)=>{
        const injectedPlugin = p.inject.plugins?.[plugin.key];
        if (injectedPlugin) injectedPlugins.push(injectedPlugin);
    });
    return [
        plugin,
        ...injectedPlugins
    ];
};
;
;
;
;
var useNodeAttributes = (props, ref)=>{
    return {
        ...props.attributes,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clsx"])(props.attributes.className, props.className) || void 0,
        ref,
        style: {
            ...props.attributes.style,
            ...props.style
        }
    };
};
var SlateElement = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(function SlateElement2({ as: Tag = "div", children, ...props }, ref) {
    const attributes = useNodeAttributes(props, ref);
    const block = !!props.element.id && !!props.editor.api.isBlock(props.element);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Tag, {
        "data-slate-node": "element",
        "data-slate-inline": attributes["data-slate-inline"],
        "data-block-id": block ? props.element.id : void 0,
        ...attributes,
        style: {
            position: "relative",
            ...attributes?.style
        }
    }, children);
});
var SlateText = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(({ as: Tag = "span", children, ...props }, ref)=>{
    const attributes = useNodeAttributes(props, ref);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Tag, {
        ...attributes
    }, children);
});
var NonBreakingSpace = ()=>/* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("span", {
        style: {
            fontSize: 0
        },
        contentEditable: false
    }, String.fromCodePoint(160));
var SlateLeaf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(({ as: Tag = "span", children, inset, ...props }, ref)=>{
    const attributes = useNodeAttributes(props, ref);
    if (inset) {
        return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(NonBreakingSpace, null), /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Tag, {
            ...attributes
        }, children, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(NonBreakingSpace, null)));
    }
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Tag, {
        ...attributes
    }, children);
});
;
;
function createStaticString({ text }) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("span", {
        "data-slate-string": true
    }, text === "" ? "\uFEFF" : text);
}
;
;
var getNodeDataAttributes = (editor, node, { isElement: isElement2, isLeaf, isText })=>{
    const dataAttributes = Object.keys(node).reduce((acc, key)=>{
        if (typeof node[key] === "object") return acc;
        if (isElement2 && key === "children") return acc;
        if ((isLeaf || isText) && key === "text") return acc;
        const plugin = editor.getPlugin({
            key
        });
        if (isLeaf && plugin?.node.isLeaf && plugin?.node.isDecoration !== true) {
            return acc;
        }
        if (isText && plugin?.node.isLeaf && plugin?.node.isDecoration !== false) {
            return acc;
        }
        const attributeName = keyToDataAttribute(key);
        return {
            ...acc,
            [attributeName]: node[key]
        };
    }, {});
    return dataAttributes;
};
var getPluginDataAttributes = (editor, plugin, node)=>{
    const isElement2 = plugin.node.isElement;
    const isLeaf = plugin.node.isLeaf && plugin.node.isDecoration === true;
    const isText = plugin.node.isLeaf && plugin.node.isDecoration === false;
    const dataAttributes = getNodeDataAttributes(editor, node, {
        isElement: isElement2,
        isLeaf,
        isText
    });
    const customAttributes = plugin.node.toDataAttributes?.({
        ...plugin ? getEditorPlugin(editor, plugin) : {},
        node
    }) ?? {};
    return {
        ...dataAttributes,
        ...customAttributes
    };
};
var getNodeDataAttributeKeys = (node)=>{
    return Object.keys(node).filter((key)=>typeof node[key] !== "object" && (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["TextApi"].isText(node) || key !== "text")).map((key)=>keyToDataAttribute(key));
};
var keyToDataAttribute = (key)=>{
    return `data-slate-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$kebabCase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(key)}`;
};
;
;
// src/internal/plugin/isEditOnlyDisabled.ts
var DEFAULT = {
    handlers: true,
    inject: true,
    normalizeInitialValue: false,
    render: true
};
var isEditOnly = (readOnly, plugin, feature)=>{
    if (!readOnly) return false;
    if (plugin.editOnly === true) {
        return DEFAULT[feature];
    }
    if (typeof plugin.editOnly === "object") {
        return plugin.editOnly[feature] ?? DEFAULT[feature];
    }
    return false;
};
;
var pluginInjectNodeProps = (editor, plugin, nodeProps, getElementPath)=>{
    const { key, inject: { nodeProps: injectNodeProps } } = plugin;
    const { element, text } = nodeProps;
    const node = element ?? text;
    if (!node) return;
    if (!injectNodeProps) return;
    const { classNames, defaultNodeValue, nodeKey = editor.getType(key), query, styleKey = nodeKey, transformClassName, transformNodeValue, transformProps, transformStyle, validNodeValues } = injectNodeProps;
    const injectMatch = getInjectMatch(editor, plugin);
    if (!injectMatch(node, getElementPath(node))) return;
    const queryResult = query?.({
        ...injectNodeProps,
        ...getEditorPlugin(editor, plugin),
        nodeProps
    });
    if (query && !queryResult) {
        return;
    }
    const nodeValue = node[nodeKey];
    if (!transformProps && (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(nodeValue) || validNodeValues && !validNodeValues.includes(nodeValue) || nodeValue === defaultNodeValue)) {
        return;
    }
    const transformOptions = {
        ...nodeProps,
        ...getEditorPlugin(editor, plugin),
        nodeValue
    };
    const value = transformNodeValue?.(transformOptions) ?? nodeValue;
    transformOptions.value = value;
    let newProps = {};
    if (element && nodeKey && nodeValue) {
        newProps.className = `slate-${nodeKey}-${nodeValue}`;
    }
    if (classNames?.[nodeValue] || transformClassName) {
        newProps.className = transformClassName?.(transformOptions) ?? classNames?.[value];
    }
    if (styleKey) {
        newProps.style = transformStyle?.(transformOptions) ?? {
            [styleKey]: value
        };
    }
    if (transformProps) {
        newProps = transformProps({
            ...transformOptions,
            props: newProps
        }) ?? newProps;
    }
    return newProps;
};
// src/internal/plugin/pipeInjectNodeProps.tsx
var pipeInjectNodeProps = (editor, nodeProps, getElementPath, readOnly = false)=>{
    editor.meta.pluginCache.inject.nodeProps.forEach((key)=>{
        const plugin = editor.getPlugin({
            key
        });
        const newAttributes = pluginInjectNodeProps(editor, plugin, nodeProps, getElementPath);
        if (isEditOnly(readOnly, plugin, "inject")) {
            return;
        }
        if (!newAttributes) return;
        const attributes = nodeProps.attributes;
        nodeProps.attributes = {
            ...attributes,
            ...newAttributes,
            className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attributes?.className, newAttributes.className) || void 0,
            style: {
                ...attributes?.style,
                ...newAttributes.style
            }
        };
    });
    return nodeProps;
};
// src/lib/static/utils/getRenderNodeStaticProps.ts
var getRenderNodeStaticProps = ({ attributes: nodeAttributes, editor, node, plugin, props })=>{
    let newProps = {
        ...props,
        ...plugin ? getEditorPlugin(editor, plugin) : {
            api: editor.api,
            editor,
            tf: editor.transforms
        }
    };
    const { className } = props;
    const pluginProps = getPluginNodeProps({
        attributes: nodeAttributes,
        node,
        plugin,
        props: newProps
    });
    newProps = {
        ...pluginProps,
        attributes: {
            ...pluginProps.attributes,
            className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(getSlateClass(plugin?.node.type), className) || void 0
        }
    };
    newProps = pipeInjectNodeProps(editor, newProps, (node2)=>editor.api.findPath(node2));
    if (newProps.style && Object.keys(newProps.style).length === 0) {
        delete newProps.style;
    }
    return newProps;
};
// src/lib/static/utils/pipeDecorate.ts
var pipeDecorate = (editor, decorateProp)=>{
    if (editor.meta.pluginCache.decorate.length === 0 && !decorateProp) return;
    return (entry)=>{
        let ranges = [];
        const addRanges = (newRanges)=>{
            if (newRanges?.length) ranges = [
                ...ranges,
                ...newRanges
            ];
        };
        editor.meta.pluginCache.decorate.forEach((key)=>{
            const plugin = editor.getPlugin({
                key
            });
            addRanges(plugin.decorate({
                ...getEditorPlugin(editor, plugin),
                entry
            }));
        });
        if (decorateProp) {
            addRanges(decorateProp({
                editor,
                entry
            }));
        }
        return ranges;
    };
};
// src/lib/static/utils/stripHtmlClassNames.ts
var classAttrRegExp = / class="([^"]*)"/g;
var stripHtmlClassNames = (html, { preserveClassNames = [
    "slate-"
] })=>{
    if (preserveClassNames.length === 0) {
        return html.replaceAll(classAttrRegExp, "");
    }
    const preserveRegExp = new RegExp(preserveClassNames.map((cn)=>`^${cn}`).join("|"));
    return html.replaceAll(classAttrRegExp, (match, className)=>{
        const classesToKeep = className.split(/\s+/).filter((cn)=>preserveRegExp.test(cn));
        return classesToKeep.length === 0 ? "" : ` class="${classesToKeep.join(" ")}"`;
    });
};
// src/lib/static/utils/stripSlateDataAttributes.ts
var stripSlateDataAttributes = (rawHtml)=>rawHtml.replaceAll(/ data-slate(?:-node|-type|-leaf|-string)="[^"]+"/g, "").replaceAll(/ data-testid="[^"]+"/g, "");
// src/lib/static/pluginRenderElementStatic.tsx
var pluginRenderElementStatic = (editor, plugin)=>function render(nodeProps) {
        if (nodeProps.element.type === plugin.node.type) {
            const element = nodeProps.element;
            const Component = editor.meta.components?.[plugin.key];
            const Element2 = Component ?? SlateElement;
            let { children } = nodeProps;
            const dataAttributes = getPluginDataAttributes(editor, plugin, element);
            nodeProps = getRenderNodeStaticProps({
                attributes: {
                    ...element.attributes,
                    ...dataAttributes
                },
                editor,
                node: element,
                plugin,
                props: nodeProps
            });
            editor.meta.pluginCache.render.belowNodes.forEach((key)=>{
                const hoc = editor.getPlugin({
                    key
                }).render.belowNodes({
                    ...nodeProps,
                    key
                });
                if (hoc) {
                    children = hoc({
                        ...nodeProps,
                        children
                    });
                }
            });
            const defaultProps = Component ? {} : {
                as: plugin.render?.as
            };
            let component = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Element2, {
                ...defaultProps,
                ...nodeProps
            }, children, editor.meta.pluginCache.render.belowRootNodes.map((key)=>{
                const plugin2 = editor.getPlugin({
                    key
                });
                const Component2 = plugin2.render.belowRootNodes;
                return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Component2, {
                    key,
                    ...defaultProps,
                    ...nodeProps
                });
            }));
            editor.meta.pluginCache.render.aboveNodes.forEach((key)=>{
                const hoc = editor.getPlugin({
                    key
                }).render.aboveNodes({
                    ...nodeProps,
                    key
                });
                if (hoc) {
                    component = hoc({
                        ...nodeProps,
                        children: component
                    });
                }
            });
            return component;
        }
    };
// src/lib/static/pipeRenderElementStatic.tsx
var pipeRenderElementStatic = (editor, { renderElement: renderElementProp } = {})=>{
    return function render(props) {
        let element;
        editor.meta.pluginCache.node.isElement.some((key)=>{
            const plugin = editor.getPlugin({
                key
            });
            element = pluginRenderElementStatic(editor, plugin)(props);
            return !!element;
        });
        if (element) return element;
        if (renderElementProp) {
            return renderElementProp(props);
        }
        const ctxProps = getRenderNodeStaticProps({
            editor,
            props: {
                ...props
            }
        });
        return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(SlateElement, {
            ...ctxProps
        }, props.children, editor.meta.pluginCache.render.belowRootNodes.map((key)=>{
            const plugin = editor.getPlugin({
                key
            });
            const Component = plugin.render.belowRootNodes;
            return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Component, {
                key,
                ...ctxProps
            });
        }));
    };
};
;
;
;
;
;
;
;
var pluginRenderTextStatic = (editor, plugin)=>function render(nodeProps) {
        const { children, text } = nodeProps;
        if (text[plugin.node.type ?? plugin.key]) {
            const Component = editor.meta.components?.[plugin.key];
            const Text2 = Component ?? SlateText;
            const ctxProps = getRenderNodeStaticProps({
                attributes: {
                    ...text.attributes
                },
                editor,
                node: text,
                plugin,
                props: nodeProps
            });
            const defaultProps = Component ? {} : {
                as: plugin.render?.as
            };
            return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Text2, {
                ...defaultProps,
                ...ctxProps
            }, children);
        }
        return children;
    };
var pipeRenderTextStatic = (editor, { renderText: renderTextProp } = {})=>{
    const renderTexts = [];
    const textPropsPlugins = [];
    editor.meta.pluginList.forEach((plugin)=>{
        if (plugin.node.isLeaf && plugin.node.isDecoration === false) {
            renderTexts.push(pluginRenderTextStatic(editor, plugin));
        }
        if (plugin.node.textProps) {
            textPropsPlugins.push(plugin);
        }
    });
    return function render({ attributes, ...props }) {
        renderTexts.forEach((render2)=>{
            const newChildren = render2(props);
            if (newChildren !== void 0) {
                props.children = newChildren;
            }
        });
        textPropsPlugins.forEach((plugin)=>{
            if (props.text[plugin.node.type ?? plugin.key]) {
                const pluginTextProps = typeof plugin.node.textProps === "function" ? plugin.node.textProps(props) : plugin.node.textProps ?? {};
                if (pluginTextProps.className) {
                    pluginTextProps.className = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(props.className, pluginTextProps.className);
                }
                attributes = {
                    ...attributes,
                    ...pluginTextProps
                };
            }
        });
        if (renderTextProp) {
            return renderTextProp({
                attributes,
                ...props
            });
        }
        const ctxProps = getRenderNodeStaticProps({
            editor,
            props: {
                attributes,
                ...props
            }
        });
        const text = ctxProps.text;
        const dataAttributes = getNodeDataAttributes(editor, text, {
            isText: true
        });
        return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(SlateText, {
            ...ctxProps,
            attributes: {
                ...ctxProps.attributes,
                ...dataAttributes
            }
        });
    };
};
// src/lib/static/components/PlateStatic.tsx
function BaseElementStatic({ decorate, decorations, editor, element = {
    children: [],
    type: ""
} }) {
    const renderElement = pipeRenderElementStatic(editor);
    const attributes = {
        "data-slate-node": "element",
        ref: null
    };
    let children = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Children, {
        decorate,
        decorations,
        editor
    }, element.children);
    if (editor.api.isVoid(element)) {
        attributes["data-slate-void"] = true;
        children = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("span", {
            style: {
                color: "transparent",
                height: "0",
                outline: "none",
                position: "absolute"
            },
            "data-slate-spacer": true
        }, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Children, {
            decorate,
            decorations,
            editor
        }, element.children));
    }
    if (editor.api.isInline(element)) {
        attributes["data-slate-inline"] = true;
    }
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, renderElement?.({
        attributes,
        children,
        element
    }));
}
var ElementStatic = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].memo(BaseElementStatic, (prev, next)=>{
    return (prev.element === next.element || prev.element._memo !== void 0 && prev.element._memo === next.element._memo) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElementDecorationsEqual"])(prev.decorations, next.decorations);
});
function BaseLeafStatic({ decorations, editor, text = {
    text: ""
} }) {
    const renderLeaf = pipeRenderLeafStatic(editor);
    const renderText = pipeRenderTextStatic(editor);
    const decoratedLeaves = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["TextApi"].decorations(text, decorations);
    const leafElements = decoratedLeaves.map(({ leaf, position }, index)=>{
        const leafElement = renderLeaf({
            attributes: {
                "data-slate-leaf": true
            },
            children: /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("span", {
                "data-slate-string": true
            }, leaf.text === "" ? "\uFEFF" : leaf.text),
            leaf,
            leafPosition: position,
            text: leaf
        });
        return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, {
            key: index
        }, leafElement);
    });
    return renderText({
        attributes: {
            "data-slate-node": "text",
            ref: null
        },
        children: leafElements,
        text
    });
}
var LeafStatic = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].memo(BaseLeafStatic, (prev, next)=>{
    return(// prev.text === next.text &&
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["TextApi"].equals(next.text, prev.text) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextDecorationsEqual"])(next.decorations, prev.decorations));
});
var defaultDecorate = ()=>[];
function Children({ children = [], decorate = defaultDecorate, decorations = [], editor }) {
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, children.map((child, i)=>{
        const p = editor.api.findPath(child);
        let ds = [];
        if (p) {
            const range = editor.api.range(p);
            ds = decorate([
                child,
                p
            ]);
            for (const dec of decorations){
                const d = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RangeApi"].intersection(dec, range);
                if (d) {
                    ds.push(d);
                }
            }
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(child) ? /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(ElementStatic, {
            key: i,
            decorate,
            decorations: ds,
            editor,
            element: child
        }) : /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(LeafStatic, {
            key: i,
            decorations: ds,
            editor,
            text: child
        });
    }));
}
function PlateStatic(props) {
    const { className, editor, value, ...rest } = props;
    if (value) {
        editor.children = value;
    }
    const decorate = pipeDecorate(editor);
    let afterEditable = null;
    let beforeEditable = null;
    editor.meta.pluginCache.render.beforeEditable.forEach((key)=>{
        const plugin = editor.getPlugin({
            key
        });
        const BeforeEditable = plugin.render.beforeEditable;
        if (BeforeEditable) {
            beforeEditable = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, beforeEditable, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(BeforeEditable, null));
        }
    });
    editor.meta.pluginCache.render.afterEditable.forEach((key)=>{
        const plugin = editor.getPlugin({
            key
        });
        const AfterEditable = plugin.render.afterEditable;
        if (AfterEditable) {
            afterEditable = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, afterEditable, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(AfterEditable, null));
        }
    });
    const content = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("slate-editor", className),
        "data-slate-editor": true,
        "data-slate-node": "value",
        ...rest
    }, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Children, {
        decorate,
        decorations: [],
        editor
    }, editor.children));
    let aboveEditable = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, beforeEditable, content, afterEditable);
    editor.meta.pluginCache.render.aboveEditable.forEach((key)=>{
        const plugin = editor.getPlugin({
            key
        });
        const AboveEditable = plugin.render.aboveEditable;
        if (AboveEditable) {
            aboveEditable = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(AboveEditable, null, aboveEditable);
        }
    });
    return aboveEditable;
}
// src/lib/static/pluginRenderLeafStatic.tsx
var pluginRenderLeafStatic = (editor, plugin)=>function render(props) {
        const { children, leaf } = props;
        if (leaf[plugin.node.type ?? plugin.key]) {
            const Component = plugin.render.leaf ?? editor.meta.components?.[plugin.key];
            const Leaf = Component ?? SlateLeaf;
            const ctxProps = getRenderNodeStaticProps({
                attributes: {
                    ...leaf.attributes
                },
                editor,
                node: leaf,
                plugin,
                props
            });
            const defaultProps = Component ? {} : {
                as: plugin.render?.as
            };
            return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Leaf, {
                ...defaultProps,
                ...ctxProps
            }, children);
        }
        return children;
    };
var pipeRenderLeafStatic = (editor, { renderLeaf: renderLeafProp } = {})=>{
    const renderLeafs = [];
    const leafPropsPlugins = [];
    editor.meta.pluginList.forEach((plugin)=>{
        if (plugin.node.isLeaf && (plugin.node.isDecoration === true || plugin.render.leaf)) {
            renderLeafs.push(pluginRenderLeafStatic(editor, plugin));
        }
        if (plugin.node.leafProps) {
            leafPropsPlugins.push(plugin);
        }
    });
    return function render({ attributes, ...props }) {
        renderLeafs.forEach((render2)=>{
            const newChildren = render2(props);
            if (newChildren !== void 0) {
                props.children = newChildren;
            }
        });
        leafPropsPlugins.forEach((plugin)=>{
            if (props.leaf[plugin.node.type ?? plugin.key]) {
                const pluginLeafProps = typeof plugin.node.leafProps === "function" ? plugin.node.leafProps(props) : plugin.node.leafProps ?? {};
                if (pluginLeafProps.className) {
                    pluginLeafProps.className = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(props.className, pluginLeafProps.className);
                }
                attributes = {
                    ...attributes,
                    ...pluginLeafProps
                };
            }
        });
        if (renderLeafProp) {
            return renderLeafProp({
                attributes,
                ...props
            });
        }
        const ctxProps = getRenderNodeStaticProps({
            editor,
            props: {
                attributes,
                ...props
            }
        });
        const leaf = ctxProps.leaf;
        const dataAttributes = getNodeDataAttributes(editor, leaf, {
            isLeaf: true
        });
        return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(SlateLeaf, {
            ...ctxProps,
            attributes: {
                ...ctxProps.attributes,
                ...dataAttributes
            }
        });
    };
};
;
;
var getReactDOMServer = async ()=>{
    const ReactDOMServer = (await __turbopack_context__.A("[project]/node_modules/next/dist/compiled/react-dom/server.browser.js [app-client] (ecmascript, async loader)")).default;
    return ReactDOMServer;
};
var renderComponentToHtml = (ReactDOMServer, Component, props)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$entities$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(ReactDOMServer.renderToStaticMarkup(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Component, props)));
};
var serializeHtml = async (editor, { editorComponent: EditorComponent = PlateStatic, preserveClassNames, props = {}, stripClassNames = false, stripDataAttributes = false } = {})=>{
    const ReactDOMServer = await getReactDOMServer();
    let htmlString = renderComponentToHtml(ReactDOMServer, EditorComponent, {
        editor,
        ...props
    });
    if (stripClassNames) {
        htmlString = stripHtmlClassNames(htmlString, {
            preserveClassNames
        });
    }
    if (stripDataAttributes) {
        htmlString = stripSlateDataAttributes(htmlString);
    }
    return htmlString;
};
// src/lib/static/deserialize/checkUtils.ts
var isSlateVoid = (element)=>{
    return element.dataset.slateVoid === "true";
};
var isSlateElement = (element)=>{
    return element.dataset.slateNode === "element";
};
var isSlateText = (element)=>{
    return element.dataset.slateNode === "text";
};
var isSlateString = (element)=>{
    return element.dataset.slateString === "true";
};
var isSlateLeaf = (element)=>{
    return element.dataset.slateLeaf === "true";
};
var isSlateEditor = (element)=>{
    return element.dataset.slateEditor === "true";
};
var isSlateNode = (element)=>{
    return isSlateLeaf(element) || isSlateElement(element) || isSlateVoid(element) || isSlateString(element) || isSlateText(element);
};
var isSlatePluginElement = (element, pluginKey)=>{
    return element.dataset.slateNode === "element" && element.classList.contains(`slate-${pluginKey}`);
};
var isSlatePluginNode = (element, pluginKey)=>{
    return element.classList.contains(`slate-${pluginKey}`);
};
var getSlateElements = (element)=>{
    return Array.from(element.querySelectorAll('[data-slate-node="element"]'));
};
// src/lib/static/deserialize/htmlStringToEditorDOM.ts
var getEditorDOMFromHtmlString = (html)=>{
    const node = document.createElement("body");
    node.innerHTML = html;
    const editorNode = node.querySelector('[data-slate-editor="true"]');
    return editorNode;
};
// src/lib/utils/getPluginNodeProps.ts
var getPluginNodeProps = ({ attributes: nodeAttributes, node, plugin, props })=>{
    const newProps = {
        ...props,
        attributes: {
            ...props.attributes
        }
    };
    if (plugin?.node.props) {
        const pluginNodeProps = (typeof plugin.node.props === "function" ? plugin.node.props(newProps) : plugin.node.props) ?? {};
        newProps.attributes = {
            ...newProps.attributes,
            ...pluginNodeProps
        };
    }
    if (nodeAttributes && plugin) {
        newProps.attributes = {
            ...newProps.attributes,
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nodeAttributes, ...plugin.node.dangerouslyAllowAttributes ?? [], [
                ...node ? getNodeDataAttributeKeys(node) : []
            ])
        };
    }
    Object.keys(newProps.attributes).forEach((key)=>{
        if (newProps.attributes?.[key] === void 0) {
            delete newProps.attributes?.[key];
        }
    });
    return newProps;
};
// src/lib/utils/getSlateClass.ts
var getSlateClass = (type)=>type ? `slate-${type}` : "";
;
;
;
var HOTKEYS = {
    bold: "mod+b",
    compose: [
        "down",
        "left",
        "right",
        "up",
        "backspace",
        "enter"
    ],
    deleteBackward: "shift?+backspace",
    deleteForward: "shift?+delete",
    escape: "escape",
    extendBackward: "shift+left",
    extendDownward: "shift+down",
    extendForward: "shift+right",
    extendUpward: "shift+up",
    insertSoftBreak: "shift+enter",
    italic: "mod+i",
    moveBackward: "left",
    moveDownward: "down",
    moveForward: "right",
    moveUpward: "up",
    moveWordBackward: "ctrl+left",
    moveWordForward: "ctrl+right",
    selectAll: "mod+a",
    splitBlock: "enter",
    tab: "tab",
    undo: "mod+z",
    untab: "shift+tab"
};
var APPLE_HOTKEYS = {
    deleteBackward: [
        "ctrl+backspace",
        "ctrl+h"
    ],
    deleteForward: [
        "ctrl+delete",
        "ctrl+d"
    ],
    deleteLineBackward: "cmd+shift?+backspace",
    deleteLineForward: [
        "cmd+shift?+delete",
        "ctrl+k"
    ],
    deleteWordBackward: "opt+shift?+backspace",
    deleteWordForward: "opt+shift?+delete",
    extendLineBackward: "opt+shift+up",
    extendLineForward: "opt+shift+down",
    moveLineBackward: "opt+up",
    moveLineForward: "opt+down",
    moveWordBackward: "opt+left",
    moveWordForward: "opt+right",
    redo: "cmd+shift+z",
    transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS = {
    deleteWordBackward: "ctrl+shift?+backspace",
    deleteWordForward: "ctrl+shift?+delete",
    redo: [
        "ctrl+y",
        "ctrl+shift+z"
    ]
};
var createHotkey = (key)=>{
    const generic = HOTKEYS[key];
    const apple = APPLE_HOTKEYS[key];
    const windows = WINDOWS_HOTKEYS[key];
    const isGeneric = generic && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$hotkey$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeyHotkey"])(generic);
    const isApple = apple && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$hotkey$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeyHotkey"])(apple);
    const isWindows = windows && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$hotkey$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeyHotkey"])(windows);
    return (event)=>{
        if (isGeneric?.(event)) return true;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_APPLE"] && isApple?.(event)) return true;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_APPLE"] && isWindows?.(event)) return true;
        return false;
    };
};
var createComposing = (key)=>(editor, event, { composing } = {})=>{
        if (!createHotkey(key)(event)) return false;
        if (!!composing !== editor.api.isComposing()) return false;
        return true;
    };
var Hotkeys = {
    isBold: createHotkey("bold"),
    isCompose: createHotkey("compose"),
    isDeleteBackward: createHotkey("deleteBackward"),
    isDeleteForward: createHotkey("deleteForward"),
    isDeleteLineBackward: createHotkey("deleteLineBackward"),
    isDeleteLineForward: createHotkey("deleteLineForward"),
    isDeleteWordBackward: createHotkey("deleteWordBackward"),
    isDeleteWordForward: createHotkey("deleteWordForward"),
    isEscape: createHotkey("escape"),
    isExtendBackward: createHotkey("extendBackward"),
    isExtendDownward: createHotkey("extendDownward"),
    isExtendForward: createHotkey("extendForward"),
    isExtendLineBackward: createHotkey("extendLineBackward"),
    isExtendLineForward: createHotkey("extendLineForward"),
    isExtendUpward: createHotkey("extendUpward"),
    isItalic: createHotkey("italic"),
    isMoveBackward: createHotkey("moveBackward"),
    isMoveDownward: createHotkey("moveDownward"),
    isMoveForward: createHotkey("moveForward"),
    isMoveLineBackward: createHotkey("moveLineBackward"),
    isMoveLineForward: createHotkey("moveLineForward"),
    isMoveUpward: createHotkey("moveUpward"),
    isMoveWordBackward: createHotkey("moveWordBackward"),
    isMoveWordForward: createHotkey("moveWordForward"),
    isRedo: createHotkey("redo"),
    isSelectAll: createHotkey("selectAll"),
    isSoftBreak: createHotkey("insertSoftBreak"),
    isSplitBlock: createHotkey("splitBlock"),
    isTab: createComposing("tab"),
    isTransposeCharacter: createHotkey("transposeCharacter"),
    isUndo: createHotkey("undo"),
    isUntab: createComposing("untab")
};
;
var isType = (editor, node, key)=>{
    const keys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$castArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(key);
    const types = [];
    keys.forEach((_key)=>types.push(editor.getType(_key)));
    return types.includes(node?.type);
};
;
var mergeDeepToNodes = (options)=>{
    applyDeepToNodes({
        ...options,
        apply: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
    });
};
;
;
;
// ../../node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
    var ctor, prot;
    if (isObject(o) === false) return false;
    ctor = o.constructor;
    if (ctor === void 0) return true;
    prot = ctor.prototype;
    if (isObject(prot) === false) return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
    }
    return true;
}
// ../../node_modules/immer/dist/immer.mjs
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
var errors = ("TURBOPACK compile-time truthy", 1) ? [
    // All error codes, starting by 0:
    function(plugin) {
        return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
    },
    function(thing) {
        return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
    },
    "This object has been frozen and should not be mutated",
    function(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
    },
    "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
    "Immer forbids circular references",
    "The first or second argument to `produce` must be a function",
    "The third argument to `produce` must be a function or undefined",
    "First argument to `createDraft` must be a plain object, an array, or an immerable object",
    "First argument to `finishDraft` must be a draft returned by `createDraft`",
    function(thing) {
        return `'current' expects a draft, got: ${thing}`;
    },
    "Object.defineProperty() cannot be used on an Immer draft",
    "Object.setPrototypeOf() cannot be used on an Immer draft",
    "Immer only supports deleting array indices",
    "Immer only supports setting array indices and the 'length' property",
    function(thing) {
        return `'original' expects a draft, got: ${thing}`;
    }
] : "TURBOPACK unreachable";
function die(error, ...args) {
    if ("TURBOPACK compile-time truthy", 1) {
        const e = errors[error];
        const msg = typeof e === "function" ? e.apply(null, args) : e;
        throw new Error(`[Immer] ${msg}`);
    }
    throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
    if (!value) return false;
    return isPlainObject2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject2(value) {
    if (!value || typeof value !== "object") return false;
    const proto = getPrototypeOf(value);
    if (proto === null) {
        return true;
    }
    const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    if (Ctor === Object) return true;
    return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
    if (getArchtype(obj) === 0) {
        Reflect.ownKeys(obj).forEach((key)=>{
            iter(key, obj[key], obj);
        });
    } else {
        obj.forEach((entry, index)=>iter(index, entry, obj));
    }
}
function getArchtype(thing) {
    const state = thing[DRAFT_STATE];
    return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
    return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
    const t = getArchtype(thing);
    if (t === 2) thing.set(propOrOldValue, value);
    else if (t === 3) {
        thing.add(value);
    } else thing[propOrOldValue] = value;
}
function is(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function isMap(target) {
    return target instanceof Map;
}
function isSet(target) {
    return target instanceof Set;
}
function latest(state) {
    return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
    if (isMap(base)) {
        return new Map(base);
    }
    if (isSet(base)) {
        return new Set(base);
    }
    if (Array.isArray(base)) return Array.prototype.slice.call(base);
    const isPlain = isPlainObject2(base);
    if (strict === true || strict === "class_only" && !isPlain) {
        const descriptors = Object.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE];
        let keys = Reflect.ownKeys(descriptors);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            const desc = descriptors[key];
            if (desc.writable === false) {
                desc.writable = true;
                desc.configurable = true;
            }
            if (desc.get || desc.set) descriptors[key] = {
                configurable: true,
                writable: true,
                // could live with !!desc.set as well here...
                enumerable: desc.enumerable,
                value: base[key]
            };
        }
        return Object.create(getPrototypeOf(base), descriptors);
    } else {
        const proto = getPrototypeOf(base);
        if (proto !== null && isPlain) {
            return {
                ...base
            };
        }
        const obj = Object.create(proto);
        return Object.assign(obj, base);
    }
}
function freeze(obj, deep = false) {
    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
    if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
    }
    Object.freeze(obj);
    if (deep) Object.entries(obj).forEach(([key, value])=>freeze(value, true));
    return obj;
}
function dontMutateFrozenCollections() {
    die(2);
}
function isFrozen(obj) {
    return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
    const plugin = plugins[pluginKey];
    if (!plugin) {
        die(0, pluginKey);
    }
    return plugin;
}
var currentScope;
function getCurrentScope() {
    return currentScope;
}
function createScope(parent_, immer_) {
    return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
    };
}
function usePatchesInScope(scope, patchListener) {
    if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
    }
}
function revokeScope(scope) {
    leaveScope(scope);
    scope.drafts_.forEach(revokeDraft);
    scope.drafts_ = null;
}
function leaveScope(scope) {
    if (scope === currentScope) {
        currentScope = scope.parent_;
    }
}
function enterScope(immer2) {
    return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
    const state = draft[DRAFT_STATE];
    if (state.type_ === 0 || state.type_ === 1) state.revoke_();
    else state.revoked_ = true;
}
function processResult(result, scope) {
    scope.unfinalizedDrafts_ = scope.drafts_.length;
    const baseDraft = scope.drafts_[0];
    const isReplaced = result !== void 0 && result !== baseDraft;
    if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
            revokeScope(scope);
            die(4);
        }
        if (isDraftable(result)) {
            result = finalize(scope, result);
            if (!scope.parent_) maybeFreeze(scope, result);
        }
        if (scope.patches_) {
            getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
        }
    } else {
        result = finalize(scope, baseDraft, []);
    }
    revokeScope(scope);
    if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
    }
    return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
    if (isFrozen(value)) return value;
    const state = value[DRAFT_STATE];
    if (!state) {
        each(value, (key, childValue)=>finalizeProperty(rootScope, state, value, key, childValue, path));
        return value;
    }
    if (state.scope_ !== rootScope) return value;
    if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
    }
    if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3) {
            resultEach = new Set(result);
            result.clear();
            isSet2 = true;
        }
        each(resultEach, (key, childValue)=>finalizeProperty(rootScope, state, result, key, childValue, path, isSet2));
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
            getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
        }
    }
    return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
    if (("TURBOPACK compile-time value", "development") !== "production" && childValue === targetObject) die(5);
    if (isDraft(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
            rootScope.canAutoFreeze_ = false;
        } else return;
    } else if (targetIsSet) {
        targetObject.add(childValue);
    }
    if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
            return;
        }
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop)) maybeFreeze(rootScope, childValue);
    }
}
function maybeFreeze(scope, value, deep = false) {
    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
    }
}
function createProxyProxy(base, parent) {
    const isArray = Array.isArray(base);
    const state = {
        type_: isArray ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
    };
    let target = state;
    let traps = objectTraps;
    if (isArray) {
        target = [
            state
        ];
        traps = arrayTraps;
    }
    const { revoke, proxy } = Proxy.revocable(target, traps);
    state.draft_ = proxy;
    state.revoke_ = revoke;
    return proxy;
}
var objectTraps = {
    get (state, prop) {
        if (prop === DRAFT_STATE) return state;
        const source = latest(state);
        if (!has(source, prop)) {
            return readPropFromProto(state, source, prop);
        }
        const value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
            return value;
        }
        if (value === peek(state.base_, prop)) {
            prepareCopy(state);
            return state.copy_[prop] = createProxy(value, state);
        }
        return value;
    },
    has (state, prop) {
        return prop in latest(state);
    },
    ownKeys (state) {
        return Reflect.ownKeys(latest(state));
    },
    set (state, prop, value) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc?.set) {
            desc.set.call(state.draft_, value);
            return true;
        }
        if (!state.modified_) {
            const current2 = peek(latest(state), prop);
            const currentState = current2?.[DRAFT_STATE];
            if (currentState && currentState.base_ === value) {
                state.copy_[prop] = value;
                state.assigned_[prop] = false;
                return true;
            }
            if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;
            prepareCopy(state);
            markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
    },
    deleteProperty (state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
            state.assigned_[prop] = false;
            prepareCopy(state);
            markChanged(state);
        } else {
            delete state.assigned_[prop];
        }
        if (state.copy_) {
            delete state.copy_[prop];
        }
        return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor (state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc) return desc;
        return {
            writable: true,
            configurable: state.type_ !== 1 || prop !== "length",
            enumerable: desc.enumerable,
            value: owner[prop]
        };
    },
    defineProperty () {
        die(11);
    },
    getPrototypeOf (state) {
        return getPrototypeOf(state.base_);
    },
    setPrototypeOf () {
        die(12);
    }
};
var arrayTraps = {};
each(objectTraps, (key, fn)=>{
    arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
    };
});
arrayTraps.deleteProperty = function(state, prop) {
    if (("TURBOPACK compile-time value", "development") !== "production" && isNaN(parseInt(prop))) die(13);
    return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
    if (("TURBOPACK compile-time value", "development") !== "production" && prop !== "length" && isNaN(parseInt(prop))) die(14);
    return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
    const state = draft[DRAFT_STATE];
    const source = state ? latest(state) : draft;
    return source[prop];
}
function readPropFromProto(state, source, prop) {
    const desc = getDescriptorFromProto(source, prop);
    return desc ? `value` in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_) : void 0;
}
function getDescriptorFromProto(source, prop) {
    if (!(prop in source)) return void 0;
    let proto = getPrototypeOf(source);
    while(proto){
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc) return desc;
        proto = getPrototypeOf(proto);
    }
    return void 0;
}
function markChanged(state) {
    if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
            markChanged(state.parent_);
        }
    }
}
function prepareCopy(state) {
    if (!state.copy_) {
        state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
    }
}
var Immer2 = class {
    constructor(config){
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.produce = (base, recipe, patchListener)=>{
            if (typeof base === "function" && typeof recipe !== "function") {
                const defaultBase = recipe;
                recipe = base;
                const self = this;
                return function curriedProduce(base2 = defaultBase, ...args) {
                    return self.produce(base2, (draft)=>recipe.call(this, draft, ...args));
                };
            }
            if (typeof recipe !== "function") die(6);
            if (patchListener !== void 0 && typeof patchListener !== "function") die(7);
            let result;
            if (isDraftable(base)) {
                const scope = enterScope(this);
                const proxy = createProxy(base, void 0);
                let hasError = true;
                try {
                    result = recipe(proxy);
                    hasError = false;
                } finally{
                    if (hasError) revokeScope(scope);
                    else leaveScope(scope);
                }
                usePatchesInScope(scope, patchListener);
                return processResult(result, scope);
            } else if (!base || typeof base !== "object") {
                result = recipe(base);
                if (result === void 0) result = base;
                if (result === NOTHING) result = void 0;
                if (this.autoFreeze_) freeze(result, true);
                if (patchListener) {
                    const p = [];
                    const ip = [];
                    getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
                    patchListener(p, ip);
                }
                return result;
            } else die(1, base);
        };
        this.produceWithPatches = (base, recipe)=>{
            if (typeof base === "function") {
                return (state, ...args)=>this.produceWithPatches(state, (draft)=>base(draft, ...args));
            }
            let patches, inversePatches;
            const result = this.produce(base, recipe, (p, ip)=>{
                patches = p;
                inversePatches = ip;
            });
            return [
                result,
                patches,
                inversePatches
            ];
        };
        if (typeof config?.autoFreeze === "boolean") this.setAutoFreeze(config.autoFreeze);
        if (typeof config?.useStrictShallowCopy === "boolean") this.setUseStrictShallowCopy(config.useStrictShallowCopy);
    }
    createDraft(base) {
        if (!isDraftable(base)) die(8);
        if (isDraft(base)) base = current(base);
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
    }
    finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_) die(9);
        const { scope_: scope } = state;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
    }
    /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */ setAutoFreeze(value) {
        this.autoFreeze_ = value;
    }
    /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */ setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
    }
    applyPatches(base, patches) {
        let i;
        for(i = patches.length - 1; i >= 0; i--){
            const patch = patches[i];
            if (patch.path.length === 0 && patch.op === "replace") {
                base = patch.value;
                break;
            }
        }
        if (i > -1) {
            patches = patches.slice(i + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
            return applyPatchesImpl(base, patches);
        }
        return this.produce(base, (draft)=>applyPatchesImpl(draft, patches));
    }
};
function createProxy(value, parent) {
    const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
    const scope = parent ? parent.scope_ : getCurrentScope();
    scope.drafts_.push(draft);
    return draft;
}
function current(value) {
    if (!isDraft(value)) die(10, value);
    return currentImpl(value);
}
function currentImpl(value) {
    if (!isDraftable(value) || isFrozen(value)) return value;
    const state = value[DRAFT_STATE];
    let copy;
    if (state) {
        if (!state.modified_) return state.base_;
        state.finalized_ = true;
        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    } else {
        copy = shallowCopy(value, true);
    }
    each(copy, (key, childValue)=>{
        set(copy, key, currentImpl(childValue));
    });
    if (state) {
        state.finalized_ = false;
    }
    return copy;
}
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(immer);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);
// ../../node_modules/slate/dist/index.es.js
var Path = {
    ancestors (path) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var { reverse = false } = options;
        var paths = Path.levels(path, options);
        if (reverse) {
            paths = paths.slice(1);
        } else {
            paths = paths.slice(0, -1);
        }
        return paths;
    },
    common (path, another) {
        var common = [];
        for(var i = 0; i < path.length && i < another.length; i++){
            var av = path[i];
            var bv = another[i];
            if (av !== bv) {
                break;
            }
            common.push(av);
        }
        return common;
    },
    compare (path, another) {
        var min = Math.min(path.length, another.length);
        for(var i = 0; i < min; i++){
            if (path[i] < another[i]) return -1;
            if (path[i] > another[i]) return 1;
        }
        return 0;
    },
    endsAfter (path, another) {
        var i = path.length - 1;
        var as = path.slice(0, i);
        var bs = another.slice(0, i);
        var av = path[i];
        var bv = another[i];
        return Path.equals(as, bs) && av > bv;
    },
    endsAt (path, another) {
        var i = path.length;
        var as = path.slice(0, i);
        var bs = another.slice(0, i);
        return Path.equals(as, bs);
    },
    endsBefore (path, another) {
        var i = path.length - 1;
        var as = path.slice(0, i);
        var bs = another.slice(0, i);
        var av = path[i];
        var bv = another[i];
        return Path.equals(as, bs) && av < bv;
    },
    equals (path, another) {
        return path.length === another.length && path.every((n, i)=>n === another[i]);
    },
    hasPrevious (path) {
        return path[path.length - 1] > 0;
    },
    isAfter (path, another) {
        return Path.compare(path, another) === 1;
    },
    isAncestor (path, another) {
        return path.length < another.length && Path.compare(path, another) === 0;
    },
    isBefore (path, another) {
        return Path.compare(path, another) === -1;
    },
    isChild (path, another) {
        return path.length === another.length + 1 && Path.compare(path, another) === 0;
    },
    isCommon (path, another) {
        return path.length <= another.length && Path.compare(path, another) === 0;
    },
    isDescendant (path, another) {
        return path.length > another.length && Path.compare(path, another) === 0;
    },
    isParent (path, another) {
        return path.length + 1 === another.length && Path.compare(path, another) === 0;
    },
    isPath (value) {
        return Array.isArray(value) && (value.length === 0 || typeof value[0] === "number");
    },
    isSibling (path, another) {
        if (path.length !== another.length) {
            return false;
        }
        var as = path.slice(0, -1);
        var bs = another.slice(0, -1);
        var al = path[path.length - 1];
        var bl = another[another.length - 1];
        return al !== bl && Path.equals(as, bs);
    },
    levels (path) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var { reverse = false } = options;
        var list = [];
        for(var i = 0; i <= path.length; i++){
            list.push(path.slice(0, i));
        }
        if (reverse) {
            list.reverse();
        }
        return list;
    },
    next (path) {
        if (path.length === 0) {
            throw new Error("Cannot get the next path of a root path [".concat(path, "], because it has no next index."));
        }
        var last = path[path.length - 1];
        return path.slice(0, -1).concat(last + 1);
    },
    operationCanTransformPath (operation) {
        switch(operation.type){
            case "insert_node":
            case "remove_node":
            case "merge_node":
            case "split_node":
            case "move_node":
                return true;
            default:
                return false;
        }
    },
    parent (path) {
        if (path.length === 0) {
            throw new Error("Cannot get the parent path of the root path [".concat(path, "]."));
        }
        return path.slice(0, -1);
    },
    previous (path) {
        if (path.length === 0) {
            throw new Error("Cannot get the previous path of a root path [".concat(path, "], because it has no previous index."));
        }
        var last = path[path.length - 1];
        if (last <= 0) {
            throw new Error("Cannot get the previous path of a first child path [".concat(path, "] because it would result in a negative index."));
        }
        return path.slice(0, -1).concat(last - 1);
    },
    relative (path, ancestor) {
        if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {
            throw new Error("Cannot get the relative path of [".concat(path, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
        }
        return path.slice(ancestor.length);
    },
    transform (path, operation) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (!path) return null;
        var p = [
            ...path
        ];
        var { affinity = "forward" } = options;
        if (path.length === 0) {
            return p;
        }
        switch(operation.type){
            case "insert_node":
                {
                    var { path: op } = operation;
                    if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {
                        p[op.length - 1] += 1;
                    }
                    break;
                }
            case "remove_node":
                {
                    var { path: _op } = operation;
                    if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {
                        return null;
                    } else if (Path.endsBefore(_op, p)) {
                        p[_op.length - 1] -= 1;
                    }
                    break;
                }
            case "merge_node":
                {
                    var { path: _op2, position } = operation;
                    if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {
                        p[_op2.length - 1] -= 1;
                    } else if (Path.isAncestor(_op2, p)) {
                        p[_op2.length - 1] -= 1;
                        p[_op2.length] += position;
                    }
                    break;
                }
            case "split_node":
                {
                    var { path: _op3, position: _position } = operation;
                    if (Path.equals(_op3, p)) {
                        if (affinity === "forward") {
                            p[p.length - 1] += 1;
                        } else if (affinity === "backward") ;
                        else {
                            return null;
                        }
                    } else if (Path.endsBefore(_op3, p)) {
                        p[_op3.length - 1] += 1;
                    } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {
                        p[_op3.length - 1] += 1;
                        p[_op3.length] -= _position;
                    }
                    break;
                }
            case "move_node":
                {
                    var { path: _op4, newPath: onp } = operation;
                    if (Path.equals(_op4, onp)) {
                        return p;
                    }
                    if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {
                        var copy = onp.slice();
                        if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
                            copy[_op4.length - 1] -= 1;
                        }
                        return copy.concat(p.slice(_op4.length));
                    } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {
                        if (Path.endsBefore(_op4, p)) {
                            p[_op4.length - 1] -= 1;
                        } else {
                            p[_op4.length - 1] += 1;
                        }
                    } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {
                        if (Path.endsBefore(_op4, p)) {
                            p[_op4.length - 1] -= 1;
                        }
                        p[onp.length - 1] += 1;
                    } else if (Path.endsBefore(_op4, p)) {
                        if (Path.equals(onp, p)) {
                            p[onp.length - 1] += 1;
                        }
                        p[_op4.length - 1] -= 1;
                    }
                    break;
                }
        }
        return p;
    }
};
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
    } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
}
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function ownKeys$e(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$e(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$e(Object(t), true).forEach(function(r2) {
            _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
var applyToDraft = (editor, selection, op)=>{
    switch(op.type){
        case "insert_node":
            {
                var { path, node } = op;
                var parent = Node2.parent(editor, path);
                var index = path[path.length - 1];
                if (index > parent.children.length) {
                    throw new Error('Cannot apply an "insert_node" operation at path ['.concat(path, "] because the destination is past the end of the node."));
                }
                parent.children.splice(index, 0, node);
                if (selection) {
                    for (var [point, key] of Range.points(selection)){
                        selection[key] = Point.transform(point, op);
                    }
                }
                break;
            }
        case "insert_text":
            {
                var { path: _path, offset, text } = op;
                if (text.length === 0) break;
                var _node = Node2.leaf(editor, _path);
                var before = _node.text.slice(0, offset);
                var after = _node.text.slice(offset);
                _node.text = before + text + after;
                if (selection) {
                    for (var [_point, _key] of Range.points(selection)){
                        selection[_key] = Point.transform(_point, op);
                    }
                }
                break;
            }
        case "merge_node":
            {
                var { path: _path2 } = op;
                var _node2 = Node2.get(editor, _path2);
                var prevPath = Path.previous(_path2);
                var prev = Node2.get(editor, prevPath);
                var _parent = Node2.parent(editor, _path2);
                var _index = _path2[_path2.length - 1];
                if (Text.isText(_node2) && Text.isText(prev)) {
                    prev.text += _node2.text;
                } else if (!Text.isText(_node2) && !Text.isText(prev)) {
                    prev.children.push(..._node2.children);
                } else {
                    throw new Error('Cannot apply a "merge_node" operation at path ['.concat(_path2, "] to nodes of different interfaces: ").concat(Scrubber.stringify(_node2), " ").concat(Scrubber.stringify(prev)));
                }
                _parent.children.splice(_index, 1);
                if (selection) {
                    for (var [_point2, _key2] of Range.points(selection)){
                        selection[_key2] = Point.transform(_point2, op);
                    }
                }
                break;
            }
        case "move_node":
            {
                var { path: _path3, newPath } = op;
                if (Path.isAncestor(_path3, newPath)) {
                    throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
                }
                var _node3 = Node2.get(editor, _path3);
                var _parent2 = Node2.parent(editor, _path3);
                var _index2 = _path3[_path3.length - 1];
                _parent2.children.splice(_index2, 1);
                var truePath = Path.transform(_path3, op);
                var newParent = Node2.get(editor, Path.parent(truePath));
                var newIndex = truePath[truePath.length - 1];
                newParent.children.splice(newIndex, 0, _node3);
                if (selection) {
                    for (var [_point3, _key3] of Range.points(selection)){
                        selection[_key3] = Point.transform(_point3, op);
                    }
                }
                break;
            }
        case "remove_node":
            {
                var { path: _path4 } = op;
                var _index3 = _path4[_path4.length - 1];
                var _parent3 = Node2.parent(editor, _path4);
                _parent3.children.splice(_index3, 1);
                if (selection) {
                    for (var [_point4, _key4] of Range.points(selection)){
                        var result = Point.transform(_point4, op);
                        if (selection != null && result != null) {
                            selection[_key4] = result;
                        } else {
                            var _prev = void 0;
                            var next = void 0;
                            for (var [n, p] of Node2.texts(editor)){
                                if (Path.compare(p, _path4) === -1) {
                                    _prev = [
                                        n,
                                        p
                                    ];
                                } else {
                                    next = [
                                        n,
                                        p
                                    ];
                                    break;
                                }
                            }
                            var preferNext = false;
                            if (_prev && next) {
                                if (Path.equals(next[1], _path4)) {
                                    preferNext = !Path.hasPrevious(next[1]);
                                } else {
                                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;
                                }
                            }
                            if (_prev && !preferNext) {
                                _point4.path = _prev[1];
                                _point4.offset = _prev[0].text.length;
                            } else if (next) {
                                _point4.path = next[1];
                                _point4.offset = 0;
                            } else {
                                selection = null;
                            }
                        }
                    }
                }
                break;
            }
        case "remove_text":
            {
                var { path: _path5, offset: _offset, text: _text } = op;
                if (_text.length === 0) break;
                var _node4 = Node2.leaf(editor, _path5);
                var _before = _node4.text.slice(0, _offset);
                var _after = _node4.text.slice(_offset + _text.length);
                _node4.text = _before + _after;
                if (selection) {
                    for (var [_point5, _key5] of Range.points(selection)){
                        selection[_key5] = Point.transform(_point5, op);
                    }
                }
                break;
            }
        case "set_node":
            {
                var { path: _path6, properties, newProperties } = op;
                if (_path6.length === 0) {
                    throw new Error("Cannot set properties on the root node!");
                }
                var _node5 = Node2.get(editor, _path6);
                for(var _key6 in newProperties){
                    if (_key6 === "children" || _key6 === "text") {
                        throw new Error('Cannot set the "'.concat(_key6, '" property of nodes!'));
                    }
                    var value = newProperties[_key6];
                    if (value == null) {
                        delete _node5[_key6];
                    } else {
                        _node5[_key6] = value;
                    }
                }
                for(var _key7 in properties){
                    if (!newProperties.hasOwnProperty(_key7)) {
                        delete _node5[_key7];
                    }
                }
                break;
            }
        case "set_selection":
            {
                var { newProperties: _newProperties } = op;
                if (_newProperties == null) {
                    selection = _newProperties;
                } else {
                    if (selection == null) {
                        if (!Range.isRange(_newProperties)) {
                            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Scrubber.stringify(_newProperties), " when there is no current selection."));
                        }
                        selection = _objectSpread$e({}, _newProperties);
                    }
                    for(var _key8 in _newProperties){
                        var _value = _newProperties[_key8];
                        if (_value == null) {
                            if (_key8 === "anchor" || _key8 === "focus") {
                                throw new Error('Cannot remove the "'.concat(_key8, '" selection property'));
                            }
                            delete selection[_key8];
                        } else {
                            selection[_key8] = _value;
                        }
                    }
                }
                break;
            }
        case "split_node":
            {
                var { path: _path7, position, properties: _properties } = op;
                if (_path7.length === 0) {
                    throw new Error('Cannot apply a "split_node" operation at path ['.concat(_path7, "] because the root node cannot be split."));
                }
                var _node6 = Node2.get(editor, _path7);
                var _parent4 = Node2.parent(editor, _path7);
                var _index4 = _path7[_path7.length - 1];
                var newNode;
                if (Text.isText(_node6)) {
                    var _before2 = _node6.text.slice(0, position);
                    var _after2 = _node6.text.slice(position);
                    _node6.text = _before2;
                    newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {
                        text: _after2
                    });
                } else {
                    var _before3 = _node6.children.slice(0, position);
                    var _after3 = _node6.children.slice(position);
                    _node6.children = _before3;
                    newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {
                        children: _after3
                    });
                }
                _parent4.children.splice(_index4 + 1, 0, newNode);
                if (selection) {
                    for (var [_point6, _key9] of Range.points(selection)){
                        selection[_key9] = Point.transform(_point6, op);
                    }
                }
                break;
            }
    }
    return selection;
};
var GeneralTransforms = {
    transform (editor, op) {
        editor.children = createDraft(editor.children);
        var selection = editor.selection && createDraft(editor.selection);
        try {
            selection = applyToDraft(editor, selection, op);
        } finally{
            editor.children = finishDraft(editor.children);
            if (selection) {
                editor.selection = isDraft(selection) ? finishDraft(selection) : selection;
            } else {
                editor.selection = null;
            }
        }
    }
};
var NodeTransforms = {
    insertNodes (editor, nodes, options) {
        editor.insertNodes(nodes, options);
    },
    liftNodes (editor, options) {
        editor.liftNodes(options);
    },
    mergeNodes (editor, options) {
        editor.mergeNodes(options);
    },
    moveNodes (editor, options) {
        editor.moveNodes(options);
    },
    removeNodes (editor, options) {
        editor.removeNodes(options);
    },
    setNodes (editor, props, options) {
        editor.setNodes(props, options);
    },
    splitNodes (editor, options) {
        editor.splitNodes(options);
    },
    unsetNodes (editor, props, options) {
        editor.unsetNodes(props, options);
    },
    unwrapNodes (editor, options) {
        editor.unwrapNodes(options);
    },
    wrapNodes (editor, element, options) {
        editor.wrapNodes(element, options);
    }
};
var SelectionTransforms = {
    collapse (editor, options) {
        editor.collapse(options);
    },
    deselect (editor) {
        editor.deselect();
    },
    move (editor, options) {
        editor.move(options);
    },
    select (editor, target) {
        editor.select(target);
    },
    setPoint (editor, props, options) {
        editor.setPoint(props, options);
    },
    setSelection (editor, props) {
        editor.setSelection(props);
    }
};
var isDeepEqual = (node, another)=>{
    for(var key in node){
        var a = node[key];
        var b = another[key];
        if (isPlainObject(a) && isPlainObject(b)) {
            if (!isDeepEqual(a, b)) return false;
        } else if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length) return false;
            for(var i = 0; i < a.length; i++){
                if (a[i] !== b[i]) return false;
            }
        } else if (a !== b) {
            return false;
        }
    }
    for(var _key in another){
        if (node[_key] === void 0 && another[_key] !== void 0) {
            return false;
        }
    }
    return true;
};
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
var _excluded$4 = [
    "anchor",
    "focus"
];
function ownKeys$d(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$d(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$d(Object(t), true).forEach(function(r2) {
            _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
var Range = {
    edges (range) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var { reverse = false } = options;
        var { anchor, focus } = range;
        return Range.isBackward(range) === reverse ? [
            anchor,
            focus
        ] : [
            focus,
            anchor
        ];
    },
    end (range) {
        var [, end] = Range.edges(range);
        return end;
    },
    equals (range, another) {
        return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
    },
    surrounds (range, target) {
        var intersectionRange = Range.intersection(range, target);
        if (!intersectionRange) {
            return false;
        }
        return Range.equals(intersectionRange, target);
    },
    includes (range, target) {
        if (Range.isRange(target)) {
            if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {
                return true;
            }
            var [rs, re] = Range.edges(range);
            var [ts, te] = Range.edges(target);
            return Point.isBefore(rs, ts) && Point.isAfter(re, te);
        }
        var [start, end] = Range.edges(range);
        var isAfterStart = false;
        var isBeforeEnd = false;
        if (Point.isPoint(target)) {
            isAfterStart = Point.compare(target, start) >= 0;
            isBeforeEnd = Point.compare(target, end) <= 0;
        } else {
            isAfterStart = Path.compare(target, start.path) >= 0;
            isBeforeEnd = Path.compare(target, end.path) <= 0;
        }
        return isAfterStart && isBeforeEnd;
    },
    intersection (range, another) {
        var rest = _objectWithoutProperties(range, _excluded$4);
        var [s1, e1] = Range.edges(range);
        var [s2, e2] = Range.edges(another);
        var start = Point.isBefore(s1, s2) ? s2 : s1;
        var end = Point.isBefore(e1, e2) ? e1 : e2;
        if (Point.isBefore(end, start)) {
            return null;
        } else {
            return _objectSpread$d({
                anchor: start,
                focus: end
            }, rest);
        }
    },
    isBackward (range) {
        var { anchor, focus } = range;
        return Point.isAfter(anchor, focus);
    },
    isCollapsed (range) {
        var { anchor, focus } = range;
        return Point.equals(anchor, focus);
    },
    isExpanded (range) {
        return !Range.isCollapsed(range);
    },
    isForward (range) {
        return !Range.isBackward(range);
    },
    isRange (value) {
        return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
    },
    *points (range) {
        yield [
            range.anchor,
            "anchor"
        ];
        yield [
            range.focus,
            "focus"
        ];
    },
    start (range) {
        var [start] = Range.edges(range);
        return start;
    },
    transform (range, op) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return produce(range, (r)=>{
            if (r === null) {
                return null;
            }
            var { affinity = "inward" } = options;
            var affinityAnchor;
            var affinityFocus;
            if (affinity === "inward") {
                var isCollapsed = Range.isCollapsed(r);
                if (Range.isForward(r)) {
                    affinityAnchor = "forward";
                    affinityFocus = isCollapsed ? affinityAnchor : "backward";
                } else {
                    affinityAnchor = "backward";
                    affinityFocus = isCollapsed ? affinityAnchor : "forward";
                }
            } else if (affinity === "outward") {
                if (Range.isForward(r)) {
                    affinityAnchor = "backward";
                    affinityFocus = "forward";
                } else {
                    affinityAnchor = "forward";
                    affinityFocus = "backward";
                }
            } else {
                affinityAnchor = affinity;
                affinityFocus = affinity;
            }
            var anchor = Point.transform(r.anchor, op, {
                affinity: affinityAnchor
            });
            var focus = Point.transform(r.focus, op, {
                affinity: affinityFocus
            });
            if (!anchor || !focus) {
                return null;
            }
            r.anchor = anchor;
            r.focus = focus;
        });
    }
};
var isElement = (value)=>{
    return isPlainObject(value) && Node2.isNodeList(value.children) && !Editor.isEditor(value);
};
var Element = {
    isAncestor (value) {
        return isPlainObject(value) && Node2.isNodeList(value.children);
    },
    isElement,
    isElementList (value) {
        return Array.isArray(value) && value.every((val)=>Element.isElement(val));
    },
    isElementProps (props) {
        return props.children !== void 0;
    },
    isElementType: function isElementType(value, elementVal) {
        var elementKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
        return isElement(value) && value[elementKey] === elementVal;
    },
    matches (element, props) {
        for(var key in props){
            if (key === "children") {
                continue;
            }
            if (element[key] !== props[key]) {
                return false;
            }
        }
        return true;
    }
};
var _excluded$3 = [
    "children"
];
var _excluded2$3 = [
    "text"
];
var IS_NODE_LIST_CACHE = /* @__PURE__ */ new WeakMap();
var Node2 = {
    ancestor (root, path) {
        var node = Node2.get(root, path);
        if (Text.isText(node)) {
            throw new Error("Cannot get the ancestor node at path [".concat(path, "] because it refers to a text node instead: ").concat(Scrubber.stringify(node)));
        }
        return node;
    },
    ancestors (root, path) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return function*() {
            for (var p of Path.ancestors(path, options)){
                var n = Node2.ancestor(root, p);
                var entry = [
                    n,
                    p
                ];
                yield entry;
            }
        }();
    },
    child (root, index) {
        if (Text.isText(root)) {
            throw new Error("Cannot get the child of a text node: ".concat(Scrubber.stringify(root)));
        }
        var c = root.children[index];
        if (c == null) {
            throw new Error("Cannot get child at index `".concat(index, "` in node: ").concat(Scrubber.stringify(root)));
        }
        return c;
    },
    children (root, path) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return function*() {
            var { reverse = false } = options;
            var ancestor = Node2.ancestor(root, path);
            var { children } = ancestor;
            var index = reverse ? children.length - 1 : 0;
            while(reverse ? index >= 0 : index < children.length){
                var child = Node2.child(ancestor, index);
                var childPath = path.concat(index);
                yield [
                    child,
                    childPath
                ];
                index = reverse ? index - 1 : index + 1;
            }
        }();
    },
    common (root, path, another) {
        var p = Path.common(path, another);
        var n = Node2.get(root, p);
        return [
            n,
            p
        ];
    },
    descendant (root, path) {
        var node = Node2.get(root, path);
        if (Editor.isEditor(node)) {
            throw new Error("Cannot get the descendant node at path [".concat(path, "] because it refers to the root editor node instead: ").concat(Scrubber.stringify(node)));
        }
        return node;
    },
    descendants (root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function*() {
            for (var [node, path] of Node2.nodes(root, options)){
                if (path.length !== 0) {
                    yield [
                        node,
                        path
                    ];
                }
            }
        }();
    },
    elements (root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function*() {
            for (var [node, path] of Node2.nodes(root, options)){
                if (Element.isElement(node)) {
                    yield [
                        node,
                        path
                    ];
                }
            }
        }();
    },
    extractProps (node) {
        if (Element.isAncestor(node)) {
            var properties = _objectWithoutProperties(node, _excluded$3);
            return properties;
        } else {
            var properties = _objectWithoutProperties(node, _excluded2$3);
            return properties;
        }
    },
    first (root, path) {
        var p = path.slice();
        var n = Node2.get(root, p);
        while(n){
            if (Text.isText(n) || n.children.length === 0) {
                break;
            } else {
                n = n.children[0];
                p.push(0);
            }
        }
        return [
            n,
            p
        ];
    },
    fragment (root, range) {
        if (Text.isText(root)) {
            throw new Error("Cannot get a fragment starting from a root text node: ".concat(Scrubber.stringify(root)));
        }
        var newRoot = produce({
            children: root.children
        }, (r)=>{
            var [start, end] = Range.edges(range);
            var nodeEntries = Node2.nodes(r, {
                reverse: true,
                pass: (_ref)=>{
                    var [, path2] = _ref;
                    return !Range.includes(range, path2);
                }
            });
            for (var [, path] of nodeEntries){
                if (!Range.includes(range, path)) {
                    var parent = Node2.parent(r, path);
                    var index = path[path.length - 1];
                    parent.children.splice(index, 1);
                }
                if (Path.equals(path, end.path)) {
                    var leaf = Node2.leaf(r, path);
                    leaf.text = leaf.text.slice(0, end.offset);
                }
                if (Path.equals(path, start.path)) {
                    var _leaf = Node2.leaf(r, path);
                    _leaf.text = _leaf.text.slice(start.offset);
                }
            }
            if (Editor.isEditor(r)) {
                r.selection = null;
            }
        });
        return newRoot.children;
    },
    get (root, path) {
        var node = Node2.getIf(root, path);
        if (node === void 0) {
            throw new Error("Cannot find a descendant at path [".concat(path, "] in node: ").concat(Scrubber.stringify(root)));
        }
        return node;
    },
    getIf (root, path) {
        var node = root;
        for(var i = 0; i < path.length; i++){
            var p = path[i];
            if (Text.isText(node) || !node.children[p]) {
                return;
            }
            node = node.children[p];
        }
        return node;
    },
    has (root, path) {
        var node = root;
        for(var i = 0; i < path.length; i++){
            var p = path[i];
            if (Text.isText(node) || !node.children[p]) {
                return false;
            }
            node = node.children[p];
        }
        return true;
    },
    isNode (value) {
        return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);
    },
    isNodeList (value) {
        if (!Array.isArray(value)) {
            return false;
        }
        var cachedResult = IS_NODE_LIST_CACHE.get(value);
        if (cachedResult !== void 0) {
            return cachedResult;
        }
        var isNodeList = value.every((val)=>Node2.isNode(val));
        IS_NODE_LIST_CACHE.set(value, isNodeList);
        return isNodeList;
    },
    last (root, path) {
        var p = path.slice();
        var n = Node2.get(root, p);
        while(n){
            if (Text.isText(n) || n.children.length === 0) {
                break;
            } else {
                var i = n.children.length - 1;
                n = n.children[i];
                p.push(i);
            }
        }
        return [
            n,
            p
        ];
    },
    leaf (root, path) {
        var node = Node2.get(root, path);
        if (!Text.isText(node)) {
            throw new Error("Cannot get the leaf node at path [".concat(path, "] because it refers to a non-leaf node: ").concat(Scrubber.stringify(node)));
        }
        return node;
    },
    levels (root, path) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return function*() {
            for (var p of Path.levels(path, options)){
                var n = Node2.get(root, p);
                yield [
                    n,
                    p
                ];
            }
        }();
    },
    matches (node, props) {
        return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);
    },
    nodes (root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function*() {
            var { pass, reverse = false } = options;
            var { from = [], to } = options;
            var visited = /* @__PURE__ */ new Set();
            var p = [];
            var n = root;
            while(true){
                if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {
                    break;
                }
                if (!visited.has(n)) {
                    yield [
                        n,
                        p
                    ];
                }
                if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([
                    n,
                    p
                ]) === false)) {
                    visited.add(n);
                    var nextIndex = reverse ? n.children.length - 1 : 0;
                    if (Path.isAncestor(p, from)) {
                        nextIndex = from[p.length];
                    }
                    p = p.concat(nextIndex);
                    n = Node2.get(root, p);
                    continue;
                }
                if (p.length === 0) {
                    break;
                }
                if (!reverse) {
                    var newPath = Path.next(p);
                    if (Node2.has(root, newPath)) {
                        p = newPath;
                        n = Node2.get(root, p);
                        continue;
                    }
                }
                if (reverse && p[p.length - 1] !== 0) {
                    var _newPath = Path.previous(p);
                    p = _newPath;
                    n = Node2.get(root, p);
                    continue;
                }
                p = Path.parent(p);
                n = Node2.get(root, p);
                visited.add(n);
            }
        }();
    },
    parent (root, path) {
        var parentPath = Path.parent(path);
        var p = Node2.get(root, parentPath);
        if (Text.isText(p)) {
            throw new Error("Cannot get the parent of path [".concat(path, "] because it does not exist in the root."));
        }
        return p;
    },
    string (node) {
        if (Text.isText(node)) {
            return node.text;
        } else {
            return node.children.map(Node2.string).join("");
        }
    },
    texts (root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function*() {
            for (var [node, path] of Node2.nodes(root, options)){
                if (Text.isText(node)) {
                    yield [
                        node,
                        path
                    ];
                }
            }
        }();
    }
};
function ownKeys$c(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$c(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$c(Object(t), true).forEach(function(r2) {
            _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
var Operation = {
    isNodeOperation (value) {
        return Operation.isOperation(value) && value.type.endsWith("_node");
    },
    isOperation (value) {
        if (!isPlainObject(value)) {
            return false;
        }
        switch(value.type){
            case "insert_node":
                return Path.isPath(value.path) && Node2.isNode(value.node);
            case "insert_text":
                return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
            case "merge_node":
                return typeof value.position === "number" && Path.isPath(value.path) && isPlainObject(value.properties);
            case "move_node":
                return Path.isPath(value.path) && Path.isPath(value.newPath);
            case "remove_node":
                return Path.isPath(value.path) && Node2.isNode(value.node);
            case "remove_text":
                return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
            case "set_node":
                return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);
            case "set_selection":
                return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);
            case "split_node":
                return Path.isPath(value.path) && typeof value.position === "number" && isPlainObject(value.properties);
            default:
                return false;
        }
    },
    isOperationList (value) {
        return Array.isArray(value) && value.every((val)=>Operation.isOperation(val));
    },
    isSelectionOperation (value) {
        return Operation.isOperation(value) && value.type.endsWith("_selection");
    },
    isTextOperation (value) {
        return Operation.isOperation(value) && value.type.endsWith("_text");
    },
    inverse (op) {
        switch(op.type){
            case "insert_node":
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: "remove_node"
                    });
                }
            case "insert_text":
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: "remove_text"
                    });
                }
            case "merge_node":
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: "split_node",
                        path: Path.previous(op.path)
                    });
                }
            case "move_node":
                {
                    var { newPath, path } = op;
                    if (Path.equals(newPath, path)) {
                        return op;
                    }
                    if (Path.isSibling(path, newPath)) {
                        return _objectSpread$c(_objectSpread$c({}, op), {}, {
                            path: newPath,
                            newPath: path
                        });
                    }
                    var inversePath = Path.transform(path, op);
                    var inverseNewPath = Path.transform(Path.next(path), op);
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        path: inversePath,
                        newPath: inverseNewPath
                    });
                }
            case "remove_node":
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: "insert_node"
                    });
                }
            case "remove_text":
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: "insert_text"
                    });
                }
            case "set_node":
                {
                    var { properties, newProperties } = op;
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        properties: newProperties,
                        newProperties: properties
                    });
                }
            case "set_selection":
                {
                    var { properties: _properties, newProperties: _newProperties } = op;
                    if (_properties == null) {
                        return _objectSpread$c(_objectSpread$c({}, op), {}, {
                            properties: _newProperties,
                            newProperties: null
                        });
                    } else if (_newProperties == null) {
                        return _objectSpread$c(_objectSpread$c({}, op), {}, {
                            properties: null,
                            newProperties: _properties
                        });
                    } else {
                        return _objectSpread$c(_objectSpread$c({}, op), {}, {
                            properties: _newProperties,
                            newProperties: _properties
                        });
                    }
                }
            case "split_node":
                {
                    return _objectSpread$c(_objectSpread$c({}, op), {}, {
                        type: "merge_node",
                        path: Path.next(op.path)
                    });
                }
        }
    }
};
var IS_EDITOR_CACHE = /* @__PURE__ */ new WeakMap();
var isEditor = (value)=>{
    var cachedIsEditor = IS_EDITOR_CACHE.get(value);
    if (cachedIsEditor !== void 0) {
        return cachedIsEditor;
    }
    if (!isPlainObject(value)) {
        return false;
    }
    var isEditor2 = typeof value.addMark === "function" && typeof value.apply === "function" && typeof value.deleteFragment === "function" && typeof value.insertBreak === "function" && typeof value.insertSoftBreak === "function" && typeof value.insertFragment === "function" && typeof value.insertNode === "function" && typeof value.insertText === "function" && typeof value.isElementReadOnly === "function" && typeof value.isInline === "function" && typeof value.isSelectable === "function" && typeof value.isVoid === "function" && typeof value.normalizeNode === "function" && typeof value.onChange === "function" && typeof value.removeMark === "function" && typeof value.getDirtyPaths === "function" && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node2.isNodeList(value.children) && Operation.isOperationList(value.operations);
    IS_EDITOR_CACHE.set(value, isEditor2);
    return isEditor2;
};
var Editor = {
    above (editor, options) {
        return editor.above(options);
    },
    addMark (editor, key, value) {
        editor.addMark(key, value);
    },
    after (editor, at, options) {
        return editor.after(at, options);
    },
    before (editor, at, options) {
        return editor.before(at, options);
    },
    deleteBackward (editor) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var { unit = "character" } = options;
        editor.deleteBackward(unit);
    },
    deleteForward (editor) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var { unit = "character" } = options;
        editor.deleteForward(unit);
    },
    deleteFragment (editor, options) {
        editor.deleteFragment(options);
    },
    edges (editor, at) {
        return editor.edges(at);
    },
    elementReadOnly (editor) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return editor.elementReadOnly(options);
    },
    end (editor, at) {
        return editor.end(at);
    },
    first (editor, at) {
        return editor.first(at);
    },
    fragment (editor, at) {
        return editor.fragment(at);
    },
    hasBlocks (editor, element) {
        return editor.hasBlocks(element);
    },
    hasInlines (editor, element) {
        return editor.hasInlines(element);
    },
    hasPath (editor, path) {
        return editor.hasPath(path);
    },
    hasTexts (editor, element) {
        return editor.hasTexts(element);
    },
    insertBreak (editor) {
        editor.insertBreak();
    },
    insertFragment (editor, fragment, options) {
        editor.insertFragment(fragment, options);
    },
    insertNode (editor, node) {
        editor.insertNode(node);
    },
    insertSoftBreak (editor) {
        editor.insertSoftBreak();
    },
    insertText (editor, text) {
        editor.insertText(text);
    },
    isBlock (editor, value) {
        return editor.isBlock(value);
    },
    isEdge (editor, point, at) {
        return editor.isEdge(point, at);
    },
    isEditor (value) {
        return isEditor(value);
    },
    isElementReadOnly (editor, element) {
        return editor.isElementReadOnly(element);
    },
    isEmpty (editor, element) {
        return editor.isEmpty(element);
    },
    isEnd (editor, point, at) {
        return editor.isEnd(point, at);
    },
    isInline (editor, value) {
        return editor.isInline(value);
    },
    isNormalizing (editor) {
        return editor.isNormalizing();
    },
    isSelectable (editor, value) {
        return editor.isSelectable(value);
    },
    isStart (editor, point, at) {
        return editor.isStart(point, at);
    },
    isVoid (editor, value) {
        return editor.isVoid(value);
    },
    last (editor, at) {
        return editor.last(at);
    },
    leaf (editor, at, options) {
        return editor.leaf(at, options);
    },
    levels (editor, options) {
        return editor.levels(options);
    },
    marks (editor) {
        return editor.getMarks();
    },
    next (editor, options) {
        return editor.next(options);
    },
    node (editor, at, options) {
        return editor.node(at, options);
    },
    nodes (editor, options) {
        return editor.nodes(options);
    },
    normalize (editor, options) {
        editor.normalize(options);
    },
    parent (editor, at, options) {
        return editor.parent(at, options);
    },
    path (editor, at, options) {
        return editor.path(at, options);
    },
    pathRef (editor, path, options) {
        return editor.pathRef(path, options);
    },
    pathRefs (editor) {
        return editor.pathRefs();
    },
    point (editor, at, options) {
        return editor.point(at, options);
    },
    pointRef (editor, point, options) {
        return editor.pointRef(point, options);
    },
    pointRefs (editor) {
        return editor.pointRefs();
    },
    positions (editor, options) {
        return editor.positions(options);
    },
    previous (editor, options) {
        return editor.previous(options);
    },
    range (editor, at, to) {
        return editor.range(at, to);
    },
    rangeRef (editor, range, options) {
        return editor.rangeRef(range, options);
    },
    rangeRefs (editor) {
        return editor.rangeRefs();
    },
    removeMark (editor, key) {
        editor.removeMark(key);
    },
    setNormalizing (editor, isNormalizing) {
        editor.setNormalizing(isNormalizing);
    },
    start (editor, at) {
        return editor.start(at);
    },
    string (editor, at, options) {
        return editor.string(at, options);
    },
    unhangRange (editor, range, options) {
        return editor.unhangRange(range, options);
    },
    void (editor, options) {
        return editor.void(options);
    },
    withoutNormalizing (editor, fn) {
        editor.withoutNormalizing(fn);
    },
    shouldMergeNodesRemovePrevNode: (editor, prevNode, curNode)=>{
        return editor.shouldMergeNodesRemovePrevNode(prevNode, curNode);
    }
};
function ownKeys$b(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$b(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$b(Object(t), true).forEach(function(r2) {
            _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
var Point = {
    compare (point, another) {
        var result = Path.compare(point.path, another.path);
        if (result === 0) {
            if (point.offset < another.offset) return -1;
            if (point.offset > another.offset) return 1;
            return 0;
        }
        return result;
    },
    isAfter (point, another) {
        return Point.compare(point, another) === 1;
    },
    isBefore (point, another) {
        return Point.compare(point, another) === -1;
    },
    equals (point, another) {
        return point.offset === another.offset && Path.equals(point.path, another.path);
    },
    isPoint (value) {
        return isPlainObject(value) && typeof value.offset === "number" && Path.isPath(value.path);
    },
    transform (point, op) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return produce(point, (p)=>{
            if (p === null) {
                return null;
            }
            var { affinity = "forward" } = options;
            var { path, offset } = p;
            switch(op.type){
                case "insert_node":
                case "move_node":
                    {
                        p.path = Path.transform(path, op, options);
                        break;
                    }
                case "insert_text":
                    {
                        if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === "forward")) {
                            p.offset += op.text.length;
                        }
                        break;
                    }
                case "merge_node":
                    {
                        if (Path.equals(op.path, path)) {
                            p.offset += op.position;
                        }
                        p.path = Path.transform(path, op, options);
                        break;
                    }
                case "remove_text":
                    {
                        if (Path.equals(op.path, path) && op.offset <= offset) {
                            p.offset -= Math.min(offset - op.offset, op.text.length);
                        }
                        break;
                    }
                case "remove_node":
                    {
                        if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {
                            return null;
                        }
                        p.path = Path.transform(path, op, options);
                        break;
                    }
                case "split_node":
                    {
                        if (Path.equals(op.path, path)) {
                            if (op.position === offset && affinity == null) {
                                return null;
                            } else if (op.position < offset || op.position === offset && affinity === "forward") {
                                p.offset -= op.position;
                                p.path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {
                                    affinity: "forward"
                                }));
                            }
                        } else {
                            p.path = Path.transform(path, op, options);
                        }
                        break;
                    }
            }
        });
    }
};
var _scrubber = void 0;
var Scrubber = {
    setScrubber (scrubber) {
        _scrubber = scrubber;
    },
    stringify (value) {
        return JSON.stringify(value, _scrubber);
    }
};
var _excluded$2 = [
    "text"
];
var _excluded2$2 = [
    "anchor",
    "focus",
    "merge"
];
function ownKeys$a(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$a(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$a(Object(t), true).forEach(function(r2) {
            _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
var Text = {
    equals (text, another) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var { loose = false } = options;
        function omitText(obj) {
            var rest = _objectWithoutProperties(obj, _excluded$2);
            return rest;
        }
        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);
    },
    isText (value) {
        return isPlainObject(value) && typeof value.text === "string";
    },
    isTextList (value) {
        return Array.isArray(value) && value.every((val)=>Text.isText(val));
    },
    isTextProps (props) {
        return props.text !== void 0;
    },
    matches (text, props) {
        for(var key in props){
            if (key === "text") {
                continue;
            }
            if (!text.hasOwnProperty(key) || text[key] !== props[key]) {
                return false;
            }
        }
        return true;
    },
    decorations (node, decorations) {
        var leaves = [
            {
                leaf: _objectSpread$a({}, node)
            }
        ];
        for (var dec of decorations){
            var { anchor, focus, merge: mergeDecoration } = dec, rest = _objectWithoutProperties(dec, _excluded2$2);
            var [start, end] = Range.edges(dec);
            var next = [];
            var leafEnd = 0;
            var decorationStart = start.offset;
            var decorationEnd = end.offset;
            var merge4 = mergeDecoration !== null && mergeDecoration !== void 0 ? mergeDecoration : Object.assign;
            for (var { leaf } of leaves){
                var { length } = leaf.text;
                var leafStart = leafEnd;
                leafEnd += length;
                if (decorationStart <= leafStart && leafEnd <= decorationEnd) {
                    merge4(leaf, rest);
                    next.push({
                        leaf
                    });
                    continue;
                }
                if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {
                    next.push({
                        leaf
                    });
                    continue;
                }
                var middle = leaf;
                var before = void 0;
                var after = void 0;
                if (decorationEnd < leafEnd) {
                    var off = decorationEnd - leafStart;
                    after = {
                        leaf: _objectSpread$a(_objectSpread$a({}, middle), {}, {
                            text: middle.text.slice(off)
                        })
                    };
                    middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {
                        text: middle.text.slice(0, off)
                    });
                }
                if (decorationStart > leafStart) {
                    var _off = decorationStart - leafStart;
                    before = {
                        leaf: _objectSpread$a(_objectSpread$a({}, middle), {}, {
                            text: middle.text.slice(0, _off)
                        })
                    };
                    middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {
                        text: middle.text.slice(_off)
                    });
                }
                merge4(middle, rest);
                if (before) {
                    next.push(before);
                }
                next.push({
                    leaf: middle
                });
                if (after) {
                    next.push(after);
                }
            }
            leaves = next;
        }
        if (leaves.length > 1) {
            var currentOffset = 0;
            for (var [index, item] of leaves.entries()){
                var _start = currentOffset;
                var _end = _start + item.leaf.text.length;
                var position = {
                    start: _start,
                    end: _end
                };
                if (index === 0) position.isFirst = true;
                if (index === leaves.length - 1) position.isLast = true;
                item.position = position;
                currentOffset = _end;
            }
        }
        return leaves;
    }
};
var getDefaultInsertLocation = (editor)=>{
    if (editor.selection) {
        return editor.selection;
    } else if (editor.children.length > 0) {
        return Editor.end(editor, []);
    } else {
        return [
            0
        ];
    }
};
var CodepointType;
(function(CodepointType2) {
    CodepointType2[CodepointType2["None"] = 0] = "None";
    CodepointType2[CodepointType2["Extend"] = 1] = "Extend";
    CodepointType2[CodepointType2["ZWJ"] = 2] = "ZWJ";
    CodepointType2[CodepointType2["RI"] = 4] = "RI";
    CodepointType2[CodepointType2["Prepend"] = 8] = "Prepend";
    CodepointType2[CodepointType2["SpacingMark"] = 16] = "SpacingMark";
    CodepointType2[CodepointType2["L"] = 32] = "L";
    CodepointType2[CodepointType2["V"] = 64] = "V";
    CodepointType2[CodepointType2["T"] = 128] = "T";
    CodepointType2[CodepointType2["LV"] = 256] = "LV";
    CodepointType2[CodepointType2["LVT"] = 512] = "LVT";
    CodepointType2[CodepointType2["ExtPict"] = 1024] = "ExtPict";
    CodepointType2[CodepointType2["Any"] = 2048] = "Any";
})(CodepointType || (CodepointType = {}));
var NonBoundaryPairs = [
    // GB6
    [
        CodepointType.L,
        CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT
    ],
    // GB7
    [
        CodepointType.LV | CodepointType.V,
        CodepointType.V | CodepointType.T
    ],
    // GB8
    [
        CodepointType.LVT | CodepointType.T,
        CodepointType.T
    ],
    // GB9
    [
        CodepointType.Any,
        CodepointType.Extend | CodepointType.ZWJ
    ],
    // GB9a
    [
        CodepointType.Any,
        CodepointType.SpacingMark
    ],
    // GB9b
    [
        CodepointType.Prepend,
        CodepointType.Any
    ],
    // GB11
    [
        CodepointType.ZWJ,
        CodepointType.ExtPict
    ],
    // GB12 and GB13
    [
        CodepointType.RI,
        CodepointType.RI
    ]
];
var TextTransforms = {
    delete (editor, options) {
        editor.delete(options);
    },
    insertFragment (editor, fragment, options) {
        editor.insertFragment(fragment, options);
    },
    insertText (editor, text) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Editor.withoutNormalizing(editor, ()=>{
            var { voids = false } = options;
            var { at = getDefaultInsertLocation(editor) } = options;
            if (Path.isPath(at)) {
                at = Editor.range(editor, at);
            }
            if (Range.isRange(at)) {
                if (Range.isCollapsed(at)) {
                    at = at.anchor;
                } else {
                    var end = Range.end(at);
                    if (!voids && Editor.void(editor, {
                        at: end
                    })) {
                        return;
                    }
                    var start = Range.start(at);
                    var startRef = Editor.pointRef(editor, start);
                    var endRef = Editor.pointRef(editor, end);
                    Transforms.delete(editor, {
                        at,
                        voids
                    });
                    var startPoint = startRef.unref();
                    var endPoint = endRef.unref();
                    at = startPoint || endPoint;
                    Transforms.setSelection(editor, {
                        anchor: at,
                        focus: at
                    });
                }
            }
            if (!voids && Editor.void(editor, {
                at
            }) || Editor.elementReadOnly(editor, {
                at
            })) {
                return;
            }
            var { path, offset } = at;
            if (text.length > 0) editor.apply({
                type: "insert_text",
                path,
                offset,
                text
            });
        });
    }
};
function ownKeys$9(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread$9(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$9(Object(t), true).forEach(function(r2) {
            _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
    }
    return e;
}
var Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);
// src/lib/plugins/affinity/queries/getEdgeNodes.ts
var getEdgeNodes = (editor)=>{
    if (!editor.api.isCollapsed()) return null;
    const cursor = editor.selection.anchor;
    const textRange = editor.api.range(cursor.path);
    if (!textRange) return null;
    const edge = editor.api.isStart(cursor, textRange) ? "start" : editor.api.isEnd(cursor, textRange) ? "end" : null;
    if (!edge) return null;
    const parent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].parent(editor, cursor.path) ?? null;
    const isAffinityInlineElement = (()=>{
        if (!parent || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(parent)) return false;
        const parentAffinity = getPluginByType(editor, parent.type)?.rules.selection?.affinity;
        return parentAffinity === "hard" || parentAffinity === "directional";
    })();
    const nodeEntry = isAffinityInlineElement ? [
        parent,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["PathApi"].parent(cursor.path)
    ] : [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].get(editor, cursor.path),
        cursor.path
    ];
    if (edge === "start" && cursor.path.at(-1) === 0 && !isAffinityInlineElement) {
        return [
            null,
            nodeEntry
        ];
    }
    const siblingPath = edge === "end" ? Path.next(nodeEntry[1]) : Path.previous(nodeEntry[1]);
    const siblingNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].get(editor, siblingPath);
    const siblingEntry = siblingNode ? [
        siblingNode,
        siblingPath
    ] : null;
    return edge === "end" ? [
        nodeEntry,
        siblingEntry
    ] : [
        siblingEntry,
        nodeEntry
    ];
};
;
;
var getMarkBoundaryAffinity = (editor, markBoundary)=>{
    const { marks, selection } = editor;
    if (!selection) return;
    const marksMatchLeaf = (leaf)=>{
        return marks && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].extractProps(leaf), marks) && Object.keys(marks).length > 1;
    };
    const [backwardLeafEntry, forwardLeafEntry] = markBoundary;
    if (!backwardLeafEntry || !forwardLeafEntry) {
        const leafEntry = backwardLeafEntry || forwardLeafEntry;
        const affinityIsTowardsLeaf = !marks || marksMatchLeaf(leafEntry[0]);
        if (affinityIsTowardsLeaf) {
            return leafEntry === backwardLeafEntry ? "backward" : "forward";
        }
        return;
    }
    const marksDirection = marks && (()=>{
        if (backwardLeafEntry && marksMatchLeaf(backwardLeafEntry[0])) return "backward";
        if (forwardLeafEntry && marksMatchLeaf(forwardLeafEntry[0])) return "forward";
        return null;
    })();
    const selectionDirection = selection.anchor.offset === 0 ? "forward" : "backward";
    if (selectionDirection === "backward" && marksDirection === "forward") return "forward";
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_FIREFOX"] && selectionDirection === "forward" && marksDirection !== "backward") return "forward";
    return "backward";
};
;
var isNodeAffinity = (editor, node, affinity)=>{
    const marks = Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].extractProps(node));
    const keys = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(node) ? [
        node.type
    ] : marks;
    return keys.some((type)=>getPluginByType(editor, type)?.rules.selection?.affinity === affinity);
};
var isNodesAffinity = (editor, edgeNodes, affinity)=>{
    const [backwardLeafEntry, forwardLeafEntry] = edgeNodes;
    return backwardLeafEntry && isNodeAffinity(editor, backwardLeafEntry[0], affinity) || forwardLeafEntry && isNodeAffinity(editor, forwardLeafEntry[0], affinity);
};
;
var setAffinitySelection = (editor, edgeNodes, affinity)=>{
    const setMarks = (marks)=>{
        editor.marks = marks;
        editor.api.onChange();
    };
    const select = (point)=>{
        editor.tf.setSelection({
            anchor: point,
            focus: point
        });
    };
    const [before, after] = edgeNodes;
    if (affinity === "backward") {
        if (before === null) {
            setMarks({});
            return;
        }
        const beforeEnd2 = editor.api.end(before[1]);
        if (beforeEnd2) {
            select(beforeEnd2);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(before[0])) return;
        setMarks(null);
        return;
    }
    if (before === null) {
        setMarks(null);
        return;
    }
    if (after === null) {
        setMarks({});
        return;
    }
    const beforeEnd = editor.api.end(before[1]);
    select(beforeEnd);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(after[0])) {
        return;
    } else {
        setMarks(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].extractProps(after[0]));
    }
};
// src/lib/plugins/affinity/AffinityPlugin.ts
var AffinityPlugin = createTSlatePlugin({
    key: "affinity"
}).overrideEditor(({ editor, tf: { deleteBackward, insertText, move } })=>({
        transforms: {
            /**
     * On backspace, if the deletion results in the cursor being at a mark
     * boundary, then the affinity should be forward. If the deletion removes a
     * character from the left mark, then the affinity should be backward.
     */ deleteBackward: (unit)=>{
                const apply = ()=>{
                    if (unit === "character" && editor.api.isCollapsed()) {
                        const [start] = getEdgeNodes(editor) ?? [
                            null
                        ];
                        const startText = start && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["TextApi"].isText(start[0]) ? start[0].text : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].string(start[0]));
                        deleteBackward(unit);
                        const edgeNodes = getEdgeNodes(editor);
                        if (edgeNodes && isNodesAffinity(editor, edgeNodes, "directional") && !hasElement(edgeNodes)) {
                            const affinity = startText && startText.length > 1 ? "backward" : "forward";
                            setAffinitySelection(editor, edgeNodes, affinity);
                        }
                        return true;
                    }
                };
                if (apply()) return;
                deleteBackward(unit);
            },
            insertText (text, options) {
                const applyOutwardAffinity = ()=>{
                    if (!editor.selection || editor.api.isExpanded()) {
                        return;
                    }
                    const textPath = editor.selection.focus.path;
                    const textNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].get(editor, textPath);
                    if (!textNode) {
                        return;
                    }
                    const marks = Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].extractProps(textNode));
                    const outwardMarks = marks.filter((type)=>getPluginByType(editor, type)?.rules.selection?.affinity === "outward");
                    if (!outwardMarks.length || !editor.api.isEnd(editor.selection.focus, textPath)) {
                        return;
                    }
                    const nextPoint = editor.api.start(textPath, {
                        next: true
                    });
                    const marksToRemove = [];
                    let nextTextNode = null;
                    if (nextPoint) {
                        const nextTextPath = nextPoint.path;
                        nextTextNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].get(editor, nextTextPath) || null;
                    }
                    for (const markKey of outwardMarks){
                        if (!textNode[markKey]) {
                            continue;
                        }
                        const isBetweenSameMarks = nextTextNode?.[markKey];
                        if (!isBetweenSameMarks) {
                            marksToRemove.push(markKey);
                        }
                    }
                    if (marksToRemove.length > 0) {
                        editor.tf.removeMarks(marksToRemove);
                    }
                };
                applyOutwardAffinity();
                return insertText(text, options);
            },
            move: (options)=>{
                const apply = ()=>{
                    const { distance = 1, reverse = false, unit = "character" } = options || {};
                    if (unit === "character" && distance === 1 && editor.api.isCollapsed()) {
                        const preEdgeNodes = getEdgeNodes(editor);
                        if (preEdgeNodes && isNodesAffinity(editor, preEdgeNodes, "hard")) {
                            if (preEdgeNodes && preEdgeNodes[reverse ? 0 : 1] === null && getMarkBoundaryAffinity(editor, preEdgeNodes) === (reverse ? "forward" : "backward")) {
                                setAffinitySelection(editor, preEdgeNodes, reverse ? "backward" : "forward");
                                return true;
                            }
                            move({
                                ...options,
                                unit: "offset"
                            });
                            return true;
                        }
                        move(options);
                        const postEdgeNodes = getEdgeNodes(editor);
                        if (postEdgeNodes && isNodesAffinity(editor, postEdgeNodes, "directional") && !hasElement(postEdgeNodes)) {
                            setAffinitySelection(editor, postEdgeNodes, reverse ? "forward" : "backward");
                        }
                        return true;
                    }
                };
                if (apply()) return;
                move(options);
            }
        }
    }));
var hasElement = (edgeNodes)=>{
    const [before, after] = edgeNodes;
    return before && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(before[0]) || after && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(after[0]);
};
// src/lib/plugins/debug/DebugPlugin.ts
var PlateError = class extends Error {
    constructor(message, type = "DEFAULT"){
        super(`[${type}] ${message}`);
        this.type = type;
        this.name = "PlateError";
    }
};
var DebugPlugin = createTSlatePlugin({
    key: "debug",
    options: {
        isProduction: ("TURBOPACK compile-time value", "development") === "production",
        logger: {
            error: (message, type, details)=>console.error(`${type ? `[${type}] ` : ""}${message}`, details),
            info: (message, type, details)=>console.info(`${type ? `[${type}] ` : ""}${message}`, details),
            log: (message, type, details)=>console.log(`${type ? `[${type}] ` : ""}${message}`, details),
            warn: (message, type, details)=>console.warn(`${type ? `[${type}] ` : ""}${message}`, details)
        },
        logLevel: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "log",
        throwErrors: true
    }
}).extendEditorApi(({ getOptions })=>{
    const logLevels = [
        "error",
        "warn",
        "info",
        "log"
    ];
    const log = (level, message, type, details)=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const options = getOptions();
        if (options.isProduction && level === "log") return;
        if (logLevels.indexOf(level) <= logLevels.indexOf(options.logLevel)) {
            if (level === "error" && options.throwErrors) {
                throw new PlateError(message, type);
            } else {
                options.logger[level]?.(message, type, details);
            }
        }
    };
    return {
        debug: {
            error: (message, type, details)=>log("error", message, type, details),
            info: (message, type, details)=>log("info", message, type, details),
            log: (message, type, details)=>log("log", message, type, details),
            warn: (message, type, details)=>log("warn", message, type, details)
        }
    };
});
;
;
;
var withScrolling = (editor, fn, options)=>{
    const prevOptions = editor.getOptions(DOMPlugin);
    const prevAutoScroll = AUTO_SCROLL.get(editor) ?? false;
    if (options) {
        const ops = {
            ...prevOptions,
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omitBy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
        };
        editor.setOptions(DOMPlugin, ops);
    }
    AUTO_SCROLL.set(editor, true);
    fn();
    AUTO_SCROLL.set(editor, prevAutoScroll);
    editor.setOptions(DOMPlugin, prevOptions);
};
// src/lib/plugins/dom/DOMPlugin.ts
var AUTO_SCROLL = /* @__PURE__ */ new WeakMap();
var DOMPlugin = createTSlatePlugin({
    key: "dom",
    options: {
        scrollMode: "last",
        scrollOperations: {
            insert_node: true,
            insert_text: true
        },
        scrollOptions: {
            scrollMode: "if-needed"
        }
    }
}).extendEditorApi(({ editor })=>({
        isScrolling: ()=>{
            return AUTO_SCROLL.get(editor) ?? false;
        }
    })).extendEditorTransforms(({ editor })=>({
        withScrolling: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bindFirst"])(withScrolling, editor)
    })).overrideEditor(({ api, editor, getOption, tf: { apply } })=>({
        transforms: {
            apply (operation) {
                if (api.isScrolling()) {
                    apply(operation);
                    const scrollOperations = getOption("scrollOperations");
                    if (!scrollOperations[operation.type]) return;
                    const matched = editor.operations.filter((op)=>!!scrollOperations[op.type]);
                    if (matched.length === 0) return;
                    const mode = getOption("scrollMode");
                    const targetOp = mode === "first" ? matched[0] : matched.at(-1);
                    if (!targetOp) return;
                    const { offset, path } = targetOp.path ? targetOp : {};
                    if (!path) return;
                    const scrollOptions = getOption("scrollOptions");
                    const scrollTarget = {
                        offset: offset ?? 0,
                        path
                    };
                    api.scrollIntoView(scrollTarget, scrollOptions);
                    return;
                }
                return apply(operation);
            }
        }
    })).overrideEditor(({ editor, tf: { apply } })=>({
        transforms: {
            apply (operation) {
                if (operation.type === "set_selection") {
                    const { properties } = operation;
                    editor.dom.prevSelection = properties;
                    apply(operation);
                    editor.dom.currentKeyboardEvent = null;
                    return;
                }
                apply(operation);
            }
        }
    }));
;
// src/lib/plugins/html/constants.ts
var CARRIAGE_RETURN = "\r";
var LINE_FEED = "\n";
var NO_BREAK_SPACE = "\xA0";
var SPACE = " ";
var TAB = "	";
var ZERO_WIDTH_SPACE = "\u200B";
// src/lib/plugins/html/utils/isHtmlElement.ts
var isHtmlElement = (node)=>node.nodeType === Node.ELEMENT_NODE;
// src/lib/plugins/html/utils/traverseHtmlNode.ts
var traverseHtmlNode = (node, callback)=>{
    const keepTraversing = callback(node);
    if (!keepTraversing) {
        return;
    }
    let child = node.firstChild;
    while(child){
        const currentChild = child;
        const previousChild = child.previousSibling;
        child = child.nextSibling;
        traverseHtmlNode(currentChild, callback);
        if (// An unwrap was made. Need to compute the next child again.
        !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && previousChild !== child.previousSibling && child.parentNode) {
            child = previousChild ? previousChild.nextSibling : node.firstChild;
        } else if (// A list was created. Need to compute the next child again.
        !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && !child.previousSibling && !child.nextSibling && !child.parentNode) {
            if (previousChild) {
                child = previousChild.nextSibling ? previousChild.nextSibling.nextSibling : null;
            } else if (node.firstChild) {
                child = node.firstChild.nextSibling;
            }
        }
    }
};
// src/lib/plugins/html/utils/traverseHtmlElements.ts
var traverseHtmlElements = (rootNode, callback)=>{
    traverseHtmlNode(rootNode, (node)=>{
        if (!isHtmlElement(node)) {
            return true;
        }
        return callback(node);
    });
};
// src/lib/plugins/html/utils/cleanHtmlBrElements.ts
var cleanHtmlBrElements = (rootNode)=>{
    traverseHtmlElements(rootNode, (element)=>{
        if (element.tagName !== "BR") {
            return true;
        }
        const replacementTextNode = document.createTextNode(LINE_FEED);
        if (element.parentElement) {
            element.parentElement.replaceChild(replacementTextNode, element);
        }
        return false;
    });
};
// src/lib/plugins/html/utils/cleanHtmlCrLf.ts
var cleanHtmlCrLf = (html)=>{
    return html.replaceAll(/\r\n|\r/g, "\n");
};
// src/lib/plugins/html/utils/cleanHtmlEmptyElements.ts
var ALLOWED_EMPTY_ELEMENTS = /* @__PURE__ */ new Set([
    "BR",
    "IMG",
    "TD",
    "TH"
]);
var isEmpty = (element)=>{
    return !ALLOWED_EMPTY_ELEMENTS.has(element.nodeName) && !element.innerHTML.trim();
};
var removeIfEmpty = (element)=>{
    if (isEmpty(element)) {
        const { parentElement } = element;
        element.remove();
        if (parentElement) {
            removeIfEmpty(parentElement);
        }
    }
};
var cleanHtmlEmptyElements = (rootNode)=>{
    traverseHtmlElements(rootNode, (element)=>{
        removeIfEmpty(element);
        return true;
    });
};
// src/lib/plugins/html/utils/replaceTagName.ts
var replaceTagName = (element, tagName)=>{
    const newElement = document.createElement(tagName);
    newElement.innerHTML = element.innerHTML;
    for (const { name } of element.attributes){
        const value = element.getAttribute(name);
        if (value) {
            newElement.setAttribute(name, value);
        }
    }
    if (element.parentNode) {
        element.parentNode.replaceChild(newElement, element);
    }
    return newElement;
};
// src/lib/plugins/html/utils/cleanHtmlFontElements.ts
var cleanHtmlFontElements = (rootNode)=>{
    traverseHtmlElements(rootNode, (element)=>{
        if (element.tagName === "FONT") {
            if (element.textContent) {
                replaceTagName(element, "span");
            } else {
                element.remove();
            }
        }
        return true;
    });
};
// src/lib/plugins/html/utils/isHtmlFragmentHref.ts
var isHtmlFragmentHref = (href)=>href.startsWith("#");
// src/lib/plugins/html/utils/unwrapHtmlElement.ts
var unwrapHtmlElement = (element)=>{
    element.outerHTML = element.innerHTML;
};
// src/lib/plugins/html/utils/cleanHtmlLinkElements.ts
var cleanHtmlLinkElements = (rootNode)=>{
    traverseHtmlElements(rootNode, (element)=>{
        if (element.tagName !== "A") {
            return true;
        }
        const href = element.getAttribute("href");
        if (!href || isHtmlFragmentHref(href)) {
            unwrapHtmlElement(element);
        }
        if (href && element.querySelector("img")) {
            for (const span of element.querySelectorAll("span")){
                if (!span.textContent) {
                    unwrapHtmlElement(span);
                }
            }
        }
        return true;
    });
};
// src/lib/plugins/html/utils/isHtmlText.ts
var isHtmlText = (node)=>node.nodeType === Node.TEXT_NODE;
// src/lib/plugins/html/utils/traverseHtmlTexts.ts
var traverseHtmlTexts = (rootNode, callback)=>{
    traverseHtmlNode(rootNode, (node)=>{
        if (!isHtmlText(node)) {
            return true;
        }
        return callback(node);
    });
};
// src/lib/plugins/html/utils/cleanHtmlTextNodes.ts
var cleanHtmlTextNodes = (rootNode)=>{
    traverseHtmlTexts(rootNode, (textNode)=>{
        if (/^\n\s*$/.test(textNode.data) && (textNode.previousElementSibling || textNode.nextElementSibling)) {
            textNode.remove();
            return true;
        }
        textNode.data = textNode.data.replaceAll(/\n\s*/g, "\n");
        if (textNode.data.includes(CARRIAGE_RETURN) || textNode.data.includes(LINE_FEED) || textNode.data.includes(NO_BREAK_SPACE)) {
            const hasSpace = textNode.data.includes(SPACE);
            const hasNonWhitespace = /\S/.test(textNode.data);
            const hasLineFeed = textNode.data.includes(LINE_FEED);
            if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {
                if (textNode.data === NO_BREAK_SPACE) {
                    textNode.data = SPACE;
                    return true;
                }
                textNode.remove();
                return true;
            }
            if (textNode.previousSibling && textNode.previousSibling.nodeName === "BR" && textNode.parentElement) {
                textNode.previousSibling.remove();
                const matches = /^[\n\r]+/.exec(textNode.data);
                const offset = matches ? matches[0].length : 0;
                textNode.data = textNode.data.slice(Math.max(0, offset)).replaceAll(new RegExp(LINE_FEED, "g"), SPACE).replaceAll(new RegExp(CARRIAGE_RETURN, "g"), SPACE);
                textNode.data = `
${textNode.data}`;
            } else {
                textNode.data = textNode.data.replaceAll(new RegExp(LINE_FEED, "g"), SPACE).replaceAll(new RegExp(CARRIAGE_RETURN, "g"), SPACE);
            }
        }
        return true;
    });
};
// src/lib/plugins/html/utils/inlineTagNames.ts
var inlineTagNames = /* @__PURE__ */ new Set([
    "A",
    "ABBR",
    "ACRONYM",
    "B",
    "BDI",
    "BDO",
    "BIG",
    "BR",
    "BUTTON",
    "CANVAS",
    "CITE",
    "CODE",
    "CONTENT",
    "DATA",
    "DEL",
    "DFN",
    "EM",
    "EMBED",
    "FONT",
    "I",
    "IFRAME",
    "IMG",
    "IMG",
    "INPUT",
    "INS",
    "KBD",
    "LABEL",
    "MAP",
    "MARK",
    "MARQUEE",
    "math",
    "MENUITEM",
    "METER",
    "NOBR",
    "OBJECT",
    "OUTPUT",
    "PICTURE",
    "PORTAL",
    "PROGRESS",
    "Q",
    "S",
    "SAMP",
    "SELECT",
    "SHADOW",
    "SMALL",
    "SOURCE",
    "SPAN",
    "STRIKE",
    "STRONG",
    "SUB",
    "SUP",
    "svg",
    "TEXTAREA",
    "TIME",
    "TRACK",
    "TT",
    "U",
    "VAR",
    "VIDEO",
    "WBR"
]);
// src/lib/plugins/html/utils/isHtmlInlineElement.ts
var isHtmlInlineElement = (node)=>{
    if (!isHtmlElement(node)) return false;
    const element = node;
    const tagNameIsInline = inlineTagNames.has(element.tagName);
    const displayProperty = element.style.display.split(" ")[0];
    if (displayProperty === "") {
        return tagNameIsInline;
    }
    if (displayProperty.startsWith("inline")) {
        return true;
    }
    if (displayProperty === "inherit" && element.parentElement) {
        return isHtmlInlineElement(element.parentElement);
    }
    if ([
        "contents",
        "initial",
        "none",
        "revert",
        "revert-layer",
        "unset"
    ].includes(displayProperty)) {
        return tagNameIsInline;
    }
    return false;
};
// src/lib/plugins/html/utils/isHtmlBlockElement.ts
var isHtmlBlockElement = (node)=>{
    if (!isHtmlElement(node)) return false;
    const element = node;
    return !isHtmlInlineElement(element);
};
// src/lib/plugins/html/utils/isHtmlTable.ts
var isHtmlTable = (element)=>element.nodeName === "TABLE";
// src/lib/plugins/html/utils/copyBlockMarksToSpanChild.ts
var copyBlockMarksToSpanChild = (rootNode)=>{
    traverseHtmlElements(rootNode, (element)=>{
        const el = element;
        const styleAttribute = element.getAttribute("style");
        if (!styleAttribute) return true;
        if (isHtmlBlockElement(el) && !isHtmlTable(el)) {
            const { style: { backgroundColor, color, fontFamily, fontSize, fontStyle, fontWeight, textDecoration } } = el;
            if (backgroundColor || color || fontFamily || fontSize || fontStyle || fontWeight || textDecoration) {
                const span = document.createElement("span");
                if (![
                    "inherit",
                    "initial"
                ].includes(color)) {
                    span.style.color = color;
                }
                span.style.fontFamily = fontFamily;
                span.style.fontSize = fontSize;
                if (![
                    "inherit",
                    "initial",
                    "normal"
                ].includes(color)) {
                    span.style.fontStyle = fontStyle;
                }
                if (![
                    400,
                    "normal"
                ].includes(fontWeight)) {
                    span.style.fontWeight = fontWeight;
                }
                span.style.textDecoration = textDecoration;
                span.innerHTML = el.innerHTML;
                element.innerHTML = span.outerHTML;
            }
        }
        return true;
    });
};
// src/lib/plugins/html/utils/collapse-white-space/collapseString.ts
var collapseString = (text, { shouldCollapseWhiteSpace = true, trimEnd = "collapse", trimStart = "collapse", whiteSpaceIncludesNewlines = true } = {})=>{
    if (trimStart === "all") {
        text = text.replace(/^\s+/, "");
    }
    if (trimEnd === "single-newline") {
        text = text.replace(/\n$/, "");
    }
    if (shouldCollapseWhiteSpace) {
        if (whiteSpaceIncludesNewlines) {
            text = text.replaceAll(/\s+/g, " ");
        } else {
            text = text.replaceAll(/[^\S\n\r]+/g, " ");
            text = text.replaceAll(/^[^\S\n\r]+/gm, "");
            text = text.replaceAll(/[^\S\n\r]+$/gm, "");
        }
    }
    return text;
};
// src/lib/plugins/html/utils/collapse-white-space/isLastNonEmptyTextOfInlineFormattingContext.ts
var isLastNonEmptyTextOfInlineFormattingContext = (initialText)=>{
    let currentNode = initialText;
    while(true){
        if (currentNode.nextSibling) {
            currentNode = currentNode.nextSibling;
        } else {
            currentNode = currentNode.parentElement;
            if (currentNode && isHtmlBlockElement(currentNode)) {
                return true;
            }
            currentNode = currentNode?.nextSibling || null;
        }
        if (!currentNode) {
            return true;
        }
        if (isHtmlBlockElement(currentNode)) {
            return true;
        }
        if ((currentNode.textContent || "").length > 0) {
            return false;
        }
    }
};
// src/lib/plugins/html/utils/collapse-white-space/stateTransforms.ts
var upsertInlineFormattingContext = (state)=>{
    if (state.inlineFormattingContext) {
        state.inlineFormattingContext.atStart = false;
    } else {
        state.inlineFormattingContext = {
            atStart: true,
            lastHasTrailingWhiteSpace: false
        };
    }
};
var endInlineFormattingContext = (state)=>{
    state.inlineFormattingContext = null;
};
// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceText.ts
var collapseWhiteSpaceText = (text, state)=>{
    const textContent = text.textContent || "";
    const isWhiteSpaceOnly = textContent.trim() === "";
    if (state.inlineFormattingContext || !isWhiteSpaceOnly) {
        upsertInlineFormattingContext(state);
    }
    const { whiteSpaceRule } = state;
    const trimStart = (()=>{
        if (whiteSpaceRule !== "normal") return "collapse";
        if (!state.inlineFormattingContext || state.inlineFormattingContext.atStart || state.inlineFormattingContext.lastHasTrailingWhiteSpace) return "all";
        return "collapse";
    })();
    const trimEnd = (()=>{
        if (whiteSpaceRule === "normal") return "collapse";
        if (isLastNonEmptyTextOfInlineFormattingContext(text)) return "single-newline";
        return "collapse";
    })();
    const shouldCollapseWhiteSpace = {
        normal: true,
        pre: false,
        "pre-line": true
    }[whiteSpaceRule];
    const whiteSpaceIncludesNewlines = whiteSpaceRule !== "pre-line";
    const collapsedTextContent = collapseString(textContent || "", {
        shouldCollapseWhiteSpace,
        trimEnd,
        trimStart,
        whiteSpaceIncludesNewlines
    });
    if (state.inlineFormattingContext && shouldCollapseWhiteSpace) {
        state.inlineFormattingContext.lastHasTrailingWhiteSpace = collapsedTextContent.endsWith(" ");
    }
    text.textContent = collapsedTextContent;
};
// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceNode.ts
var collapseWhiteSpaceNode = (node, state)=>{
    if (isHtmlElement(node)) {
        collapseWhiteSpaceElement(node, state);
        return;
    }
    if (isHtmlText(node)) {
        collapseWhiteSpaceText(node, state);
        return;
    }
    collapseWhiteSpaceChildren(node, state);
};
// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceChildren.ts
var collapseWhiteSpaceChildren = (node, state)=>{
    const childNodes = Array.from(node.childNodes);
    for (const childNode of childNodes){
        collapseWhiteSpaceNode(childNode, state);
    }
};
// src/lib/plugins/html/utils/collapse-white-space/inferWhiteSpaceRule.ts
var inferWhiteSpaceRule = (element)=>{
    const whiteSpaceProperty = element.style.whiteSpace;
    switch(whiteSpaceProperty){
        case "break-spaces":
        case "pre":
        case "pre-wrap":
            {
                return "pre";
            }
        case "normal":
        case "nowrap":
            {
                return "normal";
            }
        case "pre-line":
            {
                return "pre-line";
            }
    }
    if (element.tagName === "PRE") {
        return "pre";
    }
    if (whiteSpaceProperty === "initial") {
        return "normal";
    }
    return null;
};
// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceElement.ts
var collapseWhiteSpaceElement = (element, state)=>{
    const isInlineElement = isHtmlInlineElement(element);
    const previousWhiteSpaceRule = state.whiteSpaceRule;
    const inferredWhiteSpaceRule = inferWhiteSpaceRule(element);
    if (inferredWhiteSpaceRule) {
        state.whiteSpaceRule = inferredWhiteSpaceRule;
    }
    if (!isInlineElement) {
        endInlineFormattingContext(state);
    }
    collapseWhiteSpaceChildren(element, state);
    if (!isInlineElement) {
        endInlineFormattingContext(state);
    }
    state.whiteSpaceRule = previousWhiteSpaceRule;
};
// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpace.ts
var collapseWhiteSpace = (element)=>{
    const clonedElement = element.cloneNode(true);
    const state = {
        inlineFormattingContext: null,
        whiteSpaceRule: "normal"
    };
    collapseWhiteSpaceElement(clonedElement, state);
    return clonedElement;
};
;
// src/lib/plugins/html/utils/deserializeHtmlNodeChildren.ts
var deserializeHtmlNodeChildren = (editor, node, isSlateParent = false)=>{
    return Array.from(node.childNodes).flatMap((child)=>{
        if (child.nodeType === 1 && !isSlateNode(child) && isSlateParent) {
            return deserializeHtmlNodeChildren(editor, child, isSlateParent);
        }
        return deserializeHtmlNode(editor)(child);
    });
};
// src/lib/plugins/html/utils/htmlBodyToFragment.ts
var htmlBodyToFragment = (editor, element)=>{
    if (element.nodeName === "BODY") {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$hyperscript$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("fragment", {}, deserializeHtmlNodeChildren(editor, element));
    }
};
// src/lib/plugins/html/utils/htmlBrToNewLine.ts
var htmlBrToNewLine = (node)=>{
    if (node.nodeName === "BR") {
        return "\n";
    }
};
;
;
;
// src/lib/plugins/html/utils/getDataNodeProps.ts
var getDefaultNodeProps = ({ element, type })=>{
    if (!isSlatePluginNode(element, type) && !isSlateLeaf(element)) return;
    const dataAttributes = {};
    Object.entries(element.dataset).forEach(([key, value])=>{
        if (key.startsWith("slate") && value && // Ignore slate default attributes
        ![
            "slateInline",
            "slateLeaf",
            "slateNode",
            "slateVoid"
        ].includes(key)) {
            const attributeKey = key.slice(5).charAt(0).toLowerCase() + key.slice(6);
            if (value === void 0) return;
            let parsedValue = value;
            if (value === "true") parsedValue = true;
            else if (value === "false") parsedValue = false;
            else if (!Number.isNaN(Number(value))) parsedValue = Number(value);
            dataAttributes[attributeKey] = parsedValue;
        }
    });
    if (Object.keys(dataAttributes).length > 0) {
        return dataAttributes;
    }
};
var getDataNodeProps = ({ editor, element, plugin })=>{
    const toNodeProps = plugin.parsers.html?.deserializer?.toNodeProps;
    const disableDefaultNodeProps = plugin.parsers.html?.deserializer?.disableDefaultNodeProps ?? false;
    const defaultNodeProps = disableDefaultNodeProps ? {} : getDefaultNodeProps({
        ...getEditorPlugin(editor, plugin),
        element
    });
    if (!toNodeProps) return defaultNodeProps;
    const customNodeProps = toNodeProps({
        ...getEditorPlugin(editor, plugin),
        element
    }) ?? {};
    return {
        ...defaultNodeProps,
        ...customNodeProps
    };
};
// src/lib/plugins/html/utils/pluginDeserializeHtml.ts
var getDeserializedWithStaticRules = (plugin)=>{
    let deserializer = plugin.parsers?.html?.deserializer;
    const rules = deserializer?.rules ?? [];
    const hasSlateRule = rules.some((rule)=>rule.validClassName?.includes(`slate-${plugin.key}`));
    const staticRules = hasSlateRule ? rules : [
        {
            validClassName: `slate-${plugin.key}`,
            validNodeName: "*"
        },
        ...rules
    ];
    if (!deserializer) deserializer = {
        rules: staticRules
    };
    deserializer.rules = staticRules;
    return deserializer;
};
var pluginDeserializeHtml = (editor, plugin, { deserializeLeaf, element: el })=>{
    const { node: { isElement: isElementRoot, isLeaf: isLeafRoot } } = plugin;
    const deserializer = getDeserializedWithStaticRules(plugin);
    if (!deserializer) return;
    const { attributeNames, isElement: isElementRule, isLeaf: isLeafRule, query, rules } = deserializer;
    let { parse } = deserializer;
    const isElement2 = isElementRule || isElementRoot;
    const isLeaf = isLeafRule || isLeafRoot;
    if (!deserializeLeaf && !isElement2) {
        return;
    }
    if (deserializeLeaf && !isLeaf) {
        return;
    }
    if (rules) {
        const isValid = rules.some(({ validAttribute, validClassName, validNodeName = "*", validStyle })=>{
            if (validNodeName) {
                const validNodeNames = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$castArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(validNodeName);
                if (validNodeNames.length > 0 && !validNodeNames.includes(el.nodeName) && validNodeName !== "*") return false;
            }
            if (validClassName && !el.classList.contains(validClassName)) return false;
            if (validStyle) {
                for (const [key, value] of Object.entries(validStyle)){
                    const values = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$castArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value);
                    if (!values.includes(el.style[key]) && value !== "*") return;
                    if (value === "*" && !el.style[key]) return;
                    const defaultNodeValue = plugin.inject.nodeProps?.defaultNodeValue;
                    if (defaultNodeValue && defaultNodeValue === el.style[key]) {
                        return false;
                    }
                }
            }
            if (validAttribute) {
                if (typeof validAttribute === "string") {
                    if (!el.getAttributeNames().includes(validAttribute)) return false;
                } else {
                    for (const [attributeName, attributeValue] of Object.entries(validAttribute)){
                        const attributeValues = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$castArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attributeValue);
                        const elAttribute = el.getAttribute(attributeName);
                        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(elAttribute) || !attributeValues.includes(elAttribute)) return false;
                    }
                }
            }
            return true;
        });
        if (!isValid) return;
    }
    if (query && !query({
        ...getEditorPlugin(editor, plugin),
        element: el
    })) {
        return;
    }
    if (!parse) if (isElement2) {
        parse = ({ type })=>({
                type
            });
    } else if (isLeaf) {
        parse = ({ type })=>({
                [type]: true
            });
    } else {
        return;
    }
    const parsedNode = (()=>{
        if (isSlateNode(el)) {
            return {};
        }
        return parse({
            ...getEditorPlugin(editor, plugin),
            element: el,
            node: {}
        }) ?? {};
    })();
    const dataNodeProps = getDataNodeProps({
        editor,
        element: el,
        plugin
    });
    let node = {
        ...parsedNode,
        ...dataNodeProps
    };
    if (Object.keys(node).length === 0) return;
    const injectedPlugins = getInjectedPlugins(editor, plugin);
    injectedPlugins.forEach((injectedPlugin)=>{
        const res = injectedPlugin.parsers?.html?.deserializer?.parse?.({
            ...getEditorPlugin(editor, plugin),
            element: el,
            node
        });
        if (res && !isSlateNode(el)) {
            node = {
                ...node,
                ...res
            };
        }
    });
    if (attributeNames) {
        const elementAttributes = {};
        const elementAttributeNames = el.getAttributeNames();
        for (const elementAttributeName of elementAttributeNames){
            if (attributeNames.includes(elementAttributeName)) {
                elementAttributes[elementAttributeName] = el.getAttribute(elementAttributeName);
            }
        }
        if (Object.keys(elementAttributes).length > 0) {
            node.attributes = elementAttributes;
        }
    }
    return {
        ...deserializer,
        node
    };
};
// src/lib/plugins/html/utils/pipeDeserializeHtmlElement.ts
var pipeDeserializeHtmlElement = (editor, element)=>{
    let result;
    [
        ...editor.meta.pluginList
    ].reverse().some((plugin)=>{
        result = pluginDeserializeHtml(editor, plugin, {
            element
        });
        return !!result;
    });
    return result;
};
// src/lib/plugins/html/utils/htmlElementToElement.ts
var htmlElementToElement = (editor, element, isSlate = false)=>{
    const deserialized = pipeDeserializeHtmlElement(editor, element);
    if (deserialized) {
        const { node, withoutChildren } = deserialized;
        let descendants = node.children ?? deserializeHtmlNodeChildren(editor, element, isSlate);
        if (descendants.length === 0 || withoutChildren || isSlateVoid(element)) {
            descendants = [
                {
                    text: ""
                }
            ];
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$hyperscript$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("element", node, descendants);
    }
};
;
;
// src/lib/plugins/html/utils/pipeDeserializeHtmlLeaf.ts
var pipeDeserializeHtmlLeaf = (editor, element)=>{
    let node = {};
    [
        ...editor.meta.pluginList
    ].reverse().forEach((plugin)=>{
        const deserialized = pluginDeserializeHtml(editor, plugin, {
            deserializeLeaf: true,
            element
        });
        if (!deserialized) return;
        node = {
            ...node,
            ...deserialized.node
        };
    });
    return node;
};
// src/lib/plugins/html/utils/htmlElementToLeaf.ts
var htmlElementToLeaf = (editor, element)=>{
    const node = pipeDeserializeHtmlLeaf(editor, element);
    return deserializeHtmlNodeChildren(editor, element).reduce((arr, child)=>{
        if (!child) return arr;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(child)) {
            if (Object.keys(node).length > 0) {
                mergeDeepToNodes({
                    node: child,
                    query: {
                        filter: ([n])=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["TextApi"].isText(n)
                    },
                    source: node
                });
            }
            arr.push(child);
        } else {
            const attributes = {
                ...node
            };
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["TextApi"].isText(child) && child.text) {
                Object.keys(attributes).forEach((key)=>{
                    if (attributes[key] && child[key]) {
                        attributes[key] = child[key];
                    }
                });
            }
            arr.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$hyperscript$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("text", attributes, child));
        }
        return arr;
    }, []);
};
// src/lib/plugins/html/utils/htmlTextNodeToString.ts
var htmlTextNodeToString = (node)=>{
    if (isHtmlText(node)) {
        if (node.parentElement?.dataset.platePreventDeserialization) return "";
        return node.textContent || "";
    }
};
// src/lib/plugins/html/utils/deserializeHtmlNode.ts
var deserializeHtmlNode = (editor)=>(node)=>{
        const textNode = htmlTextNodeToString(node);
        if (textNode) return textNode;
        if (!isHtmlElement(node)) return null;
        const breakLine = htmlBrToNewLine(node);
        if (breakLine) return breakLine;
        const fragment = htmlBodyToFragment(editor, node);
        if (fragment) return fragment;
        const element = htmlElementToElement(editor, node, isSlateNode(node));
        if (element) return element;
        return htmlElementToLeaf(editor, node);
    };
// src/lib/plugins/html/utils/deserializeHtmlElement.ts
var deserializeHtmlElement = (editor, element)=>{
    return deserializeHtmlNode(editor)(element);
};
// src/lib/plugins/html/utils/htmlStringToDOMNode.ts
var htmlStringToDOMNode = (rawHtml)=>{
    const node = document.createElement("body");
    node.innerHTML = rawHtml;
    return node;
};
// src/lib/plugins/html/utils/deserializeHtml.ts
var deserializeHtml = (editor, { collapseWhiteSpace: shouldCollapseWhiteSpace = true, defaultElementPlugin, element })=>{
    if (typeof element === "string") {
        element = htmlStringToDOMNode(element);
    }
    if (shouldCollapseWhiteSpace) {
        element = collapseWhiteSpace(element);
    }
    const fragment = deserializeHtmlElement(editor, element);
    return normalizeDescendantsToDocumentFragment(editor, {
        defaultElementPlugin,
        descendants: fragment
    });
};
// src/lib/plugins/html/utils/findHtmlElement.ts
var findHtmlElement = (rootNode, predicate)=>{
    let res = null;
    traverseHtmlElements(rootNode, (node)=>{
        if (predicate(node)) {
            res = node;
            return false;
        }
        return true;
    });
    return res;
};
var someHtmlElement = (rootNode, predicate)=>{
    return !!findHtmlElement(rootNode, predicate);
};
// src/lib/plugins/html/utils/getHtmlComments.ts
var acceptNode = ()=>NodeFilter.FILTER_ACCEPT;
var getHtmlComments = (node)=>{
    const comments = [];
    const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
        acceptNode
    });
    let currentNode = iterator.nextNode();
    while(currentNode){
        if (currentNode.nodeValue) {
            comments.push(currentNode.nodeValue);
        }
        currentNode = iterator.nextNode();
    }
    return comments;
};
// src/lib/plugins/html/utils/isHtmlComment.ts
var isHtmlComment = (node)=>node.nodeType === Node.COMMENT_NODE;
// src/lib/plugins/html/utils/isOlSymbol.ts
var isOlSymbol = (symbol)=>{
    return /[\da-np-z]\S/.test(symbol.toLowerCase());
};
// src/lib/plugins/html/utils/parseHtmlDocument.ts
var parseHtmlDocument = (html)=>{
    return new DOMParser().parseFromString(html, "text/html");
};
// src/lib/plugins/html/utils/parseHtmlElement.ts
var parseHtmlElement = (html)=>{
    const { body } = parseHtmlDocument(html);
    return body.firstElementChild;
};
// src/lib/plugins/html/utils/postCleanHtml.ts
var postCleanHtml = (html)=>{
    const cleanHtml = html.trim().replaceAll(new RegExp(ZERO_WIDTH_SPACE, "g"), "");
    return `<body>${cleanHtml}</body>`;
};
// src/lib/plugins/html/utils/removeHtmlSurroundings.ts
var removeBeforeHtml = (html)=>{
    const index = html.indexOf("<html");
    if (index === -1) {
        return html;
    }
    return html.slice(Math.max(0, index));
};
var removeAfterHtml = (html)=>{
    const index = html.lastIndexOf("</html>");
    if (index === -1) {
        return html;
    }
    return html.slice(0, Math.max(0, index + "</html>".length));
};
var removeHtmlSurroundings = (html)=>{
    return removeBeforeHtml(removeAfterHtml(html));
};
// src/lib/plugins/html/utils/preCleanHtml.ts
var cleaners = [
    removeHtmlSurroundings,
    cleanHtmlCrLf
];
var preCleanHtml = (html)=>{
    return cleaners.reduce((result, clean)=>clean(result), html);
};
// src/lib/plugins/html/utils/traverseHtmlComments.ts
var traverseHtmlComments = (rootNode, callback)=>{
    traverseHtmlNode(rootNode, (node)=>{
        if (!isHtmlComment(node)) {
            return true;
        }
        return callback(node);
    });
};
// src/lib/plugins/html/utils/removeHtmlNodesBetweenComments.ts
var removeHtmlNodesBetweenComments = (rootNode, start, end)=>{
    const isClosingComment = (node)=>isHtmlComment(node) && node.data === end;
    traverseHtmlComments(rootNode, (comment)=>{
        if (comment.data === start) {
            let node = comment.nextSibling;
            comment.remove();
            while(node && !isClosingComment(node)){
                const { nextSibling } = node;
                node.remove();
                node = nextSibling;
            }
            if (node && isClosingComment(node)) {
                node.remove();
            }
        }
        return true;
    });
};
// src/lib/plugins/html/HtmlPlugin.ts
var HtmlPlugin = createSlatePlugin({
    key: "html"
}).extendApi(({ editor })=>({
        deserialize: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bindFirst"])(deserializeHtml, editor)
    })).extend({
    parser: {
        format: "text/html",
        deserialize: ({ api, data })=>{
            const document2 = parseHtmlDocument(data);
            return api.html.deserialize({
                element: document2.body
            });
        }
    }
});
// src/lib/plugins/length/LengthPlugin.ts
var LengthPlugin = createTSlatePlugin({
    key: "length"
}).overrideEditor(({ editor, getOptions, tf: { apply } })=>({
        transforms: {
            apply (operation) {
                editor.tf.withoutNormalizing(()=>{
                    apply(operation);
                    const options = getOptions();
                    if (options.maxLength) {
                        const length = editor.api.string([]).length;
                        if (length > options.maxLength) {
                            const overflowLength = length - options.maxLength;
                            editor.tf.delete({
                                distance: overflowLength,
                                reverse: true,
                                unit: "character"
                            });
                        }
                    }
                });
            }
        }
    }));
;
;
;
;
;
;
var withNodeId = ({ editor, getOptions, tf: { apply, insertNode, insertNodes } })=>{
    const idPropsCreator = ()=>({
            [getOptions().idKey ?? ""]: getOptions().idCreator()
        });
    const filterNode = (nodeEntry)=>{
        const { filter, filterText } = getOptions();
        return filter(nodeEntry) && (!filterText || nodeEntry[0]?.type !== void 0);
    };
    const removeIdFromNodeIfDuplicate = (node)=>{
        const { idKey = "", reuseId } = getOptions();
        if (!reuseId && editor.api.some({
            at: [],
            match: {
                [idKey]: node[idKey]
            }
        })) {
            delete node[idKey];
        }
    };
    const overrideIdIfSet = (node)=>{
        const { idKey = "" } = getOptions();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(node._id)) {
            const id = node._id;
            delete node._id;
            if (!editor.api.some({
                at: [],
                match: {
                    [idKey]: id
                }
            })) {
                node[idKey] = id;
            }
        }
    };
    return {
        transforms: {
            apply (operation) {
                const { allow, disableInsertOverrides, exclude, idCreator, idKey = "", reuseId } = getOptions();
                const query = {
                    allow,
                    exclude,
                    filter: filterNode
                };
                if (operation.type === "insert_node") {
                    const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$cloneDeep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(operation.node);
                    applyDeepToNodes({
                        apply: removeIdFromNodeIfDuplicate,
                        node,
                        query,
                        source: {}
                    });
                    defaultsDeepToNodes({
                        node,
                        path: operation.path,
                        query,
                        source: idPropsCreator
                    });
                    if (!disableInsertOverrides) {
                        applyDeepToNodes({
                            apply: overrideIdIfSet,
                            node,
                            query,
                            source: {}
                        });
                    }
                    return apply({
                        ...operation,
                        node
                    });
                }
                if (operation.type === "split_node") {
                    const node = operation.properties;
                    let id = operation.properties[idKey];
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryNode"])([
                        node,
                        operation.path
                    ], query)) {
                        if (!reuseId || id === void 0 || editor.api.some({
                            at: [],
                            match: {
                                [idKey]: id
                            }
                        })) {
                            id = idCreator();
                        }
                        return apply({
                            ...operation,
                            properties: {
                                ...operation.properties,
                                [idKey]: id
                            }
                        });
                    }
                    if (id) {
                        delete operation.properties[idKey];
                    }
                }
                return apply(operation);
            },
            insertNode (node) {
                const { disableInsertOverrides, idKey = "" } = getOptions();
                if (!disableInsertOverrides && node[idKey]) {
                    if (!Object.isExtensible(node)) {
                        node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$cloneDeep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node);
                    }
                    node._id = node[idKey];
                }
                insertNode(node);
            },
            insertNodes (_nodes, options) {
                const nodes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$castArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(_nodes).filter((node)=>!!node);
                if (nodes.length === 0) return;
                const { disableInsertOverrides, idKey = "" } = getOptions();
                insertNodes(nodes.map((node)=>{
                    if (!disableInsertOverrides && node[idKey]) {
                        if (!Object.isExtensible(node)) {
                            node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$cloneDeep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node);
                        }
                        node._id = node[idKey];
                    }
                    return node;
                }), options);
            }
        }
    };
};
// src/lib/plugins/node-id/NodeIdPlugin.ts
var NodeIdPlugin = createTSlatePlugin({
    key: "nodeId",
    options: {
        filterInline: true,
        filterText: true,
        idKey: "id",
        normalizeInitialValue: false,
        filter: ()=>true,
        idCreator: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])(10)
    },
    normalizeInitialValue: ({ editor, getOptions })=>{
        const { allow, exclude, filter, filterInline, filterText, idKey, normalizeInitialValue } = getOptions();
        if (!normalizeInitialValue) {
            const firstNode = editor.children[0];
            const lastNode = editor.children.at(-1);
            if (firstNode?.id && lastNode?.id) {
                return;
            }
        }
        const addNodeId = (entry)=>{
            const [node, path] = entry;
            if (!node[idKey] && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queryNode"])([
                node,
                path
            ], {
                allow,
                exclude,
                filter: (entry2)=>{
                    const [node2] = entry2;
                    if (filterText && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(node2)) {
                        return false;
                    }
                    if (filterInline && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(node2) && !editor.api.isBlock(node2)) {
                        return false;
                    }
                    return filter(entry2);
                }
            })) {
                const existingNode = editor.api.node(path);
                if (!existingNode) {
                    return;
                }
                editor.tf.withoutSaving(()=>{
                    editor.tf.setNodes({
                        [idKey]: getOptions().idCreator()
                    }, {
                        at: path
                    });
                });
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(node)) {
                node.children.forEach((child, index)=>{
                    addNodeId([
                        child,
                        [
                            ...path,
                            index
                        ]
                    ]);
                });
            }
        };
        editor.children.forEach((node, index)=>{
            addNodeId([
                node,
                [
                    index
                ]
            ]);
        });
    }
}).overrideEditor(withNodeId);
;
// src/internal/plugin/pipeNormalizeInitialValue.ts
var pipeNormalizeInitialValue = (editor)=>{
    editor.meta.pluginCache.normalizeInitialValue.forEach((key)=>{
        const p = editor.getPlugin({
            key
        });
        if (isEditOnly(editor.dom.readOnly, p, "normalizeInitialValue")) {
            return;
        }
        p.normalizeInitialValue?.({
            ...getEditorPlugin(editor, p),
            value: editor.children
        });
    });
};
// src/lib/plugins/slate-extension/transforms/init.ts
var init = async (editor, { autoSelect, selection, shouldNormalizeEditor, value })=>{
    if (value !== null) {
        if (typeof value === "string") {
            editor.children = editor.api.html.deserialize({
                element: value
            });
        } else if (typeof value === "function") {
            editor.children = await value(editor);
        } else if (value) {
            editor.children = value;
        }
        if (!editor.children || editor.children?.length === 0) {
            editor.children = editor.api.create.value();
        }
    }
    if (selection) {
        editor.selection = selection;
    } else if (autoSelect) {
        const edge = autoSelect === "start" ? "start" : "end";
        const target = edge === "start" ? editor.api.start([]) : editor.api.end([]);
        editor.tf.select(target);
    }
    if (editor.children.length > 0) {
        pipeNormalizeInitialValue(editor);
    }
    if (shouldNormalizeEditor) {
        editor.tf.normalize({
            force: true
        });
    }
};
;
var insertExitBreak = (editor, { match, reverse } = {})=>{
    if (!editor.selection || !editor.api.isCollapsed()) return;
    const block = editor.api.block();
    if (!block) return;
    const target = editor.api.above({
        at: block[1],
        match: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["combineMatchOptions"])(editor, (n, p)=>p.length === 1 || p.length > 1 && !!n.type && !getPluginTypes(editor, editor.meta.pluginCache.node.isStrictSiblings).includes(n.type), {
            match
        })
    });
    const ancestorPath = target?.[1] ?? block[1];
    const targetPath = reverse ? ancestorPath : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["PathApi"].next(ancestorPath);
    if (!targetPath) return;
    editor.tf.insertNodes(editor.api.create.block(), {
        at: targetPath,
        select: true
    });
    return true;
};
;
var resetBlock = (editor, { at } = {})=>{
    const entry = editor.api.block({
        at
    });
    if (!entry?.[0]) return;
    const [block, path] = entry;
    editor.tf.withoutNormalizing(()=>{
        const { id, type, ...otherProps } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeApi"].extractProps(block);
        Object.keys(otherProps).forEach((key)=>{
            editor.tf.unsetNodes(key, {
                at: path
            });
        });
        const paragraphType = editor.getType(BaseParagraphPlugin.key);
        if (block.type !== paragraphType) {
            editor.tf.setNodes({
                type: paragraphType
            }, {
                at: path
            });
        }
    });
    return true;
};
// src/lib/plugins/slate-extension/transforms/setValue.ts
var setValue = (editor, value)=>{
    let children = value;
    if (typeof value === "string") {
        children = editor.api.html.deserialize({
            element: value
        });
    } else if (!value || value.length === 0) {
        children = editor.api.create.value();
    }
    editor.tf.replaceNodes(children, {
        at: [],
        children: true
    });
};
// src/lib/plugins/slate-extension/SlateExtensionPlugin.ts
var SlateExtensionPlugin = createSlatePlugin({
    key: "slateExtension"
}).extendEditorTransforms(({ editor })=>({
        /**
   * Initialize the editor value, selection and normalization. Set `value` to
   * `null` to skip children initialization.
   */ init: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bindFirst"])(init, editor),
        insertExitBreak: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bindFirst"])(insertExitBreak, editor),
        resetBlock: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bindFirst"])(resetBlock, editor),
        setValue: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bindFirst"])(setValue, editor)
    }));
// src/lib/utils/normalizeDescendantsToDocumentFragment.ts
var isInlineNode = (editor)=>(node)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["TextApi"].isText(node) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(node) && editor.api.isInline(node);
var makeBlockLazy = (type)=>()=>({
            children: [],
            type
        });
var hasDifferentChildNodes = (descendants, isInline)=>{
    return descendants.some((descendant, index, arr)=>{
        const prevDescendant = arr[index - 1];
        if (index !== 0) {
            return isInline(descendant) !== isInline(prevDescendant);
        }
        return false;
    });
};
var normalizeDifferentNodeTypes = (descendants, isInline, makeDefaultBlock)=>{
    const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline);
    const { fragment } = descendants.reduce((memo, node)=>{
        if (hasDifferentNodes && isInline(node)) {
            let block = memo.precedingBlock;
            if (!block) {
                block = makeDefaultBlock();
                memo.precedingBlock = block;
                memo.fragment.push(block);
            }
            block.children.push(node);
        } else {
            memo.fragment.push(node);
            memo.precedingBlock = null;
        }
        return memo;
    }, {
        fragment: [],
        precedingBlock: null
    });
    return fragment;
};
var normalizeEmptyChildren = (descendants)=>{
    if (descendants.length === 0) {
        return [
            {
                text: ""
            }
        ];
    }
    return descendants;
};
var normalize = (descendants, isInline, makeDefaultBlock)=>{
    descendants = normalizeEmptyChildren(descendants);
    descendants = normalizeDifferentNodeTypes(descendants, isInline, makeDefaultBlock);
    descendants = descendants.map((node)=>{
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ElementApi"].isElement(node)) {
            return {
                ...node,
                children: normalize(node.children, isInline, makeDefaultBlock)
            };
        }
        return node;
    });
    return descendants;
};
var normalizeDescendantsToDocumentFragment = (editor, { defaultElementPlugin = BaseParagraphPlugin, descendants })=>{
    const isInline = isInlineNode(editor);
    const defaultType = editor.getType(defaultElementPlugin.key);
    const makeDefaultBlock = makeBlockLazy(defaultType);
    return normalize(descendants, isInline, makeDefaultBlock);
};
// src/lib/utils/omitPluginContext.ts
var omitPluginContext = (ctx)=>{
    const { api, editor, getOption, getOptions, plugin, setOption, setOptions, tf, type, ...rest } = ctx;
    return rest;
};
;
var overridePluginsByKey = (plugin, overrideByKey = {}, nested = false)=>{
    if (overrideByKey[plugin.key]) {
        const { __extensions: pluginOverridesExtensions, plugins: pluginOverridesPlugins, ...pluginOverrides } = overrideByKey[plugin.key];
        plugin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$defaultsDeep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, pluginOverrides, plugin);
        if (pluginOverridesExtensions) {
            plugin.__extensions = [
                ...plugin.__extensions || [],
                ...pluginOverridesExtensions
            ];
        }
        if (!nested) {
            pluginOverridesPlugins?.forEach((pOverrides)=>{
                if (!plugin.plugins) plugin.plugins = [];
                const found = plugin.plugins.find((p)=>p.key === pOverrides.key);
                if (!found) plugin.plugins.push(pOverrides);
            });
        }
    }
    if (plugin.plugins) {
        plugin.plugins = plugin.plugins.map((p)=>overridePluginsByKey(p, overrideByKey, true));
    }
    return plugin;
};
// src/lib/utils/pipeInsertDataQuery.ts
var pipeInsertDataQuery = (editor, plugins2, { data, dataTransfer })=>plugins2.every((p)=>{
        const query = p.parser?.query;
        return !query || query({
            ...getEditorPlugin(editor, p),
            data,
            dataTransfer
        });
    });
// src/lib/plugins/ParserPlugin.ts
var ParserPlugin = createSlatePlugin({
    key: "parser"
}).overrideEditor(({ editor, tf: { insertData } })=>({
        transforms: {
            insertData (dataTransfer) {
                const inserted = [
                    ...editor.meta.pluginList
                ].reverse().some((plugin)=>{
                    const parser = plugin.parser;
                    if (!parser) return false;
                    const injectedPlugins = getInjectedPlugins(editor, plugin);
                    const { deserialize, format, mimeTypes } = parser;
                    if (!format) return false;
                    const formats = Array.isArray(format) ? format : [
                        format
                    ];
                    const mimeTypeList = mimeTypes || formats.map((fmt)=>fmt.includes("/") ? fmt : `text/${fmt}`);
                    for (const mimeType of mimeTypeList){
                        let data = dataTransfer.getData(mimeType);
                        if (!data) continue;
                        if (!pipeInsertDataQuery(editor, injectedPlugins, {
                            data,
                            dataTransfer
                        })) {
                            continue;
                        }
                        data = pipeTransformData(editor, injectedPlugins, {
                            data,
                            dataTransfer
                        });
                        let fragment = deserialize?.({
                            ...getEditorPlugin(editor, plugin),
                            data,
                            dataTransfer
                        });
                        if (!fragment?.length) continue;
                        fragment = pipeTransformFragment(editor, injectedPlugins, {
                            data,
                            dataTransfer,
                            fragment
                        });
                        if (fragment.length === 0) continue;
                        pipeInsertFragment(editor, injectedPlugins, {
                            data,
                            dataTransfer,
                            fragment
                        });
                        return true;
                    }
                    return false;
                });
                if (inserted) return;
                insertData(dataTransfer);
            }
        }
    }));
// src/lib/plugins/getCorePlugins.ts
var getCorePlugins = ({ affinity, maxLength, nodeId, plugins: plugins2 = [] })=>{
    let resolvedNodeId = nodeId;
    if (("TURBOPACK compile-time value", "development") === "test" && nodeId === void 0) {
        resolvedNodeId = false;
    }
    let corePlugins = [
        DebugPlugin,
        SlateExtensionPlugin,
        DOMPlugin,
        HistoryPlugin,
        OverridePlugin,
        ParserPlugin,
        maxLength ? LengthPlugin.configure({
            options: {
                maxLength
            }
        }) : LengthPlugin,
        HtmlPlugin,
        AstPlugin,
        NodeIdPlugin.configure({
            enabled: resolvedNodeId !== false,
            options: resolvedNodeId === false ? void 0 : resolvedNodeId
        }),
        AffinityPlugin.configure({
            enabled: affinity
        }),
        BaseParagraphPlugin
    ];
    const customPluginsMap = new Map(plugins2.map((plugin)=>[
            plugin.key,
            plugin
        ]));
    corePlugins = corePlugins.map((corePlugin)=>{
        const customPlugin = customPluginsMap.get(corePlugin.key);
        if (customPlugin) {
            const index = plugins2.findIndex((p)=>p.key === corePlugin.key);
            if (index !== -1) {
                plugins2.splice(index, 1);
            }
            return customPlugin;
        }
        return corePlugin;
    });
    return corePlugins;
};
// src/lib/editor/withSlate.ts
var withSlate = (e, { id, affinity = true, autoSelect, maxLength, nodeId, plugins: plugins2 = [], readOnly = false, rootPlugin, selection, shouldNormalizeEditor, skipInitialization, value, ...pluginConfig } = {})=>{
    const editor = e;
    editor.id = id ?? editor.id ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])();
    editor.meta.key = editor.meta.key ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$plate$2d$core$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])();
    editor.meta.isFallback = false;
    editor.dom = {
        composing: false,
        currentKeyboardEvent: null,
        focused: false,
        prevSelection: null,
        readOnly
    };
    editor.getApi = ()=>editor.api;
    editor.getTransforms = ()=>editor.transforms;
    editor.getPlugin = (plugin)=>getSlatePlugin(editor, plugin);
    editor.getType = (pluginKey)=>getPluginType(editor, pluginKey);
    editor.getInjectProps = (plugin)=>{
        const nodeProps = editor.getPlugin(plugin).inject?.nodeProps ?? {};
        nodeProps.nodeKey = nodeProps.nodeKey ?? editor.getType(plugin.key);
        nodeProps.styleKey = nodeProps.styleKey ?? nodeProps.nodeKey;
        return nodeProps;
    };
    editor.getOptionsStore = (plugin)=>{
        return editor.getPlugin(plugin).optionsStore;
    };
    editor.getOptions = (plugin)=>{
        const store = editor.getOptionsStore(plugin);
        if (!store) return editor.getPlugin(plugin).options;
        return editor.getOptionsStore(plugin).get("state");
    };
    editor.getOption = (plugin, key, ...args)=>{
        const store = editor.getOptionsStore(plugin);
        if (!store) return editor.getPlugin(plugin).options[key];
        if (!(key in store.get("state")) && !(key in store.selectors)) {
            editor.api.debug.error(`editor.getOption: ${key} option is not defined in plugin ${plugin.key}.`, "OPTION_UNDEFINED");
            return;
        }
        return store.get(key, ...args);
    };
    editor.setOption = (plugin, key, ...args)=>{
        const store = editor.getOptionsStore(plugin);
        if (!store) return;
        if (!(key in store.get("state"))) {
            editor.api.debug.error(`editor.setOption: ${key} option is not defined in plugin ${plugin.key}.`, "OPTION_UNDEFINED");
            return;
        }
        store.set(key, ...args);
    };
    editor.setOptions = (plugin, options)=>{
        const store = editor.getOptionsStore(plugin);
        if (!store) return;
        if (typeof options === "object") {
            store.set("state", (draft)=>{
                Object.assign(draft, options);
            });
        } else if (typeof options === "function") {
            store.set("state", options);
        }
    };
    const corePlugins = getCorePlugins({
        affinity,
        maxLength,
        nodeId,
        plugins: plugins2
    });
    let rootPluginInstance = createSlatePlugin({
        key: "root",
        priority: 1e4,
        ...pluginConfig,
        override: {
            ...pluginConfig.override,
            components: {
                ...pluginConfig.components,
                ...pluginConfig.override?.components
            }
        },
        plugins: [
            ...corePlugins,
            ...plugins2
        ]
    });
    if (rootPlugin) {
        rootPluginInstance = rootPlugin(rootPluginInstance);
    }
    resolvePlugins(editor, [
        rootPluginInstance
    ]);
    const normalizeNode = editor.tf.normalizeNode;
    editor.tf.normalizeNode = (...args)=>{
        if (!editor.api.shouldNormalizeNode(args[0])) {
            return;
        }
        return normalizeNode(...args);
    };
    editor.normalizeNode = editor.tf.normalizeNode;
    if (!skipInitialization) {
        void editor.tf.init({
            autoSelect,
            selection,
            shouldNormalizeEditor,
            value
        });
    }
    return editor;
};
var createSlateEditor = ({ editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$udecode$2f$slate$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createEditor"])(), ...options } = {})=>{
    return withSlate(editor, options);
};
;
;
;
 /*! Bundled license information:

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/  //# sourceMappingURL=index.mjs.map
}),
]);

//# sourceMappingURL=node_modules_%40udecode_plate-core_dist_index_mjs_6a0f7c34._.js.map