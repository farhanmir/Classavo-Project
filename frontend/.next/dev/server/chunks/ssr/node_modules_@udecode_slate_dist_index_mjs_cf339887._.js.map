{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/create-editor.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/interfaces/element.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/interfaces/location-ref.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/interfaces/path.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/interfaces/location.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/interfaces/node.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/node-extension.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/interfaces/text.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/interfaces/operation.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/interfaces/point.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/interfaces/range.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/blur.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/deselectDOM.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/findDocumentOrShadowRoot.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/findEventRange.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/findKey.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/findPath.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/focus.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/getWindow.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/hasDOMNode.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/hasEditableTarget.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/hasRange.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/hasSelectableTarget.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/hasTarget.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/isComposing.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/isFocused.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/isReadOnly.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/isTargetInsideNonReadonlyVoid.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/toDOMNode.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/toDOMPoint.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/toDOMRange.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/toSlateNode.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/toSlatePoint.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/dom-editor/toSlateRange.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/edge-blocks.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/editor-block.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/editor-blocks.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/utils/assignLegacyTransforms.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/utils/deleteMerge.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/createPathRef.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/createPointRef.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getEndPoint.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/utils/getAt.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getLeafNode.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getPointAfter.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getPointBefore.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getStartPoint.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getVoidNode.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/isBlock.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/utils/match.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/nodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/withoutNormalizing.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/select.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/utils/queryEditor.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/utils/queryNode.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/editor-descendant.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/editor-mark.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/hasMark.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/is-selected.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/isAt.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/isEditorEnd.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/isText.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/nodes-range.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/prop.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/node_modules/compute-scroll-into-view/src/index.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/node_modules/scroll-into-view-if-needed/src/index.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/scrollIntoView.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor-extension/some.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/above.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/addMark.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/createRangeRef.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/deleteBackward.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/deleteForward.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/deleteFragment.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/editor-node.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/editor-path.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getEdgePoints.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getEditorString.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getFirstNode.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getFragment.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getLevels.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getMarks.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getPathRefs.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getPoint.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getPointRefs.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getPositions.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/getRangeRefs.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/hasBlocks.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/hasInlines.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/hasTexts.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/insertBreak.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/insertNode.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/isEdgePoint.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/isEditorNormalizing.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/isElementReadOnly.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/isEmpty.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/isEndPoint.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/isStartPoint.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/last.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/next.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/normalizeEditor.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/parent.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/previous.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/range.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/removeEditorMark.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/shouldMergeNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/editor/unhangRange.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms-extension/addMarks.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms-extension/duplicateNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms-extension/removeMarks.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms-extension/replaceNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms-extension/reset.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms-extension/toggleBlock.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms-extension/toggleMark.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/collapseSelection.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/deleteText.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/deselect.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/insertFragment.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/insertNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/insertSoftBreak.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/insertText.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/liftNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/mergeNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/moveNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/moveSelection.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/removeNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/setNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/setPoint.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/setSelection.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/splitNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/unsetNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/unwrapNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/internal/transforms/wrapNodes.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/slate-history/history.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/slate-dom.ts","file:///C:/Users/Farhan%20Mir/Desktop/Projects/Classavo%20Project/frontend/node_modules/%40udecode/slate/src/slate-history/with-history.ts"],"sourcesContent":["import { bindFirst } from '@udecode/utils';\nimport {\n  apply,\n  createEditor as createSlateEditor,\n  getDirtyPaths,\n  hasPath,\n  normalizeNode,\n  setNormalizing,\n  shouldNormalize,\n} from 'slate';\n\nimport type { Editor, Value } from './interfaces/editor/editor-type';\n\nimport {\n  type EditorApi,\n  type LegacyEditorMethods,\n  RangeApi,\n} from './interfaces';\nimport { blur } from './internal/dom-editor/blur';\nimport { deselectDOM } from './internal/dom-editor/deselectDOM';\nimport { findDocumentOrShadowRoot } from './internal/dom-editor/findDocumentOrShadowRoot';\nimport { findEventRange } from './internal/dom-editor/findEventRange';\nimport { findKey } from './internal/dom-editor/findKey';\nimport { findPath } from './internal/dom-editor/findPath';\nimport { focus } from './internal/dom-editor/focus';\nimport { getWindow } from './internal/dom-editor/getWindow';\nimport { hasDOMNode } from './internal/dom-editor/hasDOMNode';\nimport { hasEditableTarget } from './internal/dom-editor/hasEditableTarget';\nimport { hasRange } from './internal/dom-editor/hasRange';\nimport { hasSelectableTarget } from './internal/dom-editor/hasSelectableTarget';\nimport { hasTarget } from './internal/dom-editor/hasTarget';\nimport { isComposing } from './internal/dom-editor/isComposing';\nimport { isFocused } from './internal/dom-editor/isFocused';\nimport { isReadOnly } from './internal/dom-editor/isReadOnly';\nimport { isTargetInsideNonReadonlyVoid } from './internal/dom-editor/isTargetInsideNonReadonlyVoid';\nimport { toDOMNode } from './internal/dom-editor/toDOMNode';\nimport { toDOMPoint } from './internal/dom-editor/toDOMPoint';\nimport { toDOMRange } from './internal/dom-editor/toDOMRange';\nimport { toSlateNode } from './internal/dom-editor/toSlateNode';\nimport { toSlatePoint } from './internal/dom-editor/toSlatePoint';\nimport { toSlateRange } from './internal/dom-editor/toSlateRange';\nimport { edgeBlocks } from './internal/editor-extension/edge-blocks';\nimport { block } from './internal/editor-extension/editor-block';\nimport { blocks } from './internal/editor-extension/editor-blocks';\nimport { descendant } from './internal/editor-extension/editor-descendant';\nimport { mark } from './internal/editor-extension/editor-mark';\nimport { hasMark } from './internal/editor-extension/hasMark';\nimport { isSelected } from './internal/editor-extension/is-selected';\nimport { isAt } from './internal/editor-extension/isAt';\nimport { isEditorEnd } from './internal/editor-extension/isEditorEnd';\nimport { isText } from './internal/editor-extension/isText';\nimport { nodesRange } from './internal/editor-extension/nodes-range';\nimport { prop } from './internal/editor-extension/prop';\nimport { scrollIntoView } from './internal/editor-extension/scrollIntoView';\nimport { some } from './internal/editor-extension/some';\nimport { above } from './internal/editor/above';\nimport { addMark } from './internal/editor/addMark';\nimport { createPathRef } from './internal/editor/createPathRef';\nimport { createPointRef } from './internal/editor/createPointRef';\nimport { createRangeRef } from './internal/editor/createRangeRef';\nimport { deleteBackward } from './internal/editor/deleteBackward';\nimport { deleteForward } from './internal/editor/deleteForward';\nimport { deleteFragment } from './internal/editor/deleteFragment';\nimport { node } from './internal/editor/editor-node';\nimport { path } from './internal/editor/editor-path';\nimport { getEdgePoints } from './internal/editor/getEdgePoints';\nimport { getEditorString } from './internal/editor/getEditorString';\nimport { getEndPoint } from './internal/editor/getEndPoint';\nimport { getFirstNode } from './internal/editor/getFirstNode';\nimport { getFragment } from './internal/editor/getFragment';\nimport { getLeafNode } from './internal/editor/getLeafNode';\nimport { getLevels } from './internal/editor/getLevels';\nimport { getMarks } from './internal/editor/getMarks';\nimport { getPathRefs } from './internal/editor/getPathRefs';\nimport { getPoint } from './internal/editor/getPoint';\nimport { getPointAfter } from './internal/editor/getPointAfter';\nimport { getPointBefore } from './internal/editor/getPointBefore';\nimport { getPointRefs } from './internal/editor/getPointRefs';\nimport { getPositions } from './internal/editor/getPositions';\nimport { getRangeRefs } from './internal/editor/getRangeRefs';\nimport { getStartPoint } from './internal/editor/getStartPoint';\nimport { getVoidNode } from './internal/editor/getVoidNode';\nimport { hasBlocks } from './internal/editor/hasBlocks';\nimport { hasInlines } from './internal/editor/hasInlines';\nimport { hasTexts } from './internal/editor/hasTexts';\nimport { insertBreak } from './internal/editor/insertBreak';\nimport { insertNode } from './internal/editor/insertNode';\nimport { isBlock } from './internal/editor/isBlock';\nimport { isEdgePoint } from './internal/editor/isEdgePoint';\nimport { isEditorNormalizing } from './internal/editor/isEditorNormalizing';\nimport { isElementReadOnly } from './internal/editor/isElementReadOnly';\nimport { isEmpty } from './internal/editor/isEmpty';\nimport { isEndPoint } from './internal/editor/isEndPoint';\nimport { isStartPoint } from './internal/editor/isStartPoint';\nimport { last } from './internal/editor/last';\nimport { next } from './internal/editor/next';\nimport { nodes } from './internal/editor/nodes';\nimport { normalizeEditor } from './internal/editor/normalizeEditor';\nimport { parent } from './internal/editor/parent';\nimport { previous } from './internal/editor/previous';\nimport { range } from './internal/editor/range';\nimport { removeEditorMark } from './internal/editor/removeEditorMark';\nimport { shouldMergeNodes } from './internal/editor/shouldMergeNodes';\nimport { unhangRange } from './internal/editor/unhangRange';\nimport { withoutNormalizing } from './internal/editor/withoutNormalizing';\nimport { addMarks } from './internal/transforms-extension/addMarks';\nimport { duplicateNodes } from './internal/transforms-extension/duplicateNodes';\nimport { removeMarks } from './internal/transforms-extension/removeMarks';\nimport { replaceNodes } from './internal/transforms-extension/replaceNodes';\nimport { reset } from './internal/transforms-extension/reset';\nimport { toggleBlock } from './internal/transforms-extension/toggleBlock';\nimport { toggleMark } from './internal/transforms-extension/toggleMark';\nimport { collapseSelection } from './internal/transforms/collapseSelection';\nimport { deleteText } from './internal/transforms/deleteText';\nimport { deselect } from './internal/transforms/deselect';\nimport { insertFragment } from './internal/transforms/insertFragment';\nimport { insertNodes } from './internal/transforms/insertNodes';\nimport { insertSoftBreak } from './internal/transforms/insertSoftBreak';\nimport { insertText } from './internal/transforms/insertText';\nimport { liftNodes } from './internal/transforms/liftNodes';\nimport { mergeNodes } from './internal/transforms/mergeNodes';\nimport { moveNodes } from './internal/transforms/moveNodes';\nimport { moveSelection } from './internal/transforms/moveSelection';\nimport { removeNodes } from './internal/transforms/removeNodes';\nimport { select } from './internal/transforms/select';\nimport { setNodes } from './internal/transforms/setNodes';\nimport { setPoint } from './internal/transforms/setPoint';\nimport { setSelection } from './internal/transforms/setSelection';\nimport { splitNodes } from './internal/transforms/splitNodes';\nimport { unsetNodes } from './internal/transforms/unsetNodes';\nimport { unwrapNodes } from './internal/transforms/unwrapNodes';\nimport { wrapNodes } from './internal/transforms/wrapNodes';\nimport { HistoryApi } from './slate-history/history';\nimport { syncLegacyMethods } from './utils/assignLegacyTransforms';\n\nconst noop: {\n  (name: string): () => void;\n  <T>(name: string, returnValue: T): () => T;\n} =\n  <T>(name: string, returnValue?: T) =>\n  () => {\n    console.warn(\n      `[OVERRIDE_MISSING] The method editor.${name}() has not been implemented or overridden. ` +\n        `This may cause unexpected behavior. Please ensure that all required editor methods are properly defined.`\n    );\n\n    return returnValue;\n  };\n\nexport const createEditor = <V extends Value>({\n  children,\n  selection,\n}: {\n  children?: V;\n  selection?: Editor['selection'];\n} = {}) => {\n  const editor = createSlateEditor() as any as Editor & LegacyEditorMethods;\n\n  if (children) {\n    editor.children = children;\n  }\n  if (selection) {\n    editor.selection = selection;\n  }\n\n  Object.assign(editor, {\n    apply: bindFirst(apply, editor as any),\n    isElementReadOnly: editor.isElementReadOnly,\n    isInline: editor.isInline,\n    isSelectable: editor.isSelectable,\n    isVoid: editor.isVoid,\n    markableVoid: editor.markableVoid,\n    onChange: editor.onChange,\n  });\n\n  Object.assign(editor, {\n    addMark: bindFirst(addMark, editor),\n    deleteBackward: bindFirst(deleteBackward, editor),\n    deleteForward: bindFirst(deleteForward, editor),\n    deleteFragment: bindFirst(deleteFragment, editor),\n    getDirtyPaths: bindFirst(getDirtyPaths, editor as any),\n    getFragment: bindFirst(getFragment, editor),\n    insertBreak: bindFirst(insertBreak, editor),\n    insertFragment: bindFirst(insertFragment, editor),\n    insertNode: bindFirst(insertNode, editor),\n    insertSoftBreak: bindFirst(insertSoftBreak, editor as any),\n    insertText: bindFirst(insertText, editor),\n    normalizeNode: bindFirst(normalizeNode, editor as any),\n    removeMark: bindFirst(removeEditorMark, editor as any),\n    shouldNormalize: bindFirst(shouldNormalize, editor as any),\n  });\n\n  Object.assign(editor, {\n    above: bindFirst(above, editor),\n    after: bindFirst(getPointAfter, editor),\n    before: bindFirst(getPointBefore, editor),\n    collapse: bindFirst(collapseSelection, editor),\n    delete: bindFirst(deleteText, editor),\n    deselect: bindFirst(deselect, editor),\n    deselectDOM: bindFirst(deselectDOM, editor),\n    edges: bindFirst(getEdgePoints, editor),\n    elementReadOnly: bindFirst(isElementReadOnly, editor),\n    end: bindFirst(getEndPoint, editor),\n    first: bindFirst(getFirstNode, editor),\n    fragment: bindFirst(getFragment, editor),\n    getMarks: bindFirst(getMarks, editor),\n    hasBlocks: bindFirst(hasBlocks, editor),\n    hasInlines: bindFirst(hasInlines, editor),\n    hasPath: bindFirst(hasPath, editor as any),\n    hasTexts: bindFirst(hasTexts, editor),\n    insertNodes: bindFirst(insertNodes, editor),\n    isBlock: bindFirst(isBlock, editor),\n    isEdge: bindFirst(isEdgePoint, editor),\n    isEmpty: bindFirst(isEmpty, editor),\n    isEnd: bindFirst(isEndPoint, editor),\n    isNormalizing: bindFirst(isEditorNormalizing, editor),\n    isStart: bindFirst(isStartPoint, editor),\n    last: bindFirst(last, editor),\n    leaf: bindFirst(getLeafNode, editor),\n    levels: bindFirst(getLevels, editor),\n    liftNodes: bindFirst(liftNodes, editor),\n    mergeNodes: bindFirst(mergeNodes, editor),\n    move: bindFirst(moveSelection, editor),\n    moveNodes: bindFirst(moveNodes, editor),\n    next: bindFirst(next, editor),\n    node: bindFirst(node, editor),\n    nodes: bindFirst(nodes, editor),\n    normalize: bindFirst(normalizeEditor, editor),\n    parent: bindFirst(parent, editor),\n    path: bindFirst(path, editor),\n    pathRef: bindFirst(createPathRef, editor),\n    pathRefs: bindFirst(getPathRefs, editor),\n    point: bindFirst(getPoint, editor),\n    pointRef: bindFirst(createPointRef, editor),\n    pointRefs: bindFirst(getPointRefs, editor),\n    positions: bindFirst(getPositions, editor),\n    previous: bindFirst(previous, editor),\n    range: bindFirst(range, editor),\n    rangeRef: bindFirst(createRangeRef, editor),\n    rangeRefs: bindFirst(getRangeRefs, editor),\n    removeNodes: bindFirst(removeNodes, editor),\n    select: bindFirst(select, editor),\n    setNodes: bindFirst(setNodes, editor),\n    setNormalizing: bindFirst(setNormalizing, editor as any),\n    setPoint: bindFirst(setPoint, editor),\n    setSelection: bindFirst(setSelection, editor),\n    shouldMergeNodes: bindFirst(shouldMergeNodes, editor as any),\n    splitNodes: bindFirst(splitNodes, editor),\n    start: bindFirst(getStartPoint, editor),\n    string: bindFirst(getEditorString, editor),\n    unhangRange: bindFirst(unhangRange, editor),\n    unsetNodes: bindFirst(unsetNodes, editor),\n    unwrapNodes: bindFirst(unwrapNodes, editor),\n    void: bindFirst(getVoidNode, editor),\n    withoutNormalizing: bindFirst(withoutNormalizing, editor as any),\n    wrapNodes: bindFirst(wrapNodes, editor),\n  });\n\n  Object.assign(editor, {\n    history: { redos: [], undos: [] },\n    meta: {},\n    redo: noop('redo'),\n    undo: noop('undo'),\n    writeHistory: noop('writeHistory'),\n  });\n\n  Object.assign(editor, {\n    insertData: noop('insertData'),\n    insertFragmentData: noop('insertFragmentData', false),\n    insertTextData: noop('insertTextData', false),\n    setFragmentData: noop('setFragmentData'),\n  });\n\n  const api: Partial<EditorApi<V>> = {\n    block: bindFirst(block, editor) as any,\n    blocks: bindFirst(blocks, editor) as any,\n    create: {\n      block: (props) => ({ children: [{ text: '' }], type: 'p', ...props }),\n      value: () => [api.create!.block()],\n    },\n    descendant: bindFirst(descendant, editor) as any,\n    edgeBlocks: bindFirst(edgeBlocks, editor) as any,\n    findDocumentOrShadowRoot: bindFirst(findDocumentOrShadowRoot, editor),\n    findEventRange: bindFirst(findEventRange, editor),\n    findKey: bindFirst(findKey, editor),\n    findPath: bindFirst(findPath, editor),\n    getWindow: bindFirst(getWindow, editor),\n    hasDOMNode: bindFirst(hasDOMNode, editor),\n    hasEditableTarget: bindFirst(hasEditableTarget, editor) as any,\n    hasMark: bindFirst(hasMark, editor) as any,\n    hasRange: bindFirst(hasRange, editor),\n    hasSelectableTarget: bindFirst(hasSelectableTarget, editor) as any,\n    hasTarget: bindFirst(hasTarget, editor) as any,\n    isAt: bindFirst(isAt, editor),\n    isComposing: bindFirst(isComposing, editor),\n    isEditorEnd: bindFirst(isEditorEnd, editor),\n    isFocused: bindFirst(isFocused, editor),\n    isMerging: bindFirst(HistoryApi.isMerging, editor as any) as any,\n    isReadOnly: bindFirst(isReadOnly, editor),\n    isSaving: bindFirst(HistoryApi.isSaving, editor as any) as any,\n    isSelected: bindFirst(isSelected, editor),\n    isSplittingOnce: bindFirst(HistoryApi.isSplittingOnce, editor as any),\n    isTargetInsideNonReadonlyVoid: bindFirst(\n      isTargetInsideNonReadonlyVoid,\n      editor\n    ),\n    isText: bindFirst(isText, editor),\n    mark: bindFirst(mark, editor) as any,\n    nodesRange: bindFirst(nodesRange, editor),\n    prop: prop as any,\n    scrollIntoView: bindFirst(scrollIntoView, editor),\n    some: bindFirst(some, editor),\n    toDOMNode: bindFirst(toDOMNode, editor),\n    toDOMPoint: bindFirst(toDOMPoint, editor),\n    toDOMRange: bindFirst(toDOMRange, editor),\n    toSlateNode: bindFirst(toSlateNode, editor) as any,\n    toSlatePoint: bindFirst(toSlatePoint, editor),\n    toSlateRange: bindFirst(toSlateRange, editor),\n    isCollapsed: () => RangeApi.isCollapsed(editor.selection),\n    isExpanded: () => RangeApi.isExpanded(editor.selection),\n    shouldNormalizeNode: () => true,\n  };\n\n  const transforms: Partial<Editor<V>['transforms']> = {\n    addMarks: bindFirst(addMarks, editor),\n    blur: bindFirst(blur, editor),\n    deselectDOM: bindFirst(deselectDOM, editor),\n    duplicateNodes: bindFirst(duplicateNodes, editor),\n    focus: bindFirst(focus, editor),\n    removeMarks: bindFirst(removeMarks, editor as any),\n    replaceNodes: bindFirst(replaceNodes, editor) as any,\n    reset: bindFirst(reset, editor),\n    setSplittingOnce: bindFirst(HistoryApi.setSplittingOnce, editor as any),\n    toggleBlock: bindFirst(toggleBlock, editor),\n    toggleMark: bindFirst(toggleMark, editor as any),\n    withMerging: bindFirst(HistoryApi.withMerging, editor as any),\n    withNewBatch: bindFirst(HistoryApi.withNewBatch, editor as any),\n    withoutMerging: bindFirst(HistoryApi.withoutMerging, editor as any),\n    withoutSaving: bindFirst(HistoryApi.withoutSaving, editor as any),\n    escape: () => false,\n    moveLine: () => false,\n    selectAll: () => false,\n    tab: () => false,\n  };\n\n  editor.api = api as any;\n  editor.tf = transforms as any;\n  editor.transforms = transforms as any;\n\n  syncLegacyMethods(editor);\n\n  return editor as unknown as Editor<V>;\n};\n","import type { UnknownObject } from '@udecode/utils';\n\nimport { Element as SlateElement } from 'slate';\n\nimport type { Editor, Value } from './editor';\nimport type { Ancestor, Descendant, TNode } from './node';\nimport type { TextIn, TextOf } from './text';\n\n/**\n * `TElement` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\nexport type TElement = {\n  children: Descendant[];\n  type: string;\n} & UnknownObject;\n\n/** Element retrieval and check methods. */\nexport const ElementApi: {\n  /** Check if a value implements the 'Ancestor' interface. */\n  isAncestor: <T extends Ancestor>(value: any) => value is T;\n  /** Check if a value implements the `TElement` interface. */\n  isElement: <T extends TElement>(value: any) => value is T;\n  /** Check if a value is an array of `TElement` objects. */\n  isElementList: <T extends TElement>(value: any) => value is T[];\n  /** Check if a set of props is a partial of TElement. */\n  isElementProps: <T extends TElement>(props: any) => props is Partial<T>;\n  /**\n   * Check if a value implements the `TElement` interface and has elementKey\n   * with selected value. Default it check to `type` key value\n   */\n  isElementType: <T extends TElement>(\n    value: any,\n    elementVal: string,\n    elementKey?: string\n  ) => value is T;\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n  matches: (element: TElement, props: Partial<TElement>) => boolean;\n} = {\n  ...(SlateElement as any),\n};\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\nexport type Element = TElement;\n\n/** A utility type to get all the element nodes type from a root node. */\nexport type ElementIn<V extends Value> = ElementOf<V[number]>;\n\nexport type ElementOf<N extends TNode> = Editor extends N\n  ? TElement\n  : TElement extends N\n    ? TElement\n    : N extends Editor\n      ?\n          | ElementOf<N['children'][number]>\n          | Extract<N['children'][number], TElement>\n      : N extends TElement\n        ?\n            | ElementOf<N['children'][number]>\n            | Extract<N['children'][number], TElement>\n            | N\n        : never;\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n// export type ElementEntry = [TElement, Path];\n\n/** Element or text of an editor. */\nexport type ElementOrTextIn<V extends Value> = ElementIn<V> | TextIn<V>;\n\nexport type ElementOrTextOf<E extends Editor> = ElementOf<E> | TextOf<E>;\n","import { PointRef as SlatePointRef, RangeRef as SlateRangeRef } from 'slate';\n\nimport type { TextDirection } from '../types';\nimport type { Operation } from './operation';\nimport type { Point } from './point';\nimport type { TRange } from './range';\n\nimport { type Path, PathApi } from './path';\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\nexport type PathRef = {\n  affinity: 'backward' | 'forward' | null;\n  current: Path | null;\n  unref: () => Path | null;\n};\n\nexport const PathRefApi: {\n  /** Transform the path ref's current value by an operation. */\n  transform: (ref: PathRef, op: Operation) => void;\n} = {\n  transform(ref, op) {\n    const { affinity, current } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    const path = PathApi.transform(current, op, { affinity });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  },\n};\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as\n * new operations are applied to the editor. You can access their `current`\n * property at any time for the up-to-date point value.\n */\nexport type PointRef = {\n  affinity: TextDirection | null;\n  current: Point | null;\n  unref: () => Point | null;\n};\n\nexport const PointRefApi: {\n  /** Transform the point ref's current value by an operation. */\n  transform: (ref: PointRef, op: Operation) => void;\n} = SlatePointRef as any;\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as\n * new operations are applied to the editor. You can access their `current`\n * property at any time for the up-to-date range value.\n */\nexport type RangeRef = {\n  affinity: 'backward' | 'forward' | 'inward' | 'outward' | null;\n  current: TRange | null;\n  unref: () => TRange | null;\n};\n\nexport const RangeRefApi: {\n  /** Transform the range ref's current value by an operation. */\n  transform: (ref: RangeRef, op: Operation) => void;\n} = SlateRangeRef as any;\n","import { Path as SlatePath } from 'slate';\n\nimport type {\n  InsertNodeOperation,\n  MergeNodeOperation,\n  MoveNodeOperation,\n  Operation,\n  RemoveNodeOperation,\n  SplitNodeOperation,\n} from '../interfaces/operation';\nimport type { TextDirection } from '../types';\nimport type { Descendant } from './node';\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\nexport type Path = number[];\n\n/** Path retrieval, check and transform methods. */\nexport const PathApi: {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n  ancestors: (path: Path, options?: PathAncestorsOptions) => Path[];\n  /** Get a path to a child at the given index. */\n  child: (path: Path, index: number) => Path;\n  /** Get the common ancestor path of two paths. */\n  common: (path: Path, another: Path) => Path;\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[PathApi.equals]] instead.\n   */\n  compare: (path: Path, another: Path) => -1 | 0 | 1;\n  /** Check if a path ends after one of the indexes in another. */\n  endsAfter: (path: Path, another: Path) => boolean;\n  /** Check if a path ends at one of the indexes in another. */\n  endsAt: (path: Path, another: Path) => boolean;\n  /** Check if a path ends before one of the indexes in another. */\n  endsBefore: (path: Path, another: Path) => boolean;\n  /** Check if a path is exactly equal to another. */\n  equals: (path: Path, another: Path) => boolean;\n  /** Get a path to the first child of a path. */\n  firstChild: (path: Path) => Path;\n  /** Check if the path of previous sibling node exists */\n  hasPrevious: (path: Path) => boolean;\n  /** Check if a path is after another. */\n  isAfter: (path: Path, another: Path) => boolean;\n  /** Check if a path is an ancestor of another. */\n  isAncestor: (path: Path, another: Path) => boolean;\n  /** Check if a path is before another. */\n  isBefore: (path: Path, another: Path) => boolean;\n  /** Check if a path is a child of another. */\n  isChild: (path: Path, another: Path) => boolean;\n  /** Check if a path is equal to or an ancestor of another. */\n  isCommon: (path: Path, another: Path) => boolean;\n  /** Check if a path is a descendant of another. */\n  isDescendant: (path: Path, another: Path) => boolean;\n  /** Check if a path is the parent of another. */\n  isParent: (path: Path, another: Path) => boolean;\n  /** Check is a value implements the `Path` interface. */\n  isPath: (value: any) => value is Path;\n  /** Check if a path is a sibling of another. */\n  isSibling: (path: Path, another: Path) => boolean;\n  /** Get the last index of a path. Returns -1 if path is empty. */\n  lastIndex: (path: Path) => number;\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `PathApi.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n  levels: (path: Path, options?: PathLevelsOptions) => Path[];\n  /** Given a path, get the path to the next sibling node. */\n  next: (path: Path) => Path;\n  /**\n   * Returns whether this operation can affect paths or not. Used as an\n   * optimization when updating dirty paths during normalization\n   *\n   * NOTE: This _must_ be kept in sync with the implementation of 'transform'\n   * below\n   */\n  operationCanTransformPath: <N extends Descendant>(\n    operation: Operation<N>\n  ) => operation is\n    | InsertNodeOperation<N>\n    | MergeNodeOperation<N>\n    | MoveNodeOperation\n    | RemoveNodeOperation<N>\n    | SplitNodeOperation<N>;\n  /** Given a path, return a new path referring to the parent node above it. */\n  parent: (path: Path) => Path;\n  /** Given a path, get the path to the previous sibling node. */\n  previous: (path: Path) => Path | undefined;\n  /** Get a path relative to an ancestor. */\n  relative: (path: Path, ancestor: Path) => Path;\n  /** Transform a path by an operation. */\n  transform: (\n    path: Path,\n    operation: Operation,\n    options?: PathTransformOptions\n  ) => Path | null;\n} = {\n  ...(SlatePath as any),\n  child: (path, index) => path.concat([index]),\n  firstChild: (path) => PathApi.child(path, 0),\n  lastIndex: (path) => path.at(-1) ?? -1,\n  next: (path) => {\n    try {\n      return SlatePath.next(path);\n    } catch {\n      return path;\n    }\n  },\n  parent: (path) => {\n    try {\n      return SlatePath.parent(path);\n    } catch {\n      return path;\n    }\n  },\n  previous: (path) => {\n    if (path.length === 0) return;\n\n    const last = path.at(-1)!;\n\n    if (last <= 0) return;\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n} as const;\n\nexport interface PathAncestorsOptions {\n  /** If true, the paths are returned in reverse order. */\n  reverse?: boolean;\n}\n\nexport interface PathLevelsOptions {\n  /** If true, the paths are returned in reverse order. */\n  reverse?: boolean;\n}\n\nexport interface PathTransformOptions {\n  /** The affinity of the transform. */\n  affinity?: TextDirection | null;\n}\n","import { Location as SlateLocation, Span as SlateSpan } from 'slate';\n\nimport type { At } from '../types';\nimport type { Path } from './path';\nimport type { Point } from './point';\nimport type { Range, TRange } from './range';\n\nimport { NodeApi } from './node';\n\n/**\n * The `TLocation` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `TRange`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\nexport type TLocation = Path | Point | TRange;\n\n/** Location check methods. */\nexport const LocationApi: {\n  /** Check if a value implements the `At` interface. */\n  isAt: (value: any) => value is At;\n  /** Check if a value implements the `Location` interface. */\n  isLocation: (value: any) => value is Location;\n} = {\n  ...(SlateLocation as any),\n  isAt: (value) => LocationApi.isLocation(value) || NodeApi.isNode(value),\n};\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\nexport type Span = [Path, Path];\n\nexport const SpanApi: {\n  /** Check if a value implements the `Span` interface. */\n  isSpan: (value: any) => value is Span;\n} = SlateSpan as any;\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\nexport type Location = Path | Point | Range;\n","import { Node as SlateNode } from 'slate';\n\nimport type { Editor, Value } from './editor/editor-type';\nimport type { NodeEntry } from './node-entry';\nimport type { Path } from './path';\nimport type { TRange } from './range';\n\nimport { NodeExtension } from '../internal/editor-extension/node-extension';\nimport { type ElementOf, type TElement, ElementApi } from './element';\nimport { type TextOf, type TText, TextApi } from './text';\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree. It\n * is returned as a convenience in certain cases to narrow a value further than\n * the more generic `Node` union.\n */\nexport type Ancestor = Editor | TElement;\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = TElement | TText;\n\n/** Convenience type for returning the props of a node. */\nexport type NodeProps<N extends TNode = TNode> = N extends Editor\n  ? Omit<N, 'children'>\n  : N extends TElement\n    ? Omit<N, 'children'>\n    : Omit<N, 'text'>;\n\n/**\n * The `TNode` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\nexport type TNode = Editor | TElement | TText;\n\nexport const NodeApi: {\n  /** Get the node at a specific path, asserting that it's an ancestor node. */\n  ancestor: <N extends AncestorOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => N | undefined;\n  /**\n   * Return a generator of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in the\n   * tree, but you can pass the `reverse: true` option to go top-down.\n   */\n  ancestors: <N extends AncestorOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path,\n    options?: NodeAncestorsOptions\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /** Get the child of a node at a specific index. */\n  child: <\n    N extends ChildOf<R, I>,\n    R extends TNode = TNode,\n    I extends number = number,\n  >(\n    root: R,\n    index: I\n  ) => N | undefined;\n  /** Iterate over the children of a node at a specific path. */\n  children: <N extends ChildOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path,\n    options?: NodeChildrenOptions\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /** Get an entry for the common ancestor node of two paths. */\n  common: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path,\n    another: Path\n  ) => NodeEntry<N> | undefined;\n  /** Get the node at a specific path, asserting that it's a descendant node. */\n  descendant: <N extends DescendantOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => N | undefined;\n  /** Return a generator of all the descendant node entries inside a root node. */\n  descendants: <N extends DescendantOf<R>, R extends TNode = TNode>(\n    root: R,\n    options?: NodeDescendantsOptions<R>\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /**\n   * Return a generator of all the element nodes inside a root node. Each\n   * iteration will return an `ElementEntry` tuple consisting of `[Element,\n   * Path]`. If the root node is an element it will be included in the iteration\n   * as well.\n   */\n  elements: <N extends ElementOf<R>, R extends TNode = TNode>(\n    root: R,\n    options?: NodeElementsOptions<R>\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /** Extract props from a TNode. */\n  extractProps: <N extends TNode>(node: N) => NodeProps<N>;\n  /** Get the first node entry in a root node from a path. */\n  first: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => NodeEntry<N> | undefined;\n  /** Get the first child node entry of a node. */\n  firstChild: <N extends ChildOf<R, 0>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => NodeEntry<N> | undefined;\n  /** Get the first text node entry of a node. */\n  firstText: <N extends TextOf<R>, R extends TNode = TNode>(\n    root: R,\n    options?: NodeTextsOptions<R>\n  ) => NodeEntry<N> | undefined;\n  /** Get the sliced fragment represented by a range inside a root node. */\n  fragment: <N extends ElementOf<R> | TextOf<R>, R extends TNode = TNode>(\n    root: R,\n    range: TRange\n  ) => N[];\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n  get: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => N | undefined;\n  /** Similar to get, but returns undefined if the node does not exist. */\n  getIf: (root: TNode, path: Path) => TNode | undefined;\n  /** Check if a descendant node exists at a specific path. */\n  has: (root: TNode, path: Path) => boolean;\n  /** Check if a node has a single child */\n  hasSingleChild: (node: TNode) => boolean;\n  /** Check if a value implements the 'Ancestor' interface */\n  isAncestor: <N extends Ancestor>(value: any) => value is N;\n  /** Check if a value implements the 'Descendant' interface. */\n  isDescendant: <N extends Descendant>(value: any) => value is N;\n  /** Check if a value implements the `Editor` interface. */\n  isEditor: (value: any) => value is Editor;\n  /** Check if a node is the last child of its parent. */\n  isLastChild: (root: TNode, path: Path) => boolean;\n  /** Check if a value implements the `TNode` interface. */\n  isNode: <N extends TNode>(value: any) => value is N;\n  /** Check if a value is a list of `Descendant` objects. */\n  isNodeList: <N extends Descendant>(value: any) => value is N[];\n  /** Get the last node entry in a root node from a path. */\n  last: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => NodeEntry<N> | undefined;\n  /** Get the last child node entry of a node. */\n  lastChild: <N extends ChildOf<R, -1>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => NodeEntry<N> | undefined;\n  /** Get the node at a specific path, ensuring it's a leaf text node. */\n  leaf: <N extends TextOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => N | undefined;\n  /**\n   * Return a generator of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from highest to lowest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n  levels: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path,\n    options?: NodeLevelsOptions\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /** Check if a node matches a set of props. */\n  matches: (node: Descendant, props: Partial<Descendant>) => boolean;\n  /**\n   * Return a generator of all the node entries of a root node. Each entry is\n   * returned as a `[TNode, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n  nodes: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    options?: NodeNodesOptions<R>\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /** Get the parent of a node at a specific path. */\n  parent: <N extends AncestorOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => N | undefined;\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n  string: (node: TNode) => string;\n  /** Return a generator of all leaf text nodes in a root node. */\n  texts: <N extends TextOf<R>, R extends TNode = TNode>(\n    root: R,\n    options?: NodeTextsOptions<R>\n  ) => Generator<NodeEntry<N>, void, undefined>;\n} = {\n  ...(SlateNode as any),\n  isAncestor: ElementApi.isAncestor,\n  ancestor: (...args) => {\n    try {\n      return SlateNode.ancestor(...args);\n    } catch {}\n  },\n  common: (...args) => {\n    try {\n      return SlateNode.common(...args);\n    } catch {}\n  },\n  descendant: (...args) => {\n    try {\n      return SlateNode.descendant(...args);\n    } catch {}\n  },\n  first: (...args) => {\n    try {\n      return SlateNode.first(...args);\n    } catch {}\n  },\n  fragment: (...args) => {\n    try {\n      return SlateNode.fragment(...args);\n    } catch {\n      return [];\n    }\n  },\n  get: (...args) => {\n    try {\n      return SlateNode.get(...args);\n    } catch {}\n  },\n  hasSingleChild: (node) => {\n    if (TextApi.isText(node)) return true;\n\n    return (\n      node.children.length === 1 && NodeApi.hasSingleChild(node.children[0])\n    );\n  },\n  isDescendant: (node) => ElementApi.isElement(node) || TextApi.isText(node),\n  last: (...args) => {\n    try {\n      return SlateNode.last(...args);\n    } catch {}\n  },\n  leaf: (...args) => {\n    try {\n      return SlateNode.leaf(...args);\n    } catch {}\n  },\n  parent: (...args) => {\n    try {\n      return SlateNode.parent(...args);\n    } catch {}\n  },\n  ...NodeExtension,\n};\n\n/** A utility type to get all the ancestor node types from a root node type. */\nexport type AncestorIn<V extends Value> = AncestorOf<Editor | V[number]>;\n\nexport type AncestorOf<N extends TNode> = Editor extends N\n  ? Editor | TElement\n  : TElement extends N\n    ? TElement\n    : N extends Editor\n      ? ElementOf<N['children'][number]> | N | N['children'][number]\n      : N extends TElement\n        ? ElementOf<N> | N\n        : never;\n\n/** A utility type to get the child node types from a root node type. */\nexport type ChildOf<\n  N extends TNode,\n  I extends number = number,\n> = N extends Editor\n  ? N['children'][I]\n  : N extends TElement\n    ? N['children'][I]\n    : never;\n\n/** A utility type to get all the descendant node types from a root node type. */\nexport type DescendantIn<V extends Value> = DescendantOf<V[number]>;\n\nexport type DescendantOf<N extends TNode> = N extends Editor\n  ? ElementOf<N> | TextOf<N>\n  : N extends TElement\n    ? ElementOf<N['children'][number]> | TextOf<N>\n    : never;\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\nexport type Node = TNode;\n\nexport interface NodeAncestorsOptions {\n  reverse?: boolean;\n}\n\nexport interface NodeChildrenOptions {\n  /** Get children starting from this index (inclusive) */\n  from?: number;\n  reverse?: boolean;\n  /** Get children up to this index (exclusive) */\n  to?: number;\n}\n\nexport interface NodeDescendantsOptions<N extends TNode> {\n  from?: Path;\n  reverse?: boolean;\n  to?: Path;\n  pass?: (entry: NodeEntry<DescendantOf<N>>) => boolean;\n}\n\nexport interface NodeElementsOptions<N extends TNode> {\n  from?: Path;\n  reverse?: boolean;\n  to?: Path;\n  pass?: (entry: NodeEntry<ElementOf<N>>) => boolean;\n}\n\n/** A utility type to get all possible node types from a Value type */\nexport type NodeIn<V extends Value> = NodeOf<Editor | V[number]>;\n\nexport interface NodeLevelsOptions {\n  reverse?: boolean;\n}\n\nexport interface NodeNodesOptions<N extends TNode> {\n  from?: Path;\n  reverse?: boolean;\n  to?: Path;\n  pass?: (entry: NodeEntry<NodeOf<N>>) => boolean;\n}\n\n/** A utility type to get all the node types from a root node type. */\nexport type NodeOf<N extends TNode> = ElementOf<N> | N | TextOf<N>;\n\nexport interface NodeTextsOptions<N extends TNode> {\n  from?: Path;\n  reverse?: boolean;\n  to?: Path;\n  pass?: (entry: NodeEntry<TextOf<N>>) => boolean;\n}\n\n/** A helper type for narrowing matched nodes with a predicate. */\nexport type TNodeMatch<N extends TNode = TNode> =\n  | ((node: N, path: Path) => boolean)\n  | ((node: N, path: Path) => node is N);\n","import { isEditor } from 'slate';\n\nimport { NodeApi } from '../../interfaces';\n\nexport const NodeExtension = {\n  *children(root, path, options = {}) {\n    const { from, reverse = false, to } = options;\n    const ancestor = NodeApi.ancestor(root, path);\n\n    if (!ancestor) return;\n\n    const { children } = ancestor;\n    let index = reverse ? children.length - 1 : 0;\n    const endIndex = to ?? (reverse ? 0 : children.length);\n\n    if (from !== undefined) {\n      index = from;\n    }\n\n    while (reverse ? index >= endIndex : index < endIndex) {\n      const child = NodeApi.child(ancestor!, index);\n      const childPath = path.concat(index);\n      yield [child, childPath];\n      index = reverse ? index - 1 : index + 1;\n    }\n  },\n  firstChild(root, path) {\n    const children = NodeApi.children(root, path);\n    const firstChild = children.next().value;\n\n    return firstChild as any;\n  },\n  firstText(root, options) {\n    const texts = NodeApi.texts(root, options);\n    const firstText = texts.next().value;\n\n    return firstText as any;\n  },\n  isEditor: (value: any) => isEditor(value),\n  isLastChild(root, path) {\n    if (path.length === 0) return false;\n\n    const parent = NodeApi.parent(root, path);\n\n    if (!parent) return false;\n\n    const index = path.at(-1);\n\n    return index === parent.children.length - 1;\n  },\n  lastChild(root, path) {\n    const children = NodeApi.children(root, path, { reverse: true });\n    const lastChild = children.next().value;\n\n    return lastChild as any;\n  },\n} as Pick<\n  typeof NodeApi,\n  'children' | 'firstChild' | 'firstText' | 'isLastChild' | 'lastChild'\n>;\n","import type {\n  Simplify,\n  UnionToIntersection,\n  UnknownObject,\n} from '@udecode/utils';\n\nimport {\n  type DecoratedRange as SlateDecoratedRange,\n  Text as SlateText,\n} from 'slate';\n\nimport type { Editor, Value } from './editor/editor-type';\nimport type { TElement } from './element';\nimport type { NodeProps, TNode } from './node';\n\nexport type LeafPosition = {\n  end: number;\n  start: number;\n  isFirst?: true;\n  isLast?: true;\n};\n\n/**\n * `TText` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\nexport type TText = { text: string } & UnknownObject;\n\n/** Text retrieval and check methods. */\nexport const TextApi: {\n  /** Get the leaves for a text node given decorations. */\n  decorations: <N extends TText>(\n    node: TText,\n    decorations: DecoratedRange[]\n  ) => { leaf: N; position: LeafPosition }[];\n  /** Check if two text nodes are equal. */\n  equals: (text: TText, another: TText, options?: TextEqualsOptions) => boolean;\n  /** Check if a value implements the `Text` interface. */\n  isText: <N extends TText>(value: any) => value is N;\n  /** Check if a value is a list of `Text` objects. */\n  isTextList: <N extends TText>(value: any) => value is N[];\n  /** Check if some props are a partial of Text. */\n  isTextProps: <N extends TText>(props: any) => props is Partial<N>;\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n  matches: <N extends TText>(text: N, props: Partial<N>) => boolean;\n} = SlateText as any;\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\nexport type DecoratedRange = SlateDecoratedRange;\n\n/** A utility type to get all the mark types from a root node type. */\nexport type MarkKeysOf<N extends TNode> =\n  {} extends MarksOf<N> ? unknown : keyof MarksOf<N>;\n\nexport type MarksIn<V extends Value> = MarksOf<V[number]>;\n\nexport type MarksOf<N extends TNode> = Simplify<\n  UnionToIntersection<NodeProps<TextOf<N>>>\n>;\n\nexport type Text = TText;\n\nexport interface TextEqualsOptions {\n  /**\n   * If true, the text is not compared. This is used to check whether sibling\n   * text nodes can be merged.\n   */\n  loose?: boolean;\n}\n\n/** A utility type to get all the text node types from a root node type. */\nexport type TextIn<V extends Value> = TextOf<V[number]>;\n\nexport type TextOf<N extends TNode> = Editor extends N\n  ? TText\n  : TElement extends N\n    ? TText\n    : N extends Editor\n      ? TextOf<N['children'][number]>\n      : N extends TElement\n        ? Extract<N['children'][number], TText> | TextOf<N['children'][number]>\n        : N extends TText\n          ? N\n          : never;\n","import { Operation as SlateOperation } from 'slate';\n\nimport type { Descendant, NodeProps } from './node';\nimport type { Path } from './path';\nimport type { TRange } from './range';\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\nexport type Operation<N extends Descendant = Descendant> =\n  | NodeOperation<N>\n  | SelectionOperation\n  | TextOperation;\n\n/** Operation manipulation and check methods. */\nexport const OperationApi: {\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n  inverse: (op: Operation) => Operation;\n  /** Check if a value is a `NodeOperation` object. */\n  isNodeOperation: <N extends Descendant>(\n    value: any\n  ) => value is NodeOperation<N>;\n  /** Check if a value is an `Operation` object. */\n  isOperation: <N extends Descendant>(value: any) => value is Operation<N>;\n  /** Check if a value is a list of `Operation` objects. */\n  isOperationList: (value: any) => value is Operation[];\n  /** Check if a value is a `SelectionOperation` object. */\n  isSelectionOperation: (value: any) => value is SelectionOperation;\n  /** Check if a value is a `TextOperation` object. */\n  isTextOperation: (value: any) => value is TextOperation;\n} = SlateOperation as any;\n\nexport type InsertNodeOperation<N extends Descendant = Descendant> = {\n  [key: string]: unknown;\n  node: N;\n  path: Path;\n  type: 'insert_node';\n};\n\nexport type InsertTextOperation = {\n  [key: string]: unknown;\n  offset: number;\n  path: Path;\n  text: string;\n  type: 'insert_text';\n};\n\nexport type MergeNodeOperation<N extends Descendant = Descendant> = {\n  [key: string]: unknown;\n  path: Path;\n  position: number;\n  properties: Partial<NodeProps<N>>;\n  type: 'merge_node';\n};\n\nexport type MoveNodeOperation = {\n  [key: string]: unknown;\n  newPath: Path;\n  path: Path;\n  type: 'move_node';\n};\n\nexport type NodeOperation<N extends Descendant = Descendant> =\n  | InsertNodeOperation<N>\n  | MergeNodeOperation<N>\n  | MoveNodeOperation\n  | RemoveNodeOperation<N>\n  | SetNodeOperation<N>\n  | SplitNodeOperation<N>;\n\nexport type RemoveNodeOperation<N extends Descendant = Descendant> = {\n  [key: string]: unknown;\n  node: N;\n  path: Path;\n  type: 'remove_node';\n};\n\nexport type RemoveTextOperation = {\n  [key: string]: unknown;\n  offset: number;\n  path: Path;\n  text: string;\n  type: 'remove_text';\n};\n\nexport type SelectionOperation = SetSelectionOperation;\n\nexport type SetNodeOperation<\n  N1 extends Descendant = Descendant,\n  N2 extends Descendant = Descendant,\n> = {\n  [key: string]: unknown;\n  newProperties: Partial<NodeProps<N1>>;\n  path: Path;\n  properties: Partial<NodeProps<N2>>;\n  type: 'set_node';\n};\n\nexport type SetSelectionOperation =\n  | {\n      [key: string]: unknown;\n      newProperties: null;\n      properties: TRange;\n      type: 'set_selection';\n    }\n  | {\n      [key: string]: unknown;\n      newProperties: Partial<TRange>;\n      properties: Partial<TRange>;\n      type: 'set_selection';\n    }\n  | {\n      [key: string]: unknown;\n      newProperties: TRange;\n      properties: null;\n      type: 'set_selection';\n    };\n\nexport type SplitNodeOperation<N extends Descendant = Descendant> = {\n  [key: string]: unknown;\n  path: Path;\n  position: number;\n  properties: Partial<NodeProps<N>>;\n  type: 'split_node';\n};\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation;\n","import { Point as SlatePoint } from 'slate';\n\nimport type { At, TextDirection } from '../types';\nimport type { Operation } from './operation';\n\nimport { type Path, PathApi } from './path';\nimport { RangeApi } from './range';\n\nexport type Point = {\n  /** The index of the character in the text node. */\n  offset: number;\n  /** The path to the text node. */\n  path: Path;\n};\n\n/** Point retrieval, check and transform methods. */\nexport const PointApi: {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n  compare: (point: Point, another: Point) => -1 | 0 | 1;\n  /** Check if a point is exactly equal to another. */\n  equals: (point: Point, another: Point) => boolean;\n  /**\n   * Get the point from a location. If the location is a range, get the anchor\n   * point (if `focus` is true, get the focus point). If the location is a path,\n   * get the point at this path with offset 0.\n   */\n  get: (\n    at?: At | null,\n    {\n      focus,\n    }?: {\n      focus?: boolean;\n    }\n  ) => Point | undefined;\n  /** Check if a point is after another. */\n  isAfter: (point: Point, another: Point) => boolean;\n  /** Check if a point is before another. */\n  isBefore: (point: Point, another: Point) => boolean;\n  /** Check if a value implements the `Point` interface. */\n  isPoint: (value: any) => value is Point;\n  /** Transform a point by an operation. */\n  transform: (\n    point: Point,\n    op: Operation,\n    options?: PointTransformOptions\n  ) => Point | null;\n} = {\n  ...(SlatePoint as any),\n  get: (at, { focus } = {}) => {\n    let point: Point | undefined;\n\n    if (RangeApi.isRange(at)) point = focus ? at.focus : at.anchor;\n    if (PointApi.isPoint(at)) point = at;\n    if (PathApi.isPath(at)) point = { offset: 0, path: at };\n\n    return point;\n  },\n};\n\nexport type PointEntry = [Point, 'anchor' | 'focus'];\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport interface PointTransformOptions {\n  affinity?: TextDirection | null;\n}\n","import { Range as SlateRange } from 'slate';\n\nimport type { RangeDirection } from '../types';\nimport type { Operation } from './operation';\nimport type { Path } from './path';\nimport type { Point, PointEntry } from './point';\n\n/**\n * `TRange` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\nexport type TRange = {\n  /** The start point of the range. */\n  anchor: Point;\n  /** The end point of the range. */\n  focus: Point;\n};\n\nexport const RangeApi: {\n  /**\n   * Check if a range fully contains another range, meaning that both the start\n   * and end points of the target range are included in the range.\n   */\n  contains: (range: TRange, target: TRange) => boolean;\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n  edges: (range: TRange, options?: RangeEdgesOptions) => [Point, Point];\n  /** Get the end point of a range. */\n  end: (range: TRange) => Point;\n  /** Check if a range is exactly equal to another. */\n  equals: (range: TRange, another: TRange) => boolean;\n  /** Check if a range includes a path, a point or part of another range. */\n  includes: (range: TRange, target: Path | Point | TRange) => boolean;\n  /** Get the intersection of a range with another. */\n  intersection: (range: TRange, another: TRange) => TRange | null;\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n  isBackward: (range: TRange) => boolean;\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n  isCollapsed: (range?: TRange | null) => boolean;\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[RangeApi.isCollapsed]] and is provided for\n   * legibility.\n   */\n  isExpanded: (range?: TRange | null) => boolean;\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[RangeApi.isBackward]] and is provided for\n   * legibility.\n   */\n  isForward: (range: TRange) => boolean;\n  /** Check if a value implements the [[TRange]] interface. */\n  isRange: (value: any) => value is TRange;\n  /** Iterate through all of the point entries in a range. */\n  points: (range: TRange) => Generator<PointEntry, void, undefined>;\n  /** Get the start point of a range. */\n  start: (range: TRange) => Point;\n  /** Check if a range includes another range. */\n  surrounds: (range: TRange, target: TRange) => boolean;\n  /** Transform a range by an operation. */\n  transform: (\n    range: TRange,\n    op: Operation,\n    options?: RangeTransformOptions\n  ) => TRange | null;\n} = {\n  ...SlateRange,\n  contains: (range: TRange, target: TRange) => {\n    const [targetStart, targetEnd] = RangeApi.edges(target);\n\n    return (\n      RangeApi.includes(range, targetStart) &&\n      RangeApi.includes(range, targetEnd)\n    );\n  },\n  isCollapsed: (range?: TRange | null) =>\n    !!range && SlateRange.isCollapsed(range),\n  isExpanded: (range?: TRange | null) =>\n    !!range && SlateRange.isExpanded(range),\n} as any;\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\nexport type Range = TRange;\n\nexport interface RangeEdgesOptions {\n  reverse?: boolean;\n}\n\nexport interface RangeTransformOptions {\n  affinity?: RangeDirection | null;\n}\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const blur = (editor: Editor) => DOMEditor.blur(editor as any);\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const deselectDOM = (editor: Editor) =>\n  DOMEditor.deselect(editor as any);\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const findDocumentOrShadowRoot = (editor: Editor) => {\n  try {\n    return DOMEditor.findDocumentOrShadowRoot(editor as any);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const findEventRange = (editor: Editor, event: any) => {\n  try {\n    return DOMEditor.findEventRange(editor as any, event);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { TNode } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor';\n\nexport const findKey = (editor: Editor, node: TNode) => {\n  try {\n    return DOMEditor.findKey(editor as any, node);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Path } from '../../interfaces';\nimport type { Editor, EditorFindPathOptions } from '../../interfaces/editor';\nimport type { TNode } from '../../interfaces/node';\n\nexport const findPath = (\n  editor: Editor,\n  node: TNode,\n  options?: EditorFindPathOptions\n): Path | undefined => {\n  const findNodePath = () => {\n    const nodeEntry = editor.api.node({\n      ...options,\n      at: [],\n      match: (n) => n === node,\n    });\n\n    return nodeEntry?.[1];\n  };\n\n  if (options) {\n    return findNodePath();\n  }\n\n  try {\n    return DOMEditor.findPath(editor as any, node);\n  } catch {\n    return findNodePath();\n  }\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor, FocusOptions } from '../../interfaces/editor';\nimport type { At } from '../../types';\n\nexport const focus = (\n  editor: Editor,\n  { at, edge, retries = 5 }: FocusOptions = {}\n) => {\n  const reselect = (at: At) => {\n    editor.tf.withoutNormalizing(() => {\n      editor.tf.deselect();\n      editor.tf.select(at);\n    });\n  };\n\n  if (edge) {\n    const target: At | null =\n      edge === 'startEditor' || edge === 'endEditor'\n        ? []\n        : (at ?? editor.selection);\n\n    if (target) {\n      reselect(\n        edge === 'start' ? editor.api.start(target)! : editor.api.end(target)!\n      );\n    }\n  } else if (at) {\n    reselect(at);\n  }\n\n  try {\n    DOMEditor.focus(editor as any, { retries });\n  } catch (error) {\n    console.error(error);\n  }\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const getWindow = (editor: Editor) => {\n  try {\n    return DOMEditor.getWindow(editor as any);\n  } catch {}\n};\n","import type { DOMNode } from 'slate-dom';\n\nimport { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const hasDOMNode = (\n  editor: Editor,\n  target: DOMNode,\n  options?: Parameters<typeof DOMEditor.hasDOMNode>[2]\n) => {\n  try {\n    return DOMEditor.hasDOMNode(editor as any, target, options);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const hasEditableTarget = (\n  editor: Editor,\n  target: EventTarget | null\n): target is Node => {\n  try {\n    return DOMEditor.hasEditableTarget(editor as any, target);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { TRange } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor';\n\nexport const hasRange = (editor: Editor, range: TRange): boolean => {\n  try {\n    return DOMEditor.hasRange(editor as any, range);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const hasSelectableTarget = (\n  editor: Editor,\n  target: EventTarget | null\n) => {\n  try {\n    return DOMEditor.hasSelectableTarget(editor as any, target);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const hasTarget = (\n  editor: Editor,\n  target: EventTarget | null\n): target is Node => {\n  try {\n    return DOMEditor.hasTarget(editor as any, target);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const isComposing = (editor: Editor) =>\n  DOMEditor.isComposing(editor as any);\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const isFocused = (editor: Editor) => DOMEditor.isFocused(editor as any);\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const isReadOnly = (editor: Editor) =>\n  DOMEditor.isReadOnly(editor as any);\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const isTargetInsideNonReadonlyVoid = (\n  editor: Editor,\n  target: EventTarget | null\n) => {\n  try {\n    return DOMEditor.isTargetInsideNonReadonlyVoid(editor as any, target);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\nimport type { TNode } from '../../interfaces/node';\n\nexport const toDOMNode = (editor: Editor, node: TNode) => {\n  try {\n    return DOMEditor.toDOMNode(editor as any, node);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\nimport type { Point } from '../../interfaces/point';\n\nexport const toDOMPoint = (editor: Editor, point: Point) => {\n  try {\n    return DOMEditor.toDOMPoint(editor as any, point);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\nimport type { TRange } from '../../interfaces/range';\n\nexport const toDOMRange = (editor: Editor, range: TRange) => {\n  try {\n    return DOMEditor.toDOMRange(editor as any, range);\n  } catch {}\n};\n","import type { DOMNode } from 'slate-dom';\n\nimport { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\nimport type { TNode } from '../../interfaces/node';\n\nexport const toSlateNode = (editor: Editor, domNode: DOMNode) => {\n  try {\n    return DOMEditor.toSlateNode(editor as any, domNode) as TNode;\n  } catch {}\n};\n","import type { DOMPoint } from 'slate-dom';\n\nimport { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const toSlatePoint = (\n  editor: Editor,\n  domPoint: DOMPoint,\n  options: Omit<Parameters<typeof DOMEditor.toSlatePoint>[2], 'suppressThrow'>\n) => {\n  try {\n    return DOMEditor.toSlatePoint(editor as any, domPoint, options as any);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const toSlateRange = (\n  editor: Editor,\n  domRange: Parameters<typeof DOMEditor.toSlateRange>[1],\n  options: Omit<Parameters<typeof DOMEditor.toSlateRange>[2], 'supressThrow'>\n) => {\n  try {\n    return DOMEditor.toSlateRange(editor as any, domRange, options);\n  } catch {}\n};\n","import type {\n  Editor,\n  EditorAboveOptions,\n  ElementOf,\n  NodeEntry,\n  ValueOf,\n} from '../../interfaces/index';\n\nexport const edgeBlocks = <\n  N1 extends ElementOf<E>,\n  N2 extends ElementOf<E> = N1,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  { at: _at, ...options }: EditorAboveOptions<ValueOf<E>> = {}\n): [NodeEntry<N1>, NodeEntry<N2>] | null => {\n  const at = _at ?? editor.selection;\n\n  if (!at) return null;\n\n  const [start, end] = editor.api.edges(at ?? editor.selection)!;\n\n  const startBlock = editor.api.block<N1>({\n    at: start,\n    ...options,\n  } as any);\n\n  if (!startBlock) return null;\n\n  const endBlock = editor.api.block<N2>({\n    at: end,\n    ...options,\n  } as any);\n\n  if (!endBlock) return null;\n\n  return [startBlock, endBlock];\n};\n","import type {\n  Editor,\n  EditorBlockOptions,\n  ElementOf,\n  ValueOf,\n} from '../../interfaces/index';\n\nexport const block = <N extends ElementOf<E>, E extends Editor = Editor>(\n  editor: E,\n  { above, highest, ...options }: EditorBlockOptions<ValueOf<E>> = {}\n) => {\n  if (highest) {\n    const target = options.at ?? editor.selection;\n\n    if (!target) return;\n\n    const index = editor.api.path(target as any)?.[0];\n\n    if (index === undefined) return;\n\n    return editor.api.node<N>([index]);\n  }\n  if (above) {\n    return editor.api.above<N>({\n      ...(options as any),\n      block: true,\n    });\n  }\n\n  return editor.api.node<N>({\n    ...options,\n    block: true,\n    mode: 'lowest',\n  });\n};\n","import type {\n  Editor,\n  EditorNodesOptions,\n  ElementOf,\n  ValueOf,\n} from '../../interfaces/index';\n\nexport const blocks = <N extends ElementOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: EditorNodesOptions<ValueOf<E>>\n) => {\n  return [\n    ...editor.api.nodes<N>({\n      ...options,\n      block: true,\n    }),\n  ];\n};\n","import type { UnknownObject } from '@udecode/utils';\n\nimport type { Editor, LegacyEditorMethods } from '../interfaces';\n\nconst LEGACY_TRANSFORMS = new Set([\n  'addMark',\n  'apply',\n  'blur',\n  'collapse',\n  'delete',\n  'deleteBackward',\n  'deleteForward',\n  'deleteFragment',\n  'deselect',\n  'deselectDOM',\n  'focus',\n  'insertBreak',\n  'insertData',\n  'insertFragment',\n  'insertFragmentData',\n  'insertNode',\n  'insertNodes',\n  'insertSoftBreak',\n  'insertText',\n  'insertTextData',\n  'liftNodes',\n  'mergeNodes',\n  'move',\n  'moveNodes',\n  'normalize',\n  'normalizeNode',\n  'redo',\n  'removeMark',\n  'removeNodes',\n  'select',\n  'setFragmentData',\n  'setNodes',\n  'setPoint',\n  'setSelection',\n  'setSplittingOnce',\n  'splitNodes',\n  'undo',\n  'unsetNodes',\n  'unwrapNodes',\n  'withMerging',\n  'withNewBatch',\n  'withoutMerging',\n  'withoutNormalizing',\n  'withoutSaving',\n  'wrapNodes',\n  'writeHistory',\n]);\n\nconst LEGACY_API = new Set([\n  'above',\n  'after',\n  'before',\n  'edges',\n  'elementReadOnly',\n  'end',\n  'findDocumentOrShadowRoot',\n  'findEventRange',\n  'findKey',\n  'findPath',\n  'first',\n  'fragment',\n  'getDirtyPaths',\n  'getFragment',\n  'getMarks',\n  'getWindow',\n  'hasBlocks',\n  'hasDOMNode',\n  'hasEditableTarget',\n  'hasInlines',\n  'hasPath',\n  'hasRange',\n  'hasSelectableTarget',\n  'hasTarget',\n  'hasTexts',\n  'highestBlock',\n  'isBlock',\n  'isComposing',\n  'isEdge',\n  'isElementReadOnly',\n  'isEmpty',\n  'isEnd',\n  'isFocused',\n  'isInline',\n  'isMerging',\n  'isNormalizing',\n  'isReadOnly',\n  'isSaving',\n  'isSelectable',\n  'isSplittingOnce',\n  'isStart',\n  'isTargetInsideNonReadonlyVoid',\n  'isVoid',\n  'last',\n  'leaf',\n  'levels',\n  'markableVoid',\n  // 'marks',\n  'next',\n  'node',\n  'nodes',\n  'normalize',\n  'onChange',\n  'operations',\n  'parent',\n  'path',\n  'pathRef',\n  'pathRefs',\n  'point',\n  'pointRef',\n  'pointRefs',\n  'positions',\n  'previous',\n  'range',\n  'rangeRef',\n  'rangeRefs',\n  'selection',\n  'setNormalizing',\n  'shouldMergeNodes',\n  'shouldNormalize',\n  'start',\n  'string',\n  'toDOMNode',\n  'toDOMPoint',\n  'toDOMRange',\n  'toSlateNode',\n  'toSlatePoint',\n  'toSlateRange',\n  'unhangRange',\n  'void',\n]);\n\nexport const assignLegacyTransforms = (editor: Editor, transforms: any) => {\n  if (!transforms) return;\n\n  const e = editor as Editor & LegacyEditorMethods;\n\n  const legacyTransforms = Object.entries(transforms).reduce(\n    (acc, [key, value]) => {\n      if (LEGACY_TRANSFORMS.has(key)) {\n        acc[key] = value;\n      }\n\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n\n  Object.assign(e, legacyTransforms);\n};\n\nexport const assignLegacyApi = (editor: Editor, api: any) => {\n  if (!api) return;\n\n  const e = editor as Editor & LegacyEditorMethods & UnknownObject;\n\n  const legacyApi = Object.entries(api).reduce(\n    (acc, [key, value]) => {\n      if (LEGACY_API.has(key)) {\n        acc[key] = value;\n      }\n\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n\n  Object.assign(e, legacyApi);\n\n  if (api.marks) {\n    e.getMarks = api.marks;\n  }\n};\n\n/**\n * Assigns editor's legacy methods to editor.api and editor.tf.\n *\n * NOTE: can't use yet because of recursion issues\n */\nexport const syncLegacyMethods = (editor: Editor) => {\n  const e = editor as Editor & LegacyEditorMethods & UnknownObject;\n\n  // Assign to editor.api\n  LEGACY_API.forEach((key) => {\n    if (e[key]) {\n      if (key === 'getMarks') {\n        // Special case for marks\n        (e.api as any).marks = e.getMarks;\n      } else {\n        (e.api as any)[key] = e[key];\n      }\n    }\n  });\n\n  // Assign to editor.tf\n  LEGACY_TRANSFORMS.forEach((key) => {\n    if (e[key]) {\n      (e.tf as any)[key] = e[key];\n    }\n  });\n};\n","import { Editor as EditorInterface } from 'slate';\n\nimport type { Editor } from '../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../interfaces/node-entry';\n\nimport {\n  type LegacyEditorMethods,\n  type Path,\n  type TLocation,\n  type TRange,\n  PathApi,\n  PointApi,\n  RangeApi,\n} from '../interfaces/index';\nimport { createPathRef } from '../internal/editor/createPathRef';\nimport { createPointRef } from '../internal/editor/createPointRef';\nimport { getEndPoint } from '../internal/editor/getEndPoint';\nimport { getLeafNode } from '../internal/editor/getLeafNode';\nimport { getPointAfter } from '../internal/editor/getPointAfter';\nimport { getPointBefore } from '../internal/editor/getPointBefore';\nimport { getStartPoint } from '../internal/editor/getStartPoint';\nimport { getVoidNode } from '../internal/editor/getVoidNode';\nimport { isBlock } from '../internal/editor/isBlock';\nimport { nodes } from '../internal/editor/nodes';\nimport { withoutNormalizing } from '../internal/editor/withoutNormalizing';\nimport { select } from '../internal/transforms/select';\n\nexport const deleteMerge = (\n  editor: Editor,\n  options: {\n    at?: TLocation;\n    distance?: number;\n    hanging?: boolean;\n    reverse?: boolean;\n    test?: any;\n    unit?: 'block' | 'character' | 'line' | 'word';\n    voids?: boolean;\n  } = {}\n): void => {\n  const e = editor as Editor & LegacyEditorMethods;\n\n  withoutNormalizing(e as any, () => {\n    const {\n      distance = 1,\n      reverse = false,\n      unit = 'character',\n      voids = false,\n    } = options;\n    let { at = e.selection!, hanging = false } = options;\n\n    if (!at) {\n      return;\n    }\n    if (RangeApi.isRange(at) && RangeApi.isCollapsed(at)) {\n      at = at.anchor;\n    }\n    if (PointApi.isPoint(at)) {\n      const furthestVoid = getVoidNode(e as any, { at, mode: 'highest' });\n\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        const opts = { distance, unit };\n        const target = reverse\n          ? getPointBefore(e as any, at, opts) || getStartPoint(e as any, [])!\n          : getPointAfter(e as any, at, opts) || getEndPoint(e as any, [])!;\n        at = { anchor: at, focus: target };\n        hanging = true;\n      }\n    }\n    if (PathApi.isPath(at)) {\n      e.tf.removeNodes({ at, voids });\n\n      return;\n    }\n    if (RangeApi.isCollapsed(at)) {\n      return;\n    }\n    if (!hanging) {\n      at = EditorInterface.unhangRange(e as any, at, { voids });\n    }\n\n    let [start, end] = RangeApi.edges(at as TRange);\n    const startBlock = e.api.above({\n      at: start,\n      voids,\n      match: (n) => isBlock(e as any, n),\n    });\n    const endBlock = e.api.above({\n      at: end,\n      voids,\n      match: (n) => isBlock(e as any, n),\n    });\n    const isAcrossBlocks =\n      startBlock && endBlock && !PathApi.equals(startBlock[1], endBlock[1]);\n    const isSingleText = PathApi.equals(start.path, end.path);\n    const startVoid = voids\n      ? null\n      : getVoidNode(e as any, { at: start, mode: 'highest' });\n    const endVoid = voids\n      ? null\n      : getVoidNode(e as any, { at: end, mode: 'highest' });\n\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startVoid) {\n      const before = getPointBefore(e as any, start);\n\n      if (\n        before &&\n        startBlock &&\n        PathApi.isAncestor(startBlock[1], before.path)\n      ) {\n        start = before;\n      }\n    }\n    if (endVoid) {\n      const after = getPointAfter(e as any, end);\n\n      if (after && endBlock && PathApi.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    const matches: NodeEntry[] = [];\n    let lastPath: Path | undefined;\n\n    const _nodes = nodes(e as any, { at, voids });\n\n    for (const entry of _nodes) {\n      const [node, path] = entry;\n\n      if (lastPath && PathApi.compare(path, lastPath) === 0) {\n        continue;\n      }\n      if (\n        (!voids && e.api.isVoid(node as any)) ||\n        (!PathApi.isCommon(path, start.path) &&\n          !PathApi.isCommon(path, end.path))\n      ) {\n        matches.push(entry as any);\n        lastPath = path;\n      }\n    }\n\n    const pathRefs = Array.from(matches, ([, p]) => createPathRef(e as any, p));\n    const startRef = createPointRef(e as any, start);\n    const endRef = createPointRef(e as any, end);\n\n    if (!isSingleText && !startVoid) {\n      const point = startRef.current!;\n      const [node] = getLeafNode(e as any, point)!;\n      const { path } = point;\n      const { offset } = start;\n      const text = node.text.slice(offset);\n      e.apply({ offset, path, text, type: 'remove_text' });\n    }\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!;\n      e.tf.removeNodes({ at: path, voids });\n    }\n\n    if (!endVoid) {\n      const point = endRef.current!;\n      const [node] = getLeafNode(e as any, point)!;\n      const { path } = point;\n      const offset = isSingleText ? start.offset : 0;\n      const text = node.text.slice(offset, end.offset);\n      e.apply({ offset, path, text, type: 'remove_text' });\n    }\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      // DIFF: allow custom mergeNodes\n      e.tf.mergeNodes({\n        at: endRef.current,\n        hanging: true,\n        voids,\n      });\n    }\n\n    const point = endRef.unref() || startRef.unref();\n\n    if (options.at == null && point) {\n      select(e as any, point);\n    }\n  });\n};\n","import type { EditorPathRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { pathRef } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { Path } from '../../interfaces/path';\n\nexport const createPathRef = (\n  editor: Editor,\n  at: Path,\n  options?: EditorPathRefOptions\n) => pathRef(editor as any, at, options as any);\n","import type { EditorPointRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { pointRef } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { Point } from '../../interfaces/point';\n\nexport const createPointRef = (\n  editor: Editor,\n  point: Point,\n  options?: EditorPointRefOptions\n) => pointRef(editor as any, point, options as any);\n","import { end } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorEndOptions } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils/getAt';\n\nexport const getEndPoint = (\n  editor: Editor,\n  at: At,\n  options: EditorEndOptions = {}\n) => {\n  try {\n    if (options.previous) {\n      const prevEntry = editor.api.previous({ at: getAt(editor, at)! });\n\n      if (!prevEntry) return;\n\n      return end(editor as any, prevEntry[1]);\n    }\n\n    return end(editor as any, getAt(editor, at)!);\n  } catch {}\n};\n","import isPlainObject from 'lodash/isPlainObject.js';\n\nimport { type Editor, type TNode, NodeApi } from '../interfaces';\n\nexport const getAt = <T>(\n  editor: Editor,\n  at?: T | TNode | null\n): T | undefined => {\n  if (at && isPlainObject(at) && NodeApi.isNode(at)) {\n    return editor.api.findPath(at) as any;\n  }\n\n  return (at as T) ?? undefined;\n};\n","import type { EditorLeafOptions } from 'slate/dist/interfaces/editor';\n\nimport { leaf } from 'slate';\n\nimport type { TextOf } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getLeafNode = <N extends TextOf<E>, E extends Editor>(\n  editor: E,\n  at: At,\n  options?: EditorLeafOptions\n): NodeEntry<N> | undefined => {\n  try {\n    return leaf(editor as any, getAt(editor, at)!, options) as any;\n  } catch {}\n};\n","import { after } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorAfterOptions } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getPointAfter = (\n  editor: Editor,\n  at: At,\n  options?: EditorAfterOptions\n) => {\n  try {\n    return after(editor as any, getAt(editor, at)!, options as any);\n  } catch {}\n};\n","import castArray from 'lodash/castArray.js';\nimport map from 'lodash/map.js';\nimport { before as beforeBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorBeforeOptions, Point } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getPointBefore = (\n  editor: Editor,\n  at: At,\n  options?: EditorBeforeOptions\n): Point | undefined => {\n  if (!options || (!options.match && !options.matchString)) {\n    try {\n      return beforeBase(editor as any, getAt(editor, at)!, options as any);\n    } catch {}\n\n    return;\n  }\n\n  const unitOffset = !options.unit || options.unit === 'offset';\n\n  const matchStrings: string[] = options.matchString\n    ? castArray(options.matchString)\n    : [''];\n\n  const matchByRegex = options.matchByRegex ?? false;\n\n  let point: any;\n\n  matchStrings.some((matchString) => {\n    let beforeAt = at;\n    let previousBeforePoint = editor.api.point(at, { edge: 'end' })!;\n\n    const stackLength = matchString.length + 1;\n    const stack: any[] = Array.from({ length: stackLength });\n\n    let count = 0;\n\n    while (true) {\n      const beforePoint = beforeBase(\n        editor as any,\n        getAt(editor, beforeAt)!,\n        options as any\n      );\n\n      // not found\n      if (!beforePoint) {\n        if (options.matchBlockStart) {\n          point = previousBeforePoint;\n        }\n\n        return;\n      }\n      // stop looking outside of current block\n      if (\n        editor.api.isAt({\n          at: {\n            anchor: beforePoint,\n            focus: previousBeforePoint,\n          },\n          blocks: true,\n        })\n      ) {\n        if (options.matchBlockStart) {\n          point = previousBeforePoint;\n        }\n\n        return;\n      }\n\n      const beforeString = editor.api.string({\n        anchor: beforePoint,\n        focus: previousBeforePoint,\n      });\n\n      let beforeStringToMatch = beforeString;\n\n      if (unitOffset && stackLength) {\n        stack.unshift({\n          point: beforePoint,\n          text: beforeString,\n        });\n        stack.pop();\n\n        beforeStringToMatch = map(stack.slice(0, -1), 'text').join('');\n      }\n\n      const isMatched = matchByRegex\n        ? !!matchString.match(beforeStringToMatch)\n        : beforeStringToMatch === matchString;\n\n      if (\n        isMatched ||\n        options.match?.({ at, beforePoint, beforeString: beforeStringToMatch })\n      ) {\n        if (options.afterMatch) {\n          if (stackLength && unitOffset) {\n            point = stack.at(-1)?.point;\n\n            return !!point;\n          }\n\n          point = previousBeforePoint;\n\n          return true;\n        }\n\n        point = beforePoint;\n\n        return true;\n      }\n\n      previousBeforePoint = beforePoint;\n      beforeAt = beforePoint;\n\n      count += 1;\n\n      if (!options.skipInvalid && (!matchString || count >= matchString.length))\n        return;\n    }\n  });\n\n  return point;\n};\n","import { start } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorStartOptions } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getStartPoint = (\n  editor: Editor,\n  at: At,\n  options: EditorStartOptions = {}\n) => {\n  try {\n    if (options.next) {\n      const nextEntry = editor.api.next({ at: getAt(editor, at)! });\n\n      if (!nextEntry) return;\n\n      return start(editor as any, nextEntry[1]);\n    }\n\n    return start(editor as any, getAt(editor, at)!);\n  } catch {}\n};\n","import { getVoid } from 'slate';\n\nimport type { EditorVoidOptions, ElementOf } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport { getAt } from '../../utils';\n\nexport const getVoidNode = <N extends ElementOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: EditorVoidOptions\n): NodeEntry<N> | undefined =>\n  getVoid(editor as any, {\n    ...options,\n    at: getAt(editor, options?.at),\n  }) as any;\n","import { isBlock as isBlockBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nimport { type TElement, ElementApi } from '../../interfaces/element';\n\nexport const isBlock = (editor: Editor, value: any): value is TElement =>\n  ElementApi.isElement(value) && isBlockBase(editor as any, value);\n","import type { Editor } from '../interfaces/editor/editor-type';\nimport type { NodeOf, TNode } from '../interfaces/node';\n\nimport { type Path, TextApi } from '../interfaces/index';\nimport { getAt } from './getAt';\n\nexport type Predicate<T extends TNode> = PredicateFn<T> | PredicateObj;\n\ntype PredicateFn<T extends TNode> = (obj: T, path: Path) => boolean;\n\ntype PredicateObj = Record<string, any[] | any>;\n\nfunction castArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Match the object with a predicate object or function. If predicate is:\n *\n * - Object: every predicate key/value should be in obj.\n * - Function: it should return true.\n */\nexport const match = <T extends TNode>(\n  obj: T,\n  path: Path,\n  predicate?: Predicate<T>\n): boolean => {\n  if (!predicate) return true;\n  if (typeof predicate === 'object') {\n    return Object.entries(predicate).every(([key, value]) => {\n      const values = castArray<any>(value);\n\n      return values.includes((obj as any)[key]);\n    });\n  }\n\n  return predicate(obj, path);\n};\n\nexport const getMatch = <E extends Editor>(\n  editor: E,\n  { id, block, empty, match: matchObjOrFn, text }: any = {}\n) => {\n  let hasMatch = false;\n  let matchFn: PredicateFn<NodeOf<E>> = () => true;\n\n  // If text option is true/false, match only text/non-text nodes\n  if (text !== undefined) {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, (n) => TextApi.isText(n) === text);\n  }\n  // If empty option is true/false, match only empty/non-empty nodes\n  if (empty !== undefined) {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, (n) => {\n      return TextApi.isText(n)\n        ? n.text.length > 0 === !empty\n        : editor.api.isEmpty(n) === empty;\n    });\n  }\n  if (block !== undefined) {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, (n) => editor.api.isBlock(n) === block);\n  }\n  if (id !== undefined) {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, (n) => {\n      return (id === true && !!n.id) || n.id === id;\n    });\n  }\n  // Handle object predicate matching first\n  if (typeof matchObjOrFn === 'object') {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, (n, p) => match(n, p, matchObjOrFn));\n  } else if (typeof matchObjOrFn === 'function') {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, matchObjOrFn);\n  }\n\n  return hasMatch ? matchFn : undefined;\n};\n\n/**\n * Extended query options for slate queries:\n *\n * - `match` can be an object predicate where one of the values should include the\n *   node value. Example: { type: ['1', '2'] } will match the nodes having one\n *   of these 2 types.\n */\nexport const getQueryOptions = (\n  editor: Editor,\n  { id, empty, match, text, ...options }: any = {}\n) => {\n  const { at, block } = options;\n\n  return {\n    ...options,\n    at: getAt(editor, at),\n    match: getMatch(editor, { id, block, empty, match, text }),\n  };\n};\n\nexport const combineMatch = <T extends TNode>(\n  match1: PredicateFn<T>,\n  match2?: PredicateFn<T>\n): PredicateFn<T> => {\n  return (node: T, path: Path) => {\n    return match1(node, path) && (!match2 || match2(node, path));\n  };\n};\n\n/** Combine two match predicates into one. */\nexport const combineMatchOptions = <E extends Editor>(\n  editor: E,\n  match1?: PredicateFn<NodeOf<E>>,\n  options?: any\n): PredicateFn<NodeOf<E>> => {\n  return (node: NodeOf<E>, path: Path) => {\n    const match2 = getMatch(editor, options);\n\n    return (!match1 || match1(node, path)) && (!match2 || match2(node, path));\n  };\n};\n","import type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport {\n  type DescendantOf,\n  type EditorNodesOptions,\n  ElementApi,\n  NodeApi,\n  PathApi,\n  SpanApi,\n  TextApi,\n} from '../../interfaces';\nimport { getAt } from '../../utils';\nimport { getMatch, getQueryOptions } from '../../utils/match';\n\nexport function* nodes<N extends DescendantOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>> = {}\n): Generator<NodeEntry<N>, void, undefined> {\n  options = getQueryOptions(editor, options);\n\n  // if (options?.at) {\n  //   editor.api.unhangRange(options.at as any, options);\n  // }\n\n  const {\n    ignoreNonSelectable = false,\n    mode = 'all',\n    reverse = false,\n    universal = false,\n    voids = false,\n  } = options;\n  const at = getAt(editor, options.at) ?? editor.selection;\n  let match = getMatch(editor, options);\n\n  if (!match) {\n    match = () => true;\n  }\n  if (!at) {\n    return;\n  }\n\n  let from;\n  let to;\n\n  if (SpanApi.isSpan(at)) {\n    from = at[0];\n    to = at[1];\n  } else {\n    const first = editor.api.path(at, { edge: 'start' });\n    const last = editor.api.path(at, { edge: 'end' });\n    from = reverse ? last : first;\n    to = reverse ? first : last;\n\n    // FORK: return early if no path is found\n    if (!first || !last) {\n      return;\n    }\n  }\n\n  const nodeEntries = NodeApi.nodes(editor, {\n    from,\n    reverse,\n    to,\n    pass: ([node]) => {\n      if (!ElementApi.isElement(node)) return false;\n      if (\n        !voids &&\n        (editor.api.isVoid(node) || editor.api.isElementReadOnly(node))\n      ) {\n        return true;\n      }\n      if (ignoreNonSelectable && !editor.api.isSelectable(node)) {\n        return true;\n      }\n\n      return false;\n    },\n  });\n\n  const matches: NodeEntry<N>[] = [];\n  let hit: NodeEntry<N> | undefined;\n\n  for (const [node, path] of nodeEntries) {\n    if (\n      ignoreNonSelectable &&\n      ElementApi.isElement(node) &&\n      !editor.api.isSelectable(node)\n    ) {\n      continue;\n    }\n\n    const isLower = hit && PathApi.compare(path, hit[1]) === 0;\n\n    // In highest mode any node lower than the last hit is not a match.\n    if (mode === 'highest' && isLower) {\n      continue;\n    }\n    if (!match(node, path)) {\n      // If we've arrived at a leaf text node that is not lower than the last\n      // hit, then we've found a branch that doesn't include a match, which\n      // means the match is not universal.\n      if (universal && !isLower && TextApi.isText(node)) {\n        return;\n      } else {\n        continue;\n      }\n    }\n    // If there's a match and it's lower than the last, update the hit.\n    if (mode === 'lowest' && isLower) {\n      hit = [node, path] as NodeEntry<N>;\n\n      continue;\n    }\n\n    // In lowest mode we emit the last hit, once it's guaranteed lowest.\n    const emit: NodeEntry<N> | undefined =\n      mode === 'lowest' ? hit : ([node, path] as NodeEntry<N>);\n\n    if (emit) {\n      if (universal) {\n        matches.push(emit);\n      } else {\n        yield emit;\n      }\n    }\n\n    hit = [node, path] as NodeEntry<N>;\n  }\n\n  // Since lowest is always emitting one behind, catch up at the end.\n  if (mode === 'lowest' && hit) {\n    if (universal) {\n      matches.push(hit);\n    } else {\n      yield hit;\n    }\n  }\n  // Universal defers to ensure that the match occurs in every branch, so we\n  // yield all of the matches after iterating.\n  if (universal) {\n    yield* matches;\n  }\n}\n","import { withoutNormalizing as withoutNormalizingBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const withoutNormalizing = (\n  editor: Editor,\n  fn: () => boolean | void\n) => {\n  let normalized = false;\n\n  withoutNormalizingBase(editor as any, () => {\n    normalized = !!fn();\n  });\n\n  return normalized;\n};\n","import { select as selectBase } from 'slate';\n\nimport type { At } from '../../types';\n\nimport { type Editor, type SelectOptions, PathApi } from '../../interfaces';\nimport { getAt } from '../../utils/getAt';\n\nexport const select = (\n  editor: Editor,\n  target?: At,\n  options: SelectOptions = {}\n) => {\n  const { edge, focus, next, previous } = options;\n\n  if (focus) {\n    editor.tf.focus();\n  }\n  // Handle sibling selection\n  if (next || previous) {\n    const at = getAt(editor, target) ?? editor.selection;\n\n    if (!at) return;\n\n    const path = editor.api.path(at);\n\n    if (!path) return;\n\n    const point = previous\n      ? editor.api.end(path, { previous: true })\n      : editor.api.start(path, { next: true });\n\n    if (!point) return;\n\n    selectBase(editor as any, point);\n\n    return;\n  }\n  // Handle edge selection\n  if (edge) {\n    const at = getAt(editor, target) ?? editor.selection;\n\n    if (!at) return;\n\n    const path = PathApi.isPath(at)\n      ? at\n      : editor.api.node({ at, block: true })?.[1];\n\n    if (!path) return;\n\n    const point =\n      edge === 'end' ? editor.api.end(path) : editor.api.start(path);\n\n    if (!point) return;\n\n    selectBase(editor as any, point);\n\n    return;\n  }\n\n  const at = getAt(editor, target);\n\n  if (!at) return;\n\n  selectBase(editor as any, at);\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { Editor, TLocation } from '../interfaces';\nimport type { QueryNodeOptions } from './queryNode';\n\n/** Query the editor state. */\nexport interface QueryEditorOptions<E extends Editor = Editor>\n  extends Pick<QueryNodeOptions, 'allow' | 'exclude'> {\n  /** Location from where to lookup the node types (bottom-up) */\n  at?: TLocation;\n\n  /** Query the editor. */\n  filter?: (editor: E) => boolean;\n\n  /** When the selection is at the end of the block above. */\n  selectionAtBlockEnd?: boolean;\n\n  /** When the selection is at the start of the block above. */\n  selectionAtBlockStart?: boolean;\n}\n\n/** Query the editor state. */\nexport const queryEditor = <E extends Editor>(\n  editor: E,\n  {\n    allow,\n    at = editor.selection || [],\n    exclude,\n    filter,\n    selectionAtBlockEnd,\n    selectionAtBlockStart,\n  }: QueryEditorOptions<E> = {}\n) => {\n  if (\n    (filter && !filter(editor)) ||\n    (selectionAtBlockStart && !editor.api.isAt({ start: true })) ||\n    (selectionAtBlockEnd && !editor.api.isAt({ end: true }))\n  ) {\n    return false;\n  }\n\n  const allows = castArray(allow);\n\n  if (allows.length > 0 && !editor.api.some({ at, match: { type: allows } })) {\n    return false;\n  }\n\n  const excludes = castArray(exclude);\n\n  if (\n    excludes.length > 0 &&\n    editor.api.some({ at, match: { type: excludes } })\n  ) {\n    return false;\n  }\n\n  return true;\n};\n","import type { NodeEntry, TNode } from '../interfaces';\n\nfunction castArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\n/** Filter nodes. */\nexport interface QueryNodeOptions {\n  /** List of types that are valid. If empty or undefined - allow all. */\n  allow?: string[] | string | null;\n\n  /** List of types that are invalid. */\n  exclude?: string[] | string | null;\n\n  /** Query the node entry. */\n  filter?: <N extends TNode>(entry: NodeEntry<N>) => boolean;\n\n  /** Valid path levels. */\n  level?: number[] | number | null;\n\n  /** Paths above that value are invalid. */\n  maxLevel?: number | null;\n}\n\n/** Query the node entry. */\nexport const queryNode = <N extends TNode>(\n  entry?: NodeEntry<N>,\n  { allow, exclude, filter, level, maxLevel }: QueryNodeOptions = {}\n) => {\n  if (!entry) return false;\n\n  const [node, path] = entry;\n\n  if (level) {\n    const levels = castArray(level);\n\n    if (!levels.includes(path.length)) {\n      return false;\n    }\n  }\n  if (maxLevel && path.length > maxLevel) {\n    return false;\n  }\n  if (filter && !filter(entry)) {\n    return false;\n  }\n  if (allow) {\n    const allows = castArray(allow);\n\n    if (allows.length > 0 && !allows.includes(node.type as any)) {\n      return false;\n    }\n  }\n  if (exclude) {\n    const excludes = castArray(exclude);\n\n    if (excludes.length > 0 && excludes.includes(node.type as any)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","/**\n * Iterate through all of the nodes in the editor and return the first match. If\n * no match is found, return undefined.\n */\nimport {\n  type DescendantOf,\n  type Editor,\n  type EditorNodesOptions,\n  type NodeEntry,\n  type NodeEntryOf,\n  type Path,\n  type ValueOf,\n  NodeApi,\n  PathApi,\n  RangeApi,\n  SpanApi,\n} from '../../interfaces';\nimport { match } from '../../utils';\n\nexport const descendant = <\n  N extends DescendantOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>>\n): NodeEntry<N> | undefined => {\n  // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.\n  try {\n    const {\n      at = editor.selection,\n      match: _match,\n      reverse = false,\n      voids = false,\n    } = options;\n\n    if (!at) return;\n\n    let from;\n    let to;\n\n    if (SpanApi.isSpan(at)) {\n      [from, to] = at;\n    } else if (RangeApi.isRange(at)) {\n      const first = editor.api.path(at, { edge: 'start' });\n      const last = editor.api.path(at, { edge: 'end' });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    let root: NodeEntryOf<E> = [editor, []];\n\n    if (PathApi.isPath(at)) {\n      root = editor.api.node(at) as any;\n    }\n\n    const nodeEntries = NodeApi.descendants<N>(root[0], {\n      from,\n      reverse,\n      to,\n      pass: ([n]) => (voids ? false : editor.api.isVoid(n as any)),\n    });\n\n    for (const [node, path] of nodeEntries) {\n      if (match(node, path, _match as any)) {\n        return [node, (at as Path).concat(path)];\n      }\n    }\n  } catch {\n    return undefined;\n  }\n};\n","import type { Editor } from '../../interfaces/index';\n\nexport const mark = (editor: Editor, key: string) => {\n  const marks = editor.api.marks();\n\n  return (marks as any)?.[key] as unknown;\n};\n","import type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const hasMark = (editor: Editor, key: string) => {\n  return !!editor.api.mark(key);\n};\n","import {\n  type Editor,\n  type EditorIsSelectedOptions,\n  type Path,\n  type TRange,\n  RangeApi,\n} from '../../interfaces';\n\nexport const isSelected = (\n  editor: Editor,\n  target: Path | TRange,\n  options: EditorIsSelectedOptions = {}\n) => {\n  const { contains = false } = options;\n\n  if (!editor.selection) return false;\n\n  const range = RangeApi.isRange(target) ? target : editor.api.range(target);\n\n  if (!range) return false;\n  if (contains) {\n    return RangeApi.contains(editor.selection, range);\n  }\n\n  // Check if selection intersects with path range\n  return !!RangeApi.intersection(editor.selection, range);\n};\n","import type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\n\nimport {\n  type EditorAboveOptions,\n  type TLocation,\n  PathApi,\n  PointApi,\n  RangeApi,\n} from '../../interfaces';\n\n/**\n * Check if a location (point/range) is at a specific position.\n *\n * For ranges:\n *\n * - If text=true, check if range is in single text node\n * - If block=true, check if range is in single block\n * - If blocks=true, check if range is across multiple blocks\n * - If start=true, check if range starts at block start\n * - If end=true, check if range ends at block end\n *\n * For points:\n *\n * - If word=true, check relative to word boundaries\n * - If start=true, check if at start\n * - If end=true, check if at end\n */\nexport const isAt = <E extends Editor>(\n  editor: E,\n  {\n    at = editor.selection,\n    block,\n    blocks,\n    end,\n    start,\n    text,\n    word,\n    ...options\n  }: {\n    /** The location to check. Defaults to current selection */\n    at?: TLocation | null;\n    /** Check if range is in single block */\n    block?: boolean;\n    /** Check if range is across multiple blocks */\n    blocks?: boolean;\n    /** Check if range ends at block end or point is at word end */\n    end?: boolean;\n    /** Check if range starts at block start */\n    start?: boolean;\n    /** Check if range is in single text node */\n    text?: boolean;\n    /** Check if point is at word boundary (only with end=true) */\n    word?: boolean;\n  } & Omit<EditorAboveOptions<ValueOf<E>>, 'at' | 'block'> = {}\n) => {\n  if (!at) return false;\n  // Handle Point\n  if (PointApi.isPoint(at)) {\n    if (word && end) {\n      const after = editor.api.after(at);\n\n      if (!after) return true;\n\n      const afterRange = editor.api.range(at, after);\n      const afterText = editor.api.string(afterRange);\n\n      return /^(?:\\s|$)/.test(afterText);\n    }\n\n    return false;\n  }\n  // Handle Range\n  if (RangeApi.isRange(at)) {\n    const [startPoint, endPoint] = RangeApi.edges(at);\n\n    // Check if range is in single text node\n    if (text) {\n      return PathApi.equals(startPoint.path, endPoint.path);\n    }\n\n    const startBlock = editor.api.block({\n      at: startPoint,\n      ...options,\n    });\n    const endBlock = editor.api.block({\n      at: endPoint,\n      ...options,\n    });\n\n    // Handle blocks edge cases\n    if (blocks) {\n      if (!startBlock && !endBlock) return false;\n      if (!startBlock || !endBlock) return true;\n\n      return !PathApi.equals(startBlock[1], endBlock[1]);\n    }\n    if (!startBlock || !endBlock) return false;\n    // Check if range is in single block\n    if (block) {\n      return PathApi.equals(startBlock[1], endBlock[1]);\n    }\n    // Check block boundaries\n    if (start) {\n      return (\n        editor.api.isStart(startPoint, startBlock[1]) ||\n        (RangeApi.isExpanded(at) && editor.api.isStart(endPoint, startBlock[1]))\n      );\n    }\n    if (end) {\n      return editor.api.isEnd(endPoint, endBlock[1]);\n    }\n  }\n\n  return false;\n};\n","import { type Editor, PathApi } from '../../interfaces/index';\n\nexport const isEditorEnd = (editor: Editor) => {\n  if (editor.selection) {\n    const point = editor.selection.focus;\n    const endPoint = editor.api.end([])!;\n\n    return (\n      endPoint.offset === 0 &&\n      editor.api.isEnd(point, point) &&\n      PathApi.equals(PathApi.next(PathApi.parent(point.path)), endPoint.path)\n    );\n  }\n\n  return false;\n};\n","import type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport { TextApi } from '../../interfaces';\n\n/** Check if a node at a location is a Text node */\nexport const isText = (editor: Editor, at: At) => {\n  const node = editor.api.node(at)?.[0];\n\n  return TextApi.isText(node);\n};\n","import type { Editor, NodeEntry } from '../../interfaces/index';\n\nexport const nodesRange = (editor: Editor, nodes: NodeEntry[]) => {\n  if (nodes.length === 0) return;\n\n  const firstBlockPath = nodes[0][1];\n  const lastBlockPath = nodes.at(-1)![1];\n\n  return editor.api.range(firstBlockPath, lastBlockPath);\n};\n","import { type EditorPropOptions, NodeApi } from '../../interfaces';\n\nexport function prop({\n  key,\n  defaultValue,\n  getProp,\n  mode = 'block',\n  nodes,\n}: EditorPropOptions): string | undefined {\n  if (nodes.length === 0) return defaultValue;\n\n  const getNodeValue =\n    getProp ??\n    ((node) => {\n      return node[key!]!;\n    });\n\n  let value: string | undefined;\n\n  for (const node of nodes) {\n    if (mode === 'block' || mode === 'all') {\n      const nodeValue = getNodeValue(node);\n\n      if (nodeValue !== undefined) {\n        if (value === undefined) {\n          value = nodeValue;\n        } else if (value !== nodeValue) {\n          return;\n        }\n        if (mode === 'block') continue;\n      } else if (mode === 'block') {\n        return defaultValue;\n      }\n    }\n    if (mode === 'text' || mode === 'all') {\n      const textEntries = Array.from(NodeApi.texts(node));\n\n      for (const [text] of textEntries) {\n        const textValue = getNodeValue(text);\n\n        if (textValue !== undefined) {\n          if (value === undefined) {\n            value = textValue;\n          } else if (value !== textValue) {\n            return;\n          }\n        } else if (mode === 'text') {\n          return defaultValue;\n        }\n      }\n    }\n  }\n\n  return value;\n}\n","// Compute what scrolling needs to be done on required scrolling boxes for target to be in view\n\n// The type names here are named after the spec to make it easier to find more information around what they mean:\n// To reduce churn and reduce things that need be maintained things from the official TS DOM library is used here\n// https://drafts.csswg.org/cssom-view/\n\n// For a definition on what is \"block flow direction\" exactly, check this: https://drafts.csswg.org/css-writing-modes-4/#block-flow-direction\n\n/**\n * This new option is tracked in this PR, which is the most likely candidate at the time: https://github.com/w3c/csswg-drafts/pull/1805\n * @public\n */\nexport type ScrollMode = 'always' | 'if-needed'\n\n/** @public */\nexport interface Options {\n  /**\n   * Control the logical scroll position on the y-axis. The spec states that the `block` direction is related to the [writing-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode), but this is not implemented yet in this library.\n   * This means that `block: 'start'` aligns to the top edge and `block: 'end'` to the bottom.\n   * @defaultValue 'center'\n   */\n  block?: ScrollLogicalPosition\n  /**\n   * Like `block` this is affected by the [writing-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode). In left-to-right pages `inline: 'start'` will align to the left edge. In right-to-left it should be flipped. This will be supported in a future release.\n   * @defaultValue 'nearest'\n   */\n  inline?: ScrollLogicalPosition\n  /**\n   * This is a proposed addition to the spec that you can track here: https://github.com/w3c/csswg-drafts/pull/5677\n   *\n   * This library will be updated to reflect any changes to the spec and will provide a migration path.\n   * To be backwards compatible with `Element.scrollIntoViewIfNeeded` if something is not 100% visible it will count as \"needs scrolling\". If you need a different visibility ratio your best option would be to implement an [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).\n   * @defaultValue 'always'\n   */\n  scrollMode?: ScrollMode\n  /**\n   * By default there is no boundary. All the parent elements of your target is checked until it reaches the viewport ([`document.scrollingElement`](https://developer.mozilla.org/en-US/docs/Web/API/document/scrollingElement)) when calculating layout and what to scroll.\n   * By passing a boundary you can short-circuit this loop depending on your needs:\n   * \n   * - Prevent the browser window from scrolling.\n   * - Scroll elements into view in a list, without scrolling container elements.\n   * \n   * You can also pass a function to do more dynamic checks to override the scroll scoping:\n   * \n   * ```js\n   * let actions = compute(target, {\n   *   boundary: (parent) => {\n   *     // By default `overflow: hidden` elements are allowed, only `overflow: visible | clip` is skipped as\n   *     // this is required by the CSSOM spec\n   *     if (getComputedStyle(parent)['overflow'] === 'hidden') {\n   *       return false\n   *     }\n\n   *     return true\n   *   },\n   * })\n   * ```\n   * @defaultValue null\n   */\n  boundary?: Element | ((parent: Element) => boolean) | null\n  /**\n   * New option that skips auto-scrolling all nodes with overflow: hidden set\n   * See FF implementation: https://hg.mozilla.org/integration/fx-team/rev/c48c3ec05012#l7.18\n   * @defaultValue false\n   * @public\n   */\n  skipOverflowHiddenElements?: boolean\n}\n\n/** @public */\nexport interface ScrollAction {\n  el: Element\n  top: number\n  left: number\n}\n\n// @TODO better shadowdom test, 11 = document fragment\nconst isElement = (el: any): el is Element =>\n  typeof el === 'object' && el != null && el.nodeType === 1\n\nconst canOverflow = (\n  overflow: string | null,\n  skipOverflowHiddenElements?: boolean\n) => {\n  if (skipOverflowHiddenElements && overflow === 'hidden') {\n    return false\n  }\n\n  return overflow !== 'visible' && overflow !== 'clip'\n}\n\nconst getFrameElement = (el: Element) => {\n  if (!el.ownerDocument || !el.ownerDocument.defaultView) {\n    return null\n  }\n\n  try {\n    return el.ownerDocument.defaultView.frameElement\n  } catch (e) {\n    return null\n  }\n}\n\nconst isHiddenByFrame = (el: Element): boolean => {\n  const frame = getFrameElement(el)\n  if (!frame) {\n    return false\n  }\n\n  return (\n    frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth\n  )\n}\n\nconst isScrollable = (el: Element, skipOverflowHiddenElements?: boolean) => {\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\n    const style = getComputedStyle(el, null)\n    return (\n      canOverflow(style.overflowY, skipOverflowHiddenElements) ||\n      canOverflow(style.overflowX, skipOverflowHiddenElements) ||\n      isHiddenByFrame(el)\n    )\n  }\n\n  return false\n}\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n *      \n *  target    frame\n *      \n */\nconst alignNearest = (\n  scrollingEdgeStart: number,\n  scrollingEdgeEnd: number,\n  scrollingSize: number,\n  scrollingBorderStart: number,\n  scrollingBorderEnd: number,\n  elementEdgeStart: number,\n  elementEdgeEnd: number,\n  elementSize: number\n) => {\n  /**\n   * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n   *\n   *          \n   *        \n   *            \n   *                    do nothing\n   *            \n   *        \n   *          \n   *\n   *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n   *\n   *         \n   *   \n   *                    do nothing\n   *   \n   *         \n   */\n  if (\n    (elementEdgeStart < scrollingEdgeStart &&\n      elementEdgeEnd > scrollingEdgeEnd) ||\n    (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n  ) {\n    return 0\n  }\n\n  /**\n   * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n   *\n   *          \n   *                 \n   *                         \n   *  from             to    \n   *\n   *                     \n   *\n   * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n   *\n   *                   \n   *                             \n   *  from         to      \n   *                           \n   *                 \n   *                         \n   *            \n   *          \n   *\n   * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n   *\n   *       from                 to\n   *                       \n   *                   \n   *                            \n   *                   \n   *                       \n   *\n   * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n   *\n   *       from                 to\n   *                       \n   *           \n   *                              \n   *           \n   *                       \n   */\n  if (\n    (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n    (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n  ) {\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart\n  }\n\n  /**\n   * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n   *\n   *                     \n   *\n   *  from             to    \n   *                         \n   *                 \n   *          \n   *\n   * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n   *\n   *          \n   *            \n   *                         \n   *                 \n   *                           \n   *  from         to      \n   *                             \n   *                   \n   *\n   * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n   *\n   *           from                 to\n   *                           \n   *             \n   *                                \n   *             \n   *                           \n   *\n   * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n   *\n   *           from                 to\n   *                           \n   *                             \n   *                                \n   *                             \n   *                           \n   *\n   */\n  if (\n    (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n    (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n  ) {\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd\n  }\n\n  return 0\n}\n\nconst getParentElement = (element: Node): Element | null => {\n  const parent = element.parentElement\n  if (parent == null) {\n    return (element.getRootNode() as ShadowRoot).host || null\n  }\n  return parent\n}\n\nconst getScrollMargins = (target: Element) => {\n  const computedStyle = window.getComputedStyle(target)\n  return {\n    top: parseFloat(computedStyle.scrollMarginTop) || 0,\n    right: parseFloat(computedStyle.scrollMarginRight) || 0,\n    bottom: parseFloat(computedStyle.scrollMarginBottom) || 0,\n    left: parseFloat(computedStyle.scrollMarginLeft) || 0,\n  }\n}\n\n/** @public */\nexport const compute = (target: Element, options: Options): ScrollAction[] => {\n  if (typeof document === 'undefined') {\n    // If there's no DOM we assume it's not in a browser environment\n    return []\n  }\n\n  const { scrollMode, block, inline, boundary, skipOverflowHiddenElements } =\n    options\n  // Allow using a callback to check the boundary\n  // The default behavior is to check if the current target matches the boundary element or not\n  // If undefined it'll check that target is never undefined (can happen as we recurse up the tree)\n  const checkBoundary =\n    typeof boundary === 'function' ? boundary : (node: any) => node !== boundary\n\n  if (!isElement(target)) {\n    throw new TypeError('Invalid target')\n  }\n\n  // Used to handle the top most element that can be scrolled\n  const scrollingElement = document.scrollingElement || document.documentElement\n\n  // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n  const frames: Element[] = []\n  let cursor: Element | null = target\n  while (isElement(cursor) && checkBoundary(cursor)) {\n    // Move cursor to parent\n    cursor = getParentElement(cursor)\n\n    // Stop when we reach the viewport\n    if (cursor === scrollingElement) {\n      frames.push(cursor)\n      break\n    }\n\n    // Skip document.body if it's not the scrollingElement and documentElement isn't independently scrollable\n    if (\n      cursor != null &&\n      cursor === document.body &&\n      isScrollable(cursor) &&\n      !isScrollable(document.documentElement)\n    ) {\n      continue\n    }\n\n    // Now we check if the element is scrollable, this code only runs if the loop haven't already hit the viewport or a custom boundary\n    if (cursor != null && isScrollable(cursor, skipOverflowHiddenElements)) {\n      frames.push(cursor)\n    }\n  }\n\n  // Support pinch-zooming properly, making sure elements scroll into the visual viewport\n  // Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height\n  // and viewport dimensions on window.innerWidth/Height\n  // https://www.quirksmode.org/mobile/viewports2.html\n  // https://bokand.github.io/viewport/index.html\n  const viewportWidth = window.visualViewport?.width ?? innerWidth\n  const viewportHeight = window.visualViewport?.height ?? innerHeight\n  const { scrollX, scrollY } = window\n\n  const {\n    height: targetHeight,\n    width: targetWidth,\n    top: targetTop,\n    right: targetRight,\n    bottom: targetBottom,\n    left: targetLeft,\n  } = target.getBoundingClientRect()\n  const {\n    top: marginTop,\n    right: marginRight,\n    bottom: marginBottom,\n    left: marginLeft,\n  } = getScrollMargins(target)\n\n  // These values mutate as we loop through and generate scroll coordinates\n  let targetBlock: number =\n    block === 'start' || block === 'nearest'\n      ? targetTop - marginTop\n      : block === 'end'\n      ? targetBottom + marginBottom\n      : targetTop + targetHeight / 2 - marginTop + marginBottom // block === 'center\n  let targetInline: number =\n    inline === 'center'\n      ? targetLeft + targetWidth / 2 - marginLeft + marginRight\n      : inline === 'end'\n      ? targetRight + marginRight\n      : targetLeft - marginLeft // inline === 'start || inline === 'nearest\n\n  // Collect new scroll positions\n  const computations: ScrollAction[] = []\n  // In chrome there's no longer a difference between caching the `frames.length` to a var or not, so we don't in this case (size > speed anyways)\n  for (let index = 0; index < frames.length; index++) {\n    const frame = frames[index]\n\n    // @TODO add a shouldScroll hook here that allows userland code to take control\n\n    const { height, width, top, right, bottom, left } =\n      frame.getBoundingClientRect()\n\n    // If the element is already visible we can end it here\n    // @TODO targetBlock and targetInline should be taken into account to be compliant with https://github.com/w3c/csswg-drafts/pull/1805/files#diff-3c17f0e43c20f8ecf89419d49e7ef5e0R1333\n    if (\n      scrollMode === 'if-needed' &&\n      targetTop >= 0 &&\n      targetLeft >= 0 &&\n      targetBottom <= viewportHeight &&\n      targetRight <= viewportWidth &&\n      // scrollingElement is added to the frames array even if it's not scrollable, in which case checking its bounds is not required\n      ((frame === scrollingElement && !isScrollable(frame)) ||\n        (targetTop >= top &&\n          targetBottom <= bottom &&\n          targetLeft >= left &&\n          targetRight <= right))\n    ) {\n      // Break the loop and return the computations for things that are not fully visible\n      return computations\n    }\n\n    const frameStyle = getComputedStyle(frame)\n    const borderLeft = parseInt(frameStyle.borderLeftWidth as string, 10)\n    const borderTop = parseInt(frameStyle.borderTopWidth as string, 10)\n    const borderRight = parseInt(frameStyle.borderRightWidth as string, 10)\n    const borderBottom = parseInt(frameStyle.borderBottomWidth as string, 10)\n\n    let blockScroll: number = 0\n    let inlineScroll: number = 0\n\n    // The property existance checks for offfset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here\n    // @TODO find out if the \"as HTMLElement\" overrides can be dropped\n    const scrollbarWidth =\n      'offsetWidth' in frame\n        ? (frame as HTMLElement).offsetWidth -\n          (frame as HTMLElement).clientWidth -\n          borderLeft -\n          borderRight\n        : 0\n    const scrollbarHeight =\n      'offsetHeight' in frame\n        ? (frame as HTMLElement).offsetHeight -\n          (frame as HTMLElement).clientHeight -\n          borderTop -\n          borderBottom\n        : 0\n\n    const scaleX =\n      'offsetWidth' in frame\n        ? (frame as HTMLElement).offsetWidth === 0\n          ? 0\n          : width / (frame as HTMLElement).offsetWidth\n        : 0\n    const scaleY =\n      'offsetHeight' in frame\n        ? (frame as HTMLElement).offsetHeight === 0\n          ? 0\n          : height / (frame as HTMLElement).offsetHeight\n        : 0\n\n    if (scrollingElement === frame) {\n      // Handle viewport logic (document.documentElement or document.body)\n\n      if (block === 'start') {\n        blockScroll = targetBlock\n      } else if (block === 'end') {\n        blockScroll = targetBlock - viewportHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          scrollY,\n          scrollY + viewportHeight,\n          viewportHeight,\n          borderTop,\n          borderBottom,\n          scrollY + targetBlock,\n          scrollY + targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        // block === 'center' is the default\n        blockScroll = targetBlock - viewportHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - viewportWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - viewportWidth\n      } else {\n        // inline === 'nearest' is the default\n        inlineScroll = alignNearest(\n          scrollX,\n          scrollX + viewportWidth,\n          viewportWidth,\n          borderLeft,\n          borderRight,\n          scrollX + targetInline,\n          scrollX + targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      // Apply scroll position offsets and ensure they are within bounds\n      // @TODO add more test cases to cover this 100%\n      blockScroll = Math.max(0, blockScroll + scrollY)\n      inlineScroll = Math.max(0, inlineScroll + scrollX)\n    } else {\n      // Handle each scrolling frame that might exist between the target and the viewport\n      if (block === 'start') {\n        blockScroll = targetBlock - top - borderTop\n      } else if (block === 'end') {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          top,\n          bottom,\n          height,\n          borderTop,\n          borderBottom + scrollbarHeight,\n          targetBlock,\n          targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        // block === 'center' is the default\n        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline - left - borderLeft\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth\n      } else {\n        // inline === 'nearest' is the default\n        inlineScroll = alignNearest(\n          left,\n          right,\n          width,\n          borderLeft,\n          borderRight + scrollbarWidth,\n          targetInline,\n          targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      const { scrollLeft, scrollTop } = frame\n      // Ensure scroll coordinates are not out of bounds while applying scroll offsets\n      blockScroll =\n        scaleY === 0\n          ? 0\n          : Math.max(\n              0,\n              Math.min(\n                scrollTop + blockScroll / scaleY,\n                frame.scrollHeight - height / scaleY + scrollbarHeight\n              )\n            )\n      inlineScroll =\n        scaleX === 0\n          ? 0\n          : Math.max(\n              0,\n              Math.min(\n                scrollLeft + inlineScroll / scaleX,\n                frame.scrollWidth - width / scaleX + scrollbarWidth\n              )\n            )\n\n      // Cache the offset so that parent frames can scroll this into view correctly\n      targetBlock += scrollTop - blockScroll\n      targetInline += scrollLeft - inlineScroll\n    }\n\n    computations.push({ el: frame, top: blockScroll, left: inlineScroll })\n  }\n\n  return computations\n}\n","import { compute } from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/**\n * Only scrolls if the `node` is partially out of view:\n * ```ts\n * scrollIntoView(node, { scrollMode: 'if-needed' })\n * ```\n * Skips scrolling `overflow: hidden` elements:\n * ```ts\n * scrollIntoView(node, { skipOverflowHiddenElements: true })\n * ```\n * When scrolling is needed do the least and smoothest scrolling possible:\n * ```ts\n * scrollIntoView(node, {\n *   behavior: 'smooth',\n *   scrollMode: 'if-needed',\n *   block: 'nearest',\n *   inline: 'nearest',\n * })\n * ```\n * @public\n */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nconst isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nconst isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nconst getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\nconst getScrollMargins = (target: Element) => {\n  const computedStyle = window.getComputedStyle(target)\n  return {\n    top: parseFloat(computedStyle.scrollMarginTop) || 0,\n    right: parseFloat(computedStyle.scrollMarginRight) || 0,\n    bottom: parseFloat(computedStyle.scrollMarginBottom) || 0,\n    left: parseFloat(computedStyle.scrollMarginLeft) || 0,\n  }\n}\n\n// Determine if the element is part of the document (including shadow dom)\n// Derived from code of Andy Desmarais\n// https://terodox.tech/how-to-tell-if-an-element-is-in-the-dom-including-the-shadow-dom/\nconst isInDocument = (element: Node) => {\n  let currentElement = element\n  while (currentElement && currentElement.parentNode) {\n    if (currentElement.parentNode === document) {\n      return true\n    } else if (currentElement.parentNode instanceof ShadowRoot) {\n      currentElement = (currentElement.parentNode as ShadowRoot).host\n    } else {\n      currentElement = currentElement.parentNode\n    }\n  }\n  return false\n}\n\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n * @public\n */\nfunction scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n *\n * You can set the expected return type for `behavior: Function`:\n * ```ts\n * await scrollIntoView<Promise<boolean[]>>(node, {\n *   behavior: async actions => {\n *     return Promise.all(actions.map(\n *       // animate() resolves to `true` if anything was animated, `false` if the element already were in the end state\n *       ({ el, left, top }) => animate(el, {scroll: {left, top}})\n *     ))\n *   }\n * })\n * ```\n * @public\n */\nfunction scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\nfunction scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  if (!target.isConnected || !isInDocument(target)) {\n    return\n  }\n\n  const margins = getScrollMargins(target)\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(compute(target, options))\n  }\n\n  const behavior = typeof options === 'boolean' ? undefined : options?.behavior\n\n  for (const { el, top, left } of compute(target, getOptions(options))) {\n    const adjustedTop = top - margins.top + margins.bottom\n    const adjustedLeft = left - margins.left + margins.right\n    el.scroll({ top: adjustedTop, left: adjustedLeft, behavior })\n  }\n}\n\nexport default scrollIntoView\n","import scrollIntoViewIfNeeded from 'scroll-into-view-if-needed';\n\nimport type { Editor } from '../../interfaces/editor';\nimport type { ScrollIntoViewOptions } from '../../interfaces/scroll';\nimport type { DOMRange } from '../../slate-dom';\n\nimport { type Point, PointApi } from '../../interfaces/point';\n\nconst defaultOptions: ScrollIntoViewOptions = {\n  scrollMode: 'if-needed',\n};\n\n// TODO: move to slate\nexport function scrollIntoView(\n  editor: Editor,\n  target: DOMRange | Point,\n  options: ScrollIntoViewOptions = defaultOptions\n): void {\n  requestAnimationFrame(() => {\n    let domRange: DOMRange | undefined;\n\n    if (PointApi.isPoint(target)) {\n      const { offset = 0, path } = target;\n\n      domRange = editor.api.toDOMRange({\n        anchor: { offset, path },\n        focus: { offset, path },\n      });\n    } else {\n      domRange = target;\n    }\n\n    if (!domRange) return;\n\n    const leafEl = domRange.startContainer.parentElement!;\n\n    leafEl.getBoundingClientRect =\n      domRange.getBoundingClientRect.bind(domRange);\n    scrollIntoViewIfNeeded(leafEl, options);\n\n    setTimeout(() => delete (leafEl as any).getBoundingClientRect, 0);\n  });\n}\n","import type {\n  Editor,\n  EditorNodesOptions,\n  ValueOf,\n} from '../../interfaces/index';\n\n/**\n * Iterate through all of the nodes in the editor and break early for the first\n * truthy match. Otherwise returns false.\n */\nexport const some = <E extends Editor = Editor>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>>\n) => {\n  return !!editor.api.node(options);\n};\n","import { above as aboveBase } from 'slate';\n\nimport type { AncestorOf, EditorAboveOptions } from '../../interfaces';\nimport type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport { getQueryOptions } from '../../utils/match';\n\nexport const above = <N extends AncestorOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: EditorAboveOptions<ValueOf<E>>\n): NodeEntry<N> | undefined => {\n  try {\n    return aboveBase(editor as any, getQueryOptions(editor, options)) as any;\n  } catch {\n    return undefined;\n  }\n};\n","import { addMark as addMarkBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const addMark = (editor: Editor, key: string, value: any) =>\n  addMarkBase(editor as any, key, value);\n","import type { EditorRangeRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { rangeRef } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TRange } from '../../interfaces/range';\n\nexport const createRangeRef = (\n  editor: Editor,\n  range: TRange,\n  options?: EditorRangeRefOptions\n) => rangeRef(editor as any, range, options as any);\n","import { deleteBackward as deleteBackwardBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TextUnit } from '../../types';\n\nexport const deleteBackward = (\n  editor: Editor,\n  unit: TextUnit = 'character'\n) => {\n  deleteBackwardBase(editor as any, unit);\n};\n","import { deleteForward as deleteForwardBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TextUnit } from '../../types';\n\nexport const deleteForward = (editor: Editor, unit: TextUnit = 'character') => {\n  deleteForwardBase(editor as any, unit);\n};\n","import type { EditorFragmentDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { deleteFragment as deleteFragmentBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const deleteFragment = (\n  editor: Editor,\n  options?: EditorFragmentDeletionOptions\n) => deleteFragmentBase(editor as any, options);\n","import { node as nodeBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\nimport type { AtOrDescendant } from '../../types';\n\nimport {\n  type DescendantOf,\n  type EditorNodeOptions,\n  type EditorNodesOptions,\n  type ValueOf,\n  LocationApi,\n} from '../../interfaces';\nimport { getAt } from '../../utils';\n\nexport const node = <N extends DescendantOf<E>, E extends Editor = Editor>(\n  editor: E,\n  atOrOptions: AtOrDescendant | EditorNodesOptions<ValueOf<E>>,\n  nodeOptions?: EditorNodeOptions\n): NodeEntry<N> | undefined => {\n  try {\n    if (LocationApi.isAt(atOrOptions)) {\n      const at = getAt(editor, atOrOptions)!;\n\n      return nodeBase(editor as any, at, nodeOptions) as any;\n    }\n\n    const options = atOrOptions;\n\n    const nodeEntries = editor.api.nodes<N>(options);\n\n    return nodeEntries.next().value as any;\n  } catch {\n    return undefined;\n  }\n};\n","import { type EditorPathOptions, path as pathBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const path = (editor: Editor, at: At, options?: EditorPathOptions) => {\n  try {\n    return pathBase(editor as any, getAt(editor, at)!, options as any);\n  } catch {}\n};\n","import { edges } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils/getAt';\n\nexport const getEdgePoints = (editor: Editor, at: At) => {\n  try {\n    return edges(editor as any, getAt(editor, at)!);\n  } catch {}\n};\n","import { string } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorStringOptions } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils/getAt';\n\nexport const getEditorString = (\n  editor: Editor,\n  at: At | null = editor.selection,\n  options?: EditorStringOptions\n) => {\n  if (!at) return '';\n\n  try {\n    return string(editor as any, getAt(editor, at)!, options);\n  } catch {\n    return '';\n  }\n};\n","import { first } from 'slate';\n\nimport type { DescendantOf, NodeEntry } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getFirstNode = <N extends DescendantOf<E>, E extends Editor>(\n  editor: E,\n  at: At\n): NodeEntry<N> | undefined => {\n  try {\n    return first(editor as any, getAt(editor, at)!) as any;\n  } catch {}\n};\n","import { fragment, getFragment as getFragmentBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { ElementOrTextOf, TElement } from '../../interfaces/element';\nimport type { EditorFragmentOptions } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nconst unwrapContainerNodes = (nodes: TElement[], types: string[]) => {\n  const unwrap = (nodes: TElement[], acc: TElement[] = []): TElement[] => {\n    nodes.forEach((node) => {\n      if (types?.includes(node.type)) {\n        return unwrap(node.children as TElement[], acc);\n      }\n\n      acc.push(node);\n    });\n\n    return acc;\n  };\n\n  return unwrap(nodes);\n};\n\nexport const getFragment = <E extends Editor>(\n  editor: E,\n  at?: At | null,\n  options?: EditorFragmentOptions\n): ElementOrTextOf<E>[] => {\n  if (at === null) return [];\n\n  try {\n    const result =\n      at === undefined\n        ? (getFragmentBase(editor as any) as any)\n        : (fragment(editor as any, getAt(editor, at)!) as any);\n\n    if (result.length > 0 && options?.unwrap && options.unwrap.length > 0) {\n      return unwrapContainerNodes(result, options.unwrap) as any;\n    }\n\n    return result;\n  } catch {\n    return [];\n  }\n};\n","import { levels } from 'slate';\n\nimport type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\nimport type { EditorLevelsOptions } from '../../interfaces/index';\nimport type { NodeOf } from '../../interfaces/node';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport { getQueryOptions } from '../../utils';\n\nexport const getLevels = <N extends NodeOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: EditorLevelsOptions<ValueOf<E>>\n): Generator<NodeEntry<N>, void, undefined> => {\n  return levels(editor as any, getQueryOptions(editor, options)) as any;\n};\n","import { marks } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { MarksOf } from '../../interfaces/text';\n\nexport const getMarks = <E extends Editor>(editor: E) =>\n  marks(editor as any) as MarksOf<E> | null;\n","import { pathRefs } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const getPathRefs = (editor: Editor) => pathRefs(editor as any);\n","import { type EditorPointOptions, point } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getPoint = (\n  editor: Editor,\n  at: At,\n  options?: EditorPointOptions\n) => {\n  try {\n    return point(editor as any, getAt(editor, at)!, options as any);\n  } catch {}\n};\n","import { pointRefs } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const getPointRefs = (editor: Editor) => pointRefs(editor as any);\n","import { positions } from 'slate';\n\nimport type { EditorPositionsOptions } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nimport { getAt } from '../../utils';\n\nexport const getPositions = (\n  editor: Editor,\n  options?: EditorPositionsOptions\n) =>\n  positions(editor as any, {\n    ...options,\n    at: getAt(editor, options?.at),\n  });\n","import { rangeRefs } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const getRangeRefs = (editor: Editor) => rangeRefs(editor as any);\n","import { hasBlocks as hasBlocksBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TElement } from '../../interfaces/element';\n\nexport const hasBlocks = (editor: Editor, element: TElement) =>\n  hasBlocksBase(editor as any, element);\n","import { hasInlines as hasInlinesBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TElement } from '../../interfaces/element';\n\nexport const hasInlines = (editor: Editor, element: TElement) =>\n  hasInlinesBase(editor as any, element);\n","import { hasTexts as hasTextsBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TElement } from '../../interfaces/element';\n\nexport const hasTexts = (editor: Editor, element: TElement) =>\n  hasTextsBase(editor as any, element);\n","import { insertBreak as insertBreakBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const insertBreak = (editor: Editor) => insertBreakBase(editor as any);\n","import type { DescendantOf, InsertNodesOptions } from '../../interfaces';\nimport type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\n\nexport const insertNode = <\n  N extends DescendantOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  node: N,\n  options?: InsertNodesOptions<ValueOf<E>>\n) => editor.tf.insertNodes(node, options);\n","import { isEdge } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TLocation } from '../../interfaces/index';\nimport type { Point } from '../../interfaces/point';\n\nexport const isEdgePoint = (editor: Editor, point: Point, at: TLocation) =>\n  isEdge(editor as any, point, at);\n","import { isNormalizing } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const isEditorNormalizing = (editor: Editor) =>\n  isNormalizing(editor as any);\n","import { elementReadOnly } from 'slate';\n\nimport type { EditorElementReadOnlyOptions } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const isElementReadOnly = <E extends Editor = Editor>(\n  editor: E,\n  options?: EditorElementReadOnlyOptions\n) => elementReadOnly(editor as any, options);\n","import { isEmpty as isEmptyBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport {\n  type EditorEmptyOptions,\n  NodeApi,\n  PathApi,\n  TextApi,\n} from '../../interfaces';\n\nexport const isEmpty = <E extends Editor>(\n  editor: E,\n  target: At | null = [],\n  options?: EditorEmptyOptions\n) => {\n  if (target === null) return true;\n  if (\n    (PathApi.isPath(target) && target.length === 0) ||\n    NodeApi.isEditor(target)\n  ) {\n    return (\n      editor.children.length === 1 &&\n      isEmptyBase(editor as any, editor.children[0] as any)\n    );\n  }\n  if (options?.after) {\n    const blockAbove = editor.api.block({ above: true, at: target });\n\n    if (!blockAbove) return false;\n\n    const point = editor.api.point(target)!;\n    const selectionParentEntry = editor.api.parent(target);\n\n    if (!selectionParentEntry) return false;\n\n    const [, selectionParentPath] = selectionParentEntry;\n\n    if (!editor.api.isEnd(point, selectionParentPath)) return false;\n\n    const siblingNodes = Array.from(\n      NodeApi.children(editor, blockAbove[1], {\n        from: PathApi.lastIndex(point.path) + 1,\n      })\n    ).map(([node]) => node);\n\n    if (siblingNodes.length > 0) {\n      for (const siblingNode of siblingNodes) {\n        if (TextApi.isText(siblingNode) && siblingNode.text) {\n          return false;\n        }\n      }\n    } else {\n      return editor.api.isEnd(point, blockAbove[1]);\n    }\n\n    return true;\n  }\n  if (PathApi.isPath(target)) {\n    return isEmptyBase(editor as any, editor.api.node(target)?.[0] as any);\n  }\n  if (options?.block) {\n    const block = editor.api.block({ at: target });\n\n    if (!block) return false;\n\n    target = block[0];\n  }\n  if (!NodeApi.isNode(target)) {\n    const nodes = editor.api.nodes({ at: target, ...options });\n\n    for (const node of nodes) {\n      if (!isEmptyBase(editor as any, node[0] as any)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return isEmptyBase(editor as any, target as any);\n};\n","import { isEnd } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TLocation } from '../../interfaces/index';\nimport type { Point } from '../../interfaces/point';\n\nexport const isEndPoint = (\n  editor: Editor,\n  point: Point | null | undefined,\n  at: TLocation\n) => !!point && isEnd(editor as any, point, at);\n","import { isStart } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TLocation } from '../../interfaces/index';\nimport type { Point } from '../../interfaces/point';\n\nexport const isStartPoint = (\n  editor: Editor,\n  point: Point | null | undefined,\n  at: TLocation\n) => !!point && isStart(editor as any, point, at);\n","import { last as lastBase } from 'slate';\n\nimport type {\n  DescendantOf,\n  Editor,\n  EditorLastOptions,\n  NodeEntry,\n} from '../../interfaces';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nconst getNodeAtLevel = (\n  editor: Editor,\n  [node, path]: NodeEntry,\n  level: number\n): NodeEntry => {\n  // Get the path at the desired level\n  const levelPath = path.slice(0, level + 1);\n\n  // Get the node at that path\n  const entry = editor.api.node(levelPath);\n\n  if (!entry) return [node, path];\n\n  return entry;\n};\n\nexport const last = <N extends DescendantOf<E>, E extends Editor>(\n  editor: E,\n  at: At,\n  options: EditorLastOptions = {}\n): NodeEntry<N> | undefined => {\n  try {\n    const { level } = options;\n\n    const lastNodeEntry = lastBase(\n      editor as any,\n      getAt(editor, at)!\n    ) as NodeEntry<N>;\n\n    // If level is specified, get the node at that level\n    if (lastNodeEntry && typeof level === 'number') {\n      if (editor.children.length === 0) {\n        return;\n      }\n\n      return getNodeAtLevel(editor, lastNodeEntry, level) as any;\n    }\n\n    return lastNodeEntry;\n  } catch {}\n};\n","import type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport {\n  type DescendantOf,\n  type EditorNextOptions,\n  type Path,\n  type Span,\n  PathApi,\n} from '../../interfaces';\nimport { combineMatch, getAt, getMatch } from '../../utils';\n\nexport const next = <N extends DescendantOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options: EditorNextOptions<ValueOf<E>> = {}\n): NodeEntry<N> | undefined => {\n  const {\n    from = 'after',\n    mode = from === 'child' ? 'all' : 'lowest',\n    voids = false,\n  } = options;\n  let match = getMatch(editor, options);\n\n  const at = getAt(editor, options.at) ?? editor.selection;\n\n  if (!at) {\n    return;\n  }\n\n  let start: Path | undefined;\n\n  // FORK: from\n  if (from === 'child' && PathApi.isPath(at)) {\n    const path = PathApi.firstChild(at);\n    const fromNode = editor.api.node(path);\n\n    if (fromNode) {\n      start = path;\n      match = combineMatch((n, p) => {\n        return !PathApi.isAncestor(p, at) && !PathApi.equals(p, at);\n      }, match);\n    }\n  }\n  if (!start) {\n    const pointAfterLocation = editor.api.after(at, { voids })!;\n\n    if (!pointAfterLocation) return;\n\n    start = pointAfterLocation.path;\n  }\n\n  const [, to] = editor.api.last([])!;\n\n  // FORK: from\n  const span: Span = [start, to];\n\n  if (PathApi.isPath(at) && at.length === 0) {\n    // throw new Error(`Cannot get the next node from the root node!`);\n    return;\n  }\n  if (match == null) {\n    if (PathApi.isPath(at)) {\n      const [parent] = editor.api.parent(at)!;\n      match = (n) => parent.children.includes(n as any);\n    } else {\n      match = () => true;\n    }\n  }\n\n  const [next] = editor.api.nodes({ at: span, match, mode, voids });\n\n  return next as any;\n};\n","import { normalize } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorNormalizeOptions } from '../../interfaces/index';\n\nexport const normalizeEditor = (\n  editor: Editor,\n  options?: EditorNormalizeOptions\n) => normalize(editor as any, options);\n","import { parent as parentBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorParentOptions } from '../../interfaces/index';\nimport type { AncestorOf } from '../../interfaces/node';\nimport type { NodeEntry } from '../../interfaces/node-entry';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const parent = <N extends AncestorOf<E>, E extends Editor = Editor>(\n  editor: E,\n  at: At,\n  options?: EditorParentOptions\n): NodeEntry<N> | undefined => {\n  try {\n    return parentBase(editor as any, getAt(editor, at)!, options) as any;\n  } catch {}\n};\n","import type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport {\n  type DescendantOf,\n  type EditorPreviousOptions,\n  type Path,\n  type Span,\n  PathApi,\n} from '../../interfaces';\nimport { combineMatch, getAt, getMatch, getQueryOptions } from '../../utils';\n\n// Slate fork\nconst previousBase = (\n  editor: Editor,\n  options: EditorPreviousOptions<ValueOf<Editor>>\n) => {\n  const { from = 'after', mode = 'lowest', voids = false } = options;\n  let match = getMatch(editor, options);\n\n  const at = getAt(editor, options.at) ?? editor.selection;\n\n  if (!at) {\n    return;\n  }\n\n  let start: Path | undefined;\n\n  // FORK: from\n  if (from === 'parent' && PathApi.isPath(at) && at.length > 1) {\n    start = at;\n\n    match = combineMatch((n, p) => {\n      // We want nodes that:\n      // 1. Are not after our target path\n      // 2. Are not the same as our target path\n      return !PathApi.isAfter(p, at) && !PathApi.equals(p, at);\n    }, match);\n  }\n  if (!start) {\n    const pointBeforeLocation = editor.api.before(at, { voids })!;\n\n    if (!pointBeforeLocation) return;\n\n    start = pointBeforeLocation.path;\n  }\n\n  const [, to] = editor.api.first([])!;\n\n  // The search location is from the start of the document to the path of\n  // the point before the location passed in\n  const span: Span = [start, to];\n\n  if (PathApi.isPath(at) && at.length === 0) {\n    // throw new Error(`Cannot get the previous node from the root node!`);\n    return;\n  }\n  if (match == null) {\n    if (PathApi.isPath(at)) {\n      const [parent] = editor.api.parent(at)!;\n      match = (n) => parent.children.includes(n as any);\n    } else {\n      match = () => true;\n    }\n  }\n\n  const [previous] = editor.api.nodes({\n    at: span,\n    match,\n    mode,\n    reverse: true,\n    voids,\n  });\n\n  return previous;\n};\n\nexport const previous = <N extends DescendantOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: EditorPreviousOptions<ValueOf<E>>\n): NodeEntry<N> | undefined => {\n  const getPrevious = (o: EditorPreviousOptions<ValueOf<E>>) => {\n    try {\n      return previousBase(editor as any, o) as any;\n    } catch {}\n  };\n\n  if (options?.sibling) {\n    const path = getQueryOptions(editor, options).at;\n\n    if (!path) return;\n\n    const previousPath = PathApi.previous(path);\n\n    if (!previousPath) return;\n\n    const previousNode = editor.api.node(previousPath);\n\n    return previousNode as NodeEntry<N>;\n  }\n  if (!(options?.id && options?.block)) {\n    return getPrevious(options as any);\n  }\n\n  const block = editor.api.node({\n    id: options.id,\n    at: [],\n  });\n\n  if (!block) return;\n\n  // both id and block are defined\n  return getPrevious({ at: block[1], block: true });\n};\n","import { range as rangeBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport {\n  type EditorBeforeOptions,\n  type TRange,\n  PointApi,\n  RangeApi,\n} from '../../interfaces';\nimport { getAt } from '../../utils';\n\nexport const range = (\n  editor: Editor,\n  at: At | 'before' | 'start',\n  to?: At | null,\n  options?: { before?: EditorBeforeOptions }\n): TRange | undefined => {\n  let from = getAt(editor, at);\n\n  if (RangeApi.isRange(from) && !to) {\n    return from;\n  }\n  if (from === 'start') {\n    const path = editor.api.block({ at: to! })?.[1];\n\n    if (!path) return;\n\n    const anchor = editor.api.start(path);\n\n    if (!anchor) return;\n\n    const focus = PointApi.get(to);\n\n    if (!focus) return;\n\n    return { anchor, focus };\n  }\n  if (to && from === 'before') {\n    const anchor = editor.api.before(to, options?.before);\n\n    from = anchor ?? getAt(editor, to);\n  }\n\n  return rangeBase(editor as any, from as any, getAt(editor, to));\n};\n","import { removeMark } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const removeEditorMark = (editor: Editor, key: string) =>\n  removeMark(editor as any, key);\n","import type { Editor } from '../../interfaces/editor/editor-type';\n\nimport { type NodeEntry, ElementApi, TextApi } from '../../interfaces';\n\nexport const shouldMergeNodes = (\n  editor: Editor,\n  prevNodeEntry: NodeEntry,\n  _: NodeEntry\n) => {\n  const [prevNode, prevPath] = prevNodeEntry;\n\n  // If the target node that we're merging with is empty, remove it instead\n  // of merging the two. This is a common rich text editor behavior to\n  // prevent losing formatting when deleting entire nodes when you have a\n  // hanging selection.\n  // if prevNode is first child in parent,don't remove it.\n\n  if (\n    (ElementApi.isElement(prevNode) && editor.api.isEmpty(prevNode)) ||\n    (TextApi.isText(prevNode) && prevNode.text === '' && prevPath.at(-1) !== 0)\n  ) {\n    editor.tf.removeNodes({ at: prevPath });\n    return false;\n  }\n\n  return true;\n};\n","import { unhangRange as unhangRangeBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nimport {\n  type EditorUnhangRangeOptions,\n  type TRange,\n  PathApi,\n  RangeApi,\n} from '../../interfaces/index';\n\nexport const unhangRange = (\n  editor: Editor,\n  range: TRange,\n  options: EditorUnhangRangeOptions = {}\n): TRange => {\n  const { character, unhang = true, voids } = options;\n\n  if (!RangeApi.isRange(range)) return range;\n  if (character) {\n    let [start, end] = RangeApi.edges(range);\n\n    if (!PathApi.equals(start.path, end.path)) {\n      if (end.offset === 0) {\n        const pointAfter = editor.api.after(start);\n\n        if (pointAfter) {\n          end = pointAfter;\n        }\n      } else {\n        const pointBefore = editor.api.before(end);\n\n        if (pointBefore) {\n          start = pointBefore;\n        }\n      }\n    }\n\n    return { anchor: start, focus: end };\n  }\n  if (unhang) {\n    return unhangRangeBase(editor as any, range, { voids }) as TRange;\n  }\n\n  return range;\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { AddMarksOptions, Editor, EditorMarks } from '../../interfaces';\n\nexport const addMarks = (\n  editor: Editor,\n  marks: EditorMarks,\n  { remove }: AddMarksOptions = {}\n) => {\n  if (!editor.selection) return;\n\n  editor.tf.withoutNormalizing(() => {\n    editor.tf.removeMarks([\n      ...castArray<string>(remove),\n      ...Object.keys(marks),\n    ]);\n\n    Object.entries(marks).forEach(([key, value]) => {\n      editor.tf.addMark(key, value);\n    });\n  });\n};\n","import {\n  type DuplicateNodesOptions,\n  type Editor,\n  PathApi,\n} from '../../interfaces';\nimport { getAt } from '../../utils';\n\nexport const duplicateNodes = (\n  editor: Editor,\n  { block, nodes, ...options }: DuplicateNodesOptions = {}\n) => {\n  const at = getAt(editor, options.at) ?? editor.selection;\n\n  if (!nodes || !at) return;\n\n  // Use provided nodes or get blocks if block=true\n  const entries = nodes ?? (block ? editor.api.blocks({ at }) : []);\n\n  if (entries.length === 0) return;\n\n  const lastEntry = entries.at(-1)!;\n  const insertPath = PathApi.next(lastEntry[1]);\n  const nodesToInsert = entries.map(([node]) => node);\n\n  editor.tf.insertNodes(nodesToInsert as any, {\n    at: insertPath,\n    ...options,\n  });\n};\n","import castArray from 'lodash/castArray.js';\n\nimport {\n  type Editor,\n  type Path,\n  type RemoveMarksOptions,\n  type TElement,\n  type TNode,\n  RangeApi,\n  TextApi,\n} from '../../interfaces';\n\nexport const removeMarks = (\n  editor: Editor,\n  keys?: string[] | string | null,\n  { at, shouldChange = true, ...options }: RemoveMarksOptions = {}\n) => {\n  const selection = at ?? editor.selection;\n\n  if (!selection) return;\n\n  const match = (node: TNode, path: Path) => {\n    if (!TextApi.isText(node)) {\n      return false; // marks can only be applied to text\n    }\n\n    const [parentNode] = editor.api.parent<TElement>(path)!;\n\n    return (\n      !editor.api.isVoid(parentNode) || editor.api.markableVoid(parentNode)\n    );\n  };\n\n  const expandedSelection = RangeApi.isExpanded(selection);\n  let markAcceptingVoidSelected = false;\n\n  if (!expandedSelection) {\n    const [selectedNode, selectedPath] = editor.api.node(selection)!;\n\n    if (selectedNode && match(selectedNode, selectedPath)) {\n      const [parentNode] = editor.api.parent<TElement>(selectedPath)!;\n      markAcceptingVoidSelected =\n        parentNode && editor.api.markableVoid(parentNode);\n    }\n  }\n  if (keys && (expandedSelection || markAcceptingVoidSelected)) {\n    const props = castArray(keys);\n\n    editor.tf.unsetNodes(props, {\n      at: selection,\n      match,\n      split: true,\n      voids: true,\n      ...options,\n    });\n  } else if (!at) {\n    // Only modify editor.marks when no custom range is provided and selection is collapsed\n    const marks = { ...editor.api.marks() };\n\n    if (keys) {\n      castArray(keys).forEach((k) => {\n        delete marks[k];\n      });\n      editor.marks = marks;\n    } else {\n      editor.marks = {};\n    }\n\n    // Slate does not export FLUSHING so we need to call onChange manually\n    shouldChange && editor.api.onChange();\n  }\n};\n","import type {\n  Editor,\n  ElementOrTextOf,\n  ReplaceNodesOptions,\n  ValueOf,\n} from '../../interfaces';\n\nimport { getAt } from '../../utils';\n\nexport const replaceNodes = <\n  N extends ElementOrTextOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  nodes: N | N[],\n  {\n    at,\n    children,\n    removeNodes: removeOptions,\n    ...options\n  }: ReplaceNodesOptions<ValueOf<E>>\n) => {\n  editor.tf.withoutNormalizing(() => {\n    if (children) {\n      if (!at) return;\n\n      at = getAt(editor, at);\n\n      const path = editor.api.path(at!);\n\n      if (!path) return;\n\n      // Remove all children at path\n      editor.tf.removeNodes({\n        ...removeOptions,\n        at: path,\n        children: true,\n      });\n\n      // Insert at first child position\n      editor.tf.insertNodes(nodes, {\n        ...options,\n        at: path.concat([0]),\n      });\n    } else {\n      // Replace node at path\n      editor.tf.removeNodes({ ...removeOptions, at });\n\n      editor.tf.insertNodes(nodes, {\n        ...options,\n        at,\n      });\n    }\n  });\n};\n","import type { Editor, ResetOptions } from '../../interfaces';\n\nexport const reset = (editor: Editor, options: ResetOptions = {}) => {\n  editor.tf.replaceNodes(editor.api.create.value(), {\n    at: [],\n    children: true,\n    ...options,\n  } as any);\n\n  if (!options.children) {\n    editor.operations = [];\n    editor.marks = null;\n\n    if (editor.history?.undos) {\n      editor.history.undos = [];\n      editor.history.redos = [];\n    }\n  }\n};\n","import type { Editor, TElement, ToggleBlockOptions } from '../../interfaces';\n\nexport const toggleBlock = (\n  editor: Editor,\n  type: string,\n  {\n    defaultType: defaultTypeProp,\n    someOptions,\n    wrap,\n    ...options\n  }: ToggleBlockOptions = {}\n) => {\n  const at = options.at ?? editor.selection;\n\n  if (!at) return;\n\n  const isActive = editor.api.some({\n    at,\n    ...someOptions,\n    match: { type },\n  });\n\n  if (wrap) {\n    if (isActive) {\n      editor.tf.unwrapNodes({ at, match: { type } });\n    } else {\n      editor.tf.wrapNodes({ children: [], type }, { at });\n    }\n\n    return;\n  }\n\n  const defaultType = defaultTypeProp ?? editor.api.create.block().type ?? 'p';\n\n  if (isActive && type === defaultType) return;\n\n  editor.tf.setNodes<TElement>(\n    {\n      type: isActive ? defaultType : type,\n    },\n    { at: at as any, ...options }\n  );\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { Editor, ToggleMarkOptions } from '../../interfaces';\n\n/** Add or remove mark in the selection. */\nexport const toggleMark = (\n  editor: Editor,\n  key: string,\n  { remove }: ToggleMarkOptions = {}\n) => {\n  if (!editor.selection) return;\n\n  editor.tf.withoutNormalizing(() => {\n    if (editor.api.hasMark(key)) {\n      editor.tf.removeMark(key);\n\n      return;\n    }\n\n    editor.tf.removeMarks([...castArray<string>(remove), key]);\n\n    editor.tf.addMark(key, true);\n  });\n};\n","import type { SelectionCollapseOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { collapse } from 'slate';\n\nimport type { Editor } from '../../interfaces';\n\nexport const collapseSelection = (\n  editor: Editor,\n  options?: SelectionCollapseOptions\n) => {\n  collapse(editor as any, options);\n};\n","import {\n  type DeleteTextOptions,\n  type Editor,\n  type NodeEntry,\n  type Path,\n  ElementApi,\n  PathApi,\n  PointApi,\n  RangeApi,\n} from '../../interfaces';\nimport { getAt } from '../../utils';\n\nexport const deleteText = <E extends Editor>(\n  editor: E,\n  options: DeleteTextOptions = {}\n) => {\n  // deleteTextBase(editor as any, {\n  //   ...options,\n  //   at: getAt(editor, options?.at),\n  // });\n\n  let at: any = getAt(editor, options?.at) ?? editor.selection;\n\n  editor.tf.withoutNormalizing(() => {\n    const {\n      distance = 1,\n      reverse = false,\n      unit = 'character',\n      voids = false,\n    } = options;\n    let { hanging = false } = options;\n\n    if (!at) {\n      return;\n    }\n\n    let isCollapsed = false;\n    if (RangeApi.isRange(at) && RangeApi.isCollapsed(at)) {\n      isCollapsed = true;\n      at = at.anchor;\n    }\n\n    if (PointApi.isPoint(at)) {\n      const furthestVoid = editor.api.void({ at, mode: 'highest' });\n\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        const opts = { distance, unit };\n        const target = reverse\n          ? editor.api.before(at, opts) || editor.api.start([])\n          : editor.api.after(at, opts) || editor.api.end([]);\n        at = { anchor: at, focus: target };\n        hanging = true;\n      }\n    }\n\n    if (PathApi.isPath(at)) {\n      editor.tf.removeNodes({ at, voids });\n      return;\n    }\n\n    if (RangeApi.isCollapsed(at)) {\n      return;\n    }\n\n    if (!hanging) {\n      const [, end] = RangeApi.edges(at);\n      const endOfDoc = editor.api.end([])!;\n\n      if (!PointApi.equals(end, endOfDoc)) {\n        at = editor.api.unhangRange(at, { voids });\n      }\n    }\n\n    let [start, end] = RangeApi.edges(at);\n    const startBlock = editor.api.above({\n      at: start,\n      voids,\n      match: (n) => ElementApi.isElement(n) && editor.api.isBlock(n),\n    });\n    const endBlock = editor.api.above({\n      at: end,\n      voids,\n      match: (n) => ElementApi.isElement(n) && editor.api.isBlock(n),\n    });\n    const isAcrossBlocks =\n      startBlock && endBlock && !PathApi.equals(startBlock[1], endBlock[1]);\n    const isSingleText = PathApi.equals(start.path, end.path);\n    const startNonEditable = voids\n      ? null\n      : (editor.api.void({ at: start, mode: 'highest' }) ??\n        editor.api.elementReadOnly({ at: start, mode: 'highest' }));\n    const endNonEditable = voids\n      ? null\n      : (editor.api.void({ at: end, mode: 'highest' }) ??\n        editor.api.elementReadOnly({ at: end, mode: 'highest' }));\n\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startNonEditable) {\n      const before = editor.api.before(start);\n\n      if (\n        before &&\n        startBlock &&\n        PathApi.isAncestor(startBlock[1], before.path)\n      ) {\n        start = before;\n      }\n    }\n\n    if (endNonEditable) {\n      const after = editor.api.after(end);\n\n      if (after && endBlock && PathApi.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    const matches: NodeEntry[] = [];\n    let lastPath: Path | undefined;\n\n    for (const entry of editor.api.nodes({ at, voids })) {\n      const [node, path] = entry;\n\n      if (lastPath && PathApi.compare(path, lastPath) === 0) {\n        continue;\n      }\n\n      if (\n        (!voids &&\n          ElementApi.isElement(node) &&\n          // !PATCH: DO NOT remove void blocks\n          // (editor.api.isVoid(node) ||\n          editor.api.isElementReadOnly(node)) ||\n        (!PathApi.isCommon(path, start.path) &&\n          !PathApi.isCommon(path, end.path))\n      ) {\n        matches.push(entry);\n        lastPath = path;\n      }\n    }\n\n    const pathRefs = Array.from(matches, ([, p]) => editor.api.pathRef(p));\n    const startRef = editor.api.pointRef(start);\n    const endRef = editor.api.pointRef(end);\n\n    let removedText = '';\n\n    if (!isSingleText && !startNonEditable) {\n      const point = startRef.current!;\n      const [node] = editor.api.leaf(point)!;\n      const { path } = point;\n      const { offset } = start;\n      const text = node.text.slice(offset);\n      if (text.length > 0) {\n        editor.tf.apply({ offset, path, text, type: 'remove_text' });\n        removedText = text;\n      }\n    }\n\n    pathRefs\n      .reverse()\n      .map((r) => r.unref())\n      .filter((r): r is Path => r !== null)\n      .forEach((p) => {\n        return editor.tf.removeNodes({ at: p, voids });\n      });\n\n    if (!endNonEditable) {\n      const point = endRef.current!;\n      const [node] = editor.api.leaf(point)!;\n      const { path } = point;\n      const offset = isSingleText ? start.offset : 0;\n      const text = node.text.slice(offset, end.offset);\n      if (text.length > 0) {\n        editor.tf.apply({ offset, path, text, type: 'remove_text' });\n        removedText = text;\n      }\n    }\n\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      editor.tf.mergeNodes({\n        at: endRef.current,\n        hanging: true,\n        reverse: !reverse,\n        voids,\n      });\n    }\n\n    // For Thai script, deleting N character(s) backward should delete\n    // N code point(s) instead of an entire grapheme cluster.\n    // Therefore, the remaining code points should be inserted back.\n    if (\n      isCollapsed &&\n      reverse &&\n      unit === 'character' &&\n      removedText.length > 1 &&\n      /[\\u0E00-\\u0E7F]+/.exec(removedText)\n    ) {\n      editor.tf.insertText(removedText.slice(0, removedText.length - distance));\n    }\n\n    const startUnref = startRef.unref();\n    const endUnref = endRef.unref();\n    const point = reverse ? startUnref || endUnref : endUnref || startUnref;\n\n    if (options?.at == null && point) {\n      editor.tf.select(point);\n    }\n  });\n};\n","import { deselect as deselectBase } from 'slate';\n\nimport type { Editor } from '../../interfaces';\n\nexport const deselect = (editor: Editor) => {\n  deselectBase(editor as any);\n};\n","import { insertFragment as insertFragmentBase } from 'slate';\n\nimport type {\n  Editor,\n  ElementOrTextOf,\n  InsertFragmentOptions,\n} from '../../interfaces';\n\nimport { getAt } from '../../utils/getAt';\n\nexport const insertFragment = <\n  N extends ElementOrTextOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  fragment: N[],\n  options?: InsertFragmentOptions\n) => {\n  insertFragmentBase(editor as any, fragment, {\n    ...options,\n    at: getAt(editor, options?.at),\n  });\n};\n","import { insertNodes as insertNodesBase } from 'slate';\n\nimport {\n  type Descendant,\n  type Editor,\n  type ElementOrTextOf,\n  type InsertNodesOptions,\n  type ValueOf,\n  NodeApi,\n  PathApi,\n} from '../../interfaces';\nimport { type QueryNodeOptions, getQueryOptions, queryNode } from '../../utils';\n\nexport const insertNodes = <\n  N extends ElementOrTextOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  nodes: N | N[],\n  { nextBlock, removeEmpty, ...options }: InsertNodesOptions<ValueOf<E>> = {}\n) => {\n  options = getQueryOptions(editor, options);\n\n  editor.tf.withoutNormalizing(() => {\n    if (removeEmpty) {\n      const blockEntry = editor.api.above({ at: options.at });\n\n      if (blockEntry) {\n        const queryNodeOptions: QueryNodeOptions =\n          removeEmpty === true\n            ? {\n                allow: ['p'],\n              }\n            : removeEmpty;\n\n        const { filter } = queryNodeOptions;\n\n        queryNodeOptions.filter = ([node, path]) => {\n          if (NodeApi.string(node)) return false;\n\n          const children = node.children as Descendant[];\n\n          if (children.some((n) => editor.api.isInline(n))) return false;\n\n          return !filter || filter([node, path]);\n        };\n\n        if (queryNode(blockEntry, queryNodeOptions)) {\n          editor.tf.removeNodes({ at: blockEntry[1] });\n          nextBlock = false;\n        }\n      }\n    }\n    if (nextBlock) {\n      const { at = editor.selection } = options;\n\n      if (at) {\n        const endPoint = editor.api.end(at);\n\n        const blockEntry = editor.api.above({\n          at: endPoint,\n          block: true,\n        });\n\n        if (blockEntry) {\n          options.at = PathApi.next(blockEntry[1]);\n        }\n      }\n    }\n\n    insertNodesBase(editor as any, nodes, options as any);\n  });\n};\n","import type { Editor } from '../../interfaces';\n\n/**\n * Insert a soft break at the current selection. If the selection is currently\n * expanded, delete it first.\n */\nexport const insertSoftBreak = (editor: Editor) => {\n  editor.tf.withoutNormalizing(() => {\n    if (editor.api.isExpanded()) {\n      editor.tf.delete();\n    }\n    editor.tf.insertText('\\n');\n  });\n};\n","import { Transforms } from 'slate';\n\nimport type { Editor, InsertTextOptions } from '../../interfaces';\n\nimport { getAt } from '../../utils';\n\nexport const insertText = (\n  editor: Editor,\n  text: string,\n  { marks = true, ...options }: InsertTextOptions = {}\n) => {\n  const at = getAt(editor, options.at);\n\n  // Case 1: Insert at options.at if specified, regardless of selection\n  if (at) {\n    Transforms.insertText(editor as any, text, { ...options, at });\n\n    return;\n  }\n  // Case 2: Default Slate behavior - only proceed if there's a selection\n  if (editor.selection) {\n    if (marks && editor.marks) {\n      // Case 2.1: Insert with marks if any\n      const node = { text, ...editor.marks };\n      editor.tf.insertNodes(node, {\n        voids: options.voids,\n      });\n      editor.marks = null;\n    } else {\n      // Case 2.2: Insert plain text\n      Transforms.insertText(editor as any, text, options as any);\n    }\n  }\n};\n","import { liftNodes as liftNodesBase } from 'slate';\n\nimport type { Editor, LiftNodesOptions, ValueOf } from '../../interfaces';\n\nimport { getQueryOptions } from '../../utils';\n\nexport const liftNodes = <E extends Editor>(\n  editor: E,\n  options?: LiftNodesOptions<ValueOf<E>>\n) => {\n  return liftNodesBase(editor as any, getQueryOptions(editor, options));\n};\n","import {\n  type Editor,\n  type MergeNodesOptions,\n  type TElement,\n  type TNode,\n  type TText,\n  type ValueOf,\n  ElementApi,\n  NodeApi,\n  PathApi,\n  RangeApi,\n  TextApi,\n} from '../../interfaces';\nimport { getQueryOptions } from '../../utils';\n\nconst hasSingleChildNest = (editor: Editor, node: TNode): boolean => {\n  if (ElementApi.isElement(node)) {\n    const element = node as TElement;\n    if (editor.api.isVoid(node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0] as any);\n    } else {\n      return false;\n    }\n  } else if (NodeApi.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\nexport const mergeNodes = <E extends Editor>(\n  editor: E,\n  options: MergeNodesOptions<ValueOf<E>, E> = {}\n): void => {\n  options = getQueryOptions(editor, options);\n\n  editor.tf.withoutNormalizing(() => {\n    let { at = editor.selection!, match } = options;\n    const { hanging = false, mode = 'lowest', voids = false } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      if (PathApi.isPath(at)) {\n        const [parent] = editor.api.parent(at)!;\n        match = (n) => parent.children.includes(n as any);\n      } else {\n        match = (n) => ElementApi.isElement(n) && editor.api.isBlock(n);\n      }\n    }\n\n    if (!hanging && RangeApi.isRange(at)) {\n      at = editor.api.unhangRange(at);\n    }\n\n    if (RangeApi.isRange(at)) {\n      if (RangeApi.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        const [, end] = RangeApi.edges(at);\n        const pointRef = editor.api.pointRef(end);\n        editor.tf.delete({ at });\n        at = pointRef.unref()!;\n\n        if (options.at == null) {\n          editor.tf.select(at);\n        }\n      }\n    }\n\n    const _nodes = editor.api.nodes({ at, match, mode, voids });\n    const [current] = Array.from(_nodes);\n    const prev = editor.api.previous({ at, match, mode, voids });\n\n    if (!current || !prev) {\n      return;\n    }\n\n    const [node, path] = current;\n    const [prevNode, prevPath] = prev;\n\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n\n    const newPath = PathApi.next(prevPath);\n    const commonPath = PathApi.common(path, prevPath);\n    const isPreviousSibling = PathApi.isSibling(path, prevPath);\n    const _levels = editor.api.levels({ at: path });\n    const levels = new Set(\n      Array.from(_levels, ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n    );\n\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    const emptyAncestor = editor.api.above({\n      at: path,\n      mode: 'highest',\n      match: (n) => levels.has(n) && hasSingleChildNest(editor, n),\n    });\n\n    const emptyRef = emptyAncestor && editor.api.pathRef(emptyAncestor[1]);\n    let properties;\n    let position;\n\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (TextApi.isText(node) && TextApi.isText(prevNode)) {\n      const { text, ...rest } = node;\n      position = prevNode.text.length;\n      properties = rest as Partial<TText>;\n    } else if (ElementApi.isElement(node) && ElementApi.isElement(prevNode)) {\n      const { children, ...rest } = node;\n      position = prevNode.children.length;\n      properties = rest as Partial<TElement>;\n    } else {\n      throw new TypeError(\n        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n          node\n        )} ${JSON.stringify(prevNode)}`\n      );\n    }\n\n    // !PATCH: shouldMergeNodes\n    if (\n      !editor.api.shouldMergeNodes(prev, current, {\n        reverse: options.reverse,\n      })\n    ) {\n      return;\n    }\n\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (!isPreviousSibling) {\n      editor.tf.moveNodes({ at: path, to: newPath, voids });\n    }\n\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      // !PATCH: event to override removeNodes\n      editor.tf.removeNodes({\n        at: emptyRef.current!,\n        event: { type: 'mergeNodes' },\n        voids,\n      });\n    }\n\n    // !PATCH: moved up for early return\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n\n    editor.tf.apply({\n      path: newPath,\n      position,\n      properties,\n      type: 'merge_node',\n    });\n  });\n};\n","import { moveNodes as moveNodesBase } from 'slate';\n\nimport {\n  type Editor,\n  type MoveNodesOptions,\n  type TElement,\n  type ValueOf,\n  NodeApi,\n} from '../../interfaces';\nimport { getQueryOptions } from '../../utils';\n\nexport const moveNodes = <E extends Editor>(\n  editor: E,\n  { children, fromIndex = 0, ...opt }: MoveNodesOptions<ValueOf<E>>\n) => {\n  const options = getQueryOptions(editor, opt);\n\n  let moved = false;\n\n  if (children) {\n    if (!options.at) return moved;\n\n    const entry = editor.api.node(options.at!);\n\n    if (!entry) return moved;\n\n    const [node, path] = entry;\n\n    if (!editor.api.isBlock(node)) return moved;\n\n    for (\n      let i = (node.children as TElement[]).length - 1;\n      i >= fromIndex;\n      i--\n    ) {\n      const childPath = [...path, i];\n      const childNode = NodeApi.get(editor, childPath);\n\n      if (\n        !options.match ||\n        (childNode && options.match(childNode, childPath))\n      ) {\n        moveNodesBase(editor as any, {\n          ...options,\n          at: childPath,\n        });\n        moved = true;\n      }\n    }\n\n    return moved;\n  }\n\n  return moveNodesBase(editor as any, options);\n};\n","import type { SelectionMoveOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { move } from 'slate';\n\nimport type { Editor } from '../../interfaces';\n\nexport const moveSelection = (\n  editor: Editor,\n  options?: SelectionMoveOptions\n) => {\n  move(editor as any, options);\n};\n","import { removeNodes as removeNodesBase } from 'slate';\n\nimport type { Editor, RemoveNodesOptions, ValueOf } from '../../interfaces';\n\nimport { NodeApi } from '../../interfaces';\nimport { getQueryOptions } from '../../utils';\n\nexport const removeNodes = <E extends Editor>(\n  editor: E,\n  { children, previousEmptyBlock, ...opt }: RemoveNodesOptions<ValueOf<E>> = {}\n) => {\n  const options = getQueryOptions(editor, opt);\n\n  editor.tf.withoutNormalizing(() => {\n    if (previousEmptyBlock) {\n      const entry = editor.api.block({ at: options.at });\n\n      if (!entry) return;\n\n      const prevEntry = editor.api.previous({\n        at: entry[1],\n        sibling: true,\n      });\n\n      if (!prevEntry) return;\n\n      const [prevNode, prevPath] = prevEntry;\n\n      if (editor.api.isEmpty(prevNode)) {\n        editor.tf.removeNodes({ at: prevPath });\n      }\n\n      return;\n    }\n    // Handle children option\n    if (children && options.at) {\n      for (const [, childPath] of NodeApi.children(editor, options.at, {\n        reverse: true,\n      })) {\n        editor.tf.removeNodes({ ...options, at: childPath });\n      }\n\n      return;\n    }\n\n    return removeNodesBase(editor as any, getQueryOptions(editor, options));\n  });\n};\n","import { setNodes as setNodesBase } from 'slate';\n\nimport type {\n  DescendantOf,\n  Editor,\n  Path,\n  SetNodesOptions,\n  TNode,\n  ValueOf,\n} from '../../interfaces';\nimport type { NodeProps } from '../../interfaces/node';\n\nimport { PathApi, RangeApi, TextApi } from '../../interfaces';\nimport { getAt, getQueryOptions } from '../../utils';\n\nexport const setNodes = <N extends DescendantOf<E>, E extends Editor = Editor>(\n  editor: E,\n  props: Partial<NodeProps<N>>,\n  { marks, ...options }: SetNodesOptions<ValueOf<E>> & {} = {}\n) => {\n  if (marks) {\n    let at = getAt(editor, options.at) ?? editor.selection;\n\n    if (!at) return;\n    if (PathApi.isPath(at)) {\n      at = editor.api.range(at)!;\n    }\n    if (!RangeApi.isRange(at)) return;\n\n    const match = (node: TNode, path: Path) => {\n      if (!TextApi.isText(node)) return false;\n\n      const parentEntry = editor.api.parent(path);\n\n      if (!parentEntry) return false;\n\n      const [parentNode] = parentEntry;\n\n      return (\n        !editor.api.isVoid(parentNode as any) ||\n        editor.api.markableVoid(parentNode as any)\n      );\n    };\n\n    const isExpandedRange = RangeApi.isExpanded(at);\n    let markAcceptingVoidSelected = false;\n\n    if (!isExpandedRange) {\n      const selectedEntry = editor.api.node(at);\n\n      if (!selectedEntry) return;\n\n      const [selectedNode, selectedPath] = selectedEntry;\n\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        const parentEntry = editor.api.parent(selectedPath);\n\n        if (!parentEntry) return;\n\n        const [parentNode] = parentEntry;\n        markAcceptingVoidSelected =\n          parentNode && editor.api.markableVoid(parentNode as any);\n      }\n    }\n    if (isExpandedRange || markAcceptingVoidSelected) {\n      return setNodesBase(\n        editor as any,\n        props as any,\n        getQueryOptions(editor, {\n          ...options,\n          at,\n          match,\n          split: true,\n          voids: true,\n        })\n      );\n    }\n  }\n\n  return setNodesBase(\n    editor as any,\n    props as any,\n    getQueryOptions(editor, options)\n  );\n};\n","import type { SelectionSetPointOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { setPoint as setPointBase } from 'slate';\n\nimport type { Editor } from '../../interfaces';\nimport type { Point } from '../../interfaces/point';\n\nexport const setPoint = (\n  editor: Editor,\n  props: Partial<Point>,\n  options?: SelectionSetPointOptions\n) => {\n  setPointBase(editor as any, props, options);\n};\n","import { setSelection as setSelectionBase } from 'slate';\n\nimport type { Editor, TRange } from '../../interfaces';\n\nexport const setSelection = (editor: Editor, props: Partial<TRange>) => {\n  setSelectionBase(editor as any, props);\n};\n","import { splitNodes as splitNodesBase } from 'slate';\n\nimport type { Editor, SplitNodesOptions, ValueOf } from '../../interfaces';\n\nimport { getQueryOptions } from '../../utils';\n\nexport const splitNodes = <E extends Editor>(\n  editor: E,\n  options?: SplitNodesOptions<ValueOf<E>>\n) => {\n  return splitNodesBase(editor as any, getQueryOptions(editor, options));\n};\n","import { unsetNodes as unsetNodesBase } from 'slate';\n\nimport type {\n  DescendantOf,\n  Editor,\n  UnsetNodesOptions,\n  ValueOf,\n} from '../../interfaces';\nimport type { NodeProps } from '../../interfaces/node';\n\nimport { getQueryOptions } from '../../utils';\n\nexport const unsetNodes = <\n  N extends DescendantOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  props: (keyof NodeProps<N>)[] | keyof NodeProps<N>,\n  options?: UnsetNodesOptions<ValueOf<E>>\n) => {\n  return unsetNodesBase(\n    editor as any,\n    props as any,\n    getQueryOptions(editor, options)\n  );\n};\n","import { unwrapNodes as unwrapNodesBase } from 'slate';\n\nimport type { Editor, UnwrapNodesOptions, ValueOf } from '../../interfaces';\n\nimport { getQueryOptions } from '../../utils/match';\n\nexport const unwrapNodes = <E extends Editor>(\n  editor: E,\n  options?: UnwrapNodesOptions<ValueOf<E>>\n) => {\n  unwrapNodesBase(editor as any, getQueryOptions(editor, options));\n};\n","import { wrapNodes as wrapNodesBase } from 'slate';\n\nimport type {\n  Editor,\n  ElementOf,\n  TElement,\n  ValueOf,\n  WrapNodesOptions,\n} from '../../interfaces';\n\nimport { NodeApi, PathApi } from '../../interfaces';\nimport { getQueryOptions } from '../../utils';\n\nexport const wrapNodes = <N extends ElementOf<E>, E extends Editor = Editor>(\n  editor: E,\n  element: N,\n  { children, ...opt }: WrapNodesOptions<ValueOf<E>> = {}\n) => {\n  const options = getQueryOptions(editor, opt);\n\n  if (options.at) {\n    options.at = editor.api.unhangRange(options.at, options);\n  }\n  // Handle wrapping node children\n  if (children) {\n    const path = editor.api.path(options.at);\n\n    if (!path) return;\n\n    const node = NodeApi.get<TElement>(editor, path);\n\n    if (!node?.children) return;\n\n    editor.tf.withoutNormalizing(() => {\n      const firstChildPath = PathApi.firstChild(path);\n\n      // Wrap first child\n      wrapNodesBase(editor as any, element as any, {\n        ...options,\n        at: firstChildPath,\n      });\n\n      // Move remaining children if any\n      if (node.children.length > 1) {\n        editor.tf.moveNodes({\n          at: path,\n          children: true,\n          fromIndex: 1,\n          to: PathApi.child(firstChildPath, 1),\n        });\n      }\n    });\n\n    return;\n  }\n\n  // Regular wrap nodes behavior\n  wrapNodesBase(editor as any, element as any, options as any);\n};\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport { isPlainObject } from 'is-plain-object';\n\nimport {\n  type Editor,\n  type Operation,\n  type TRange,\n  OperationApi,\n} from '../interfaces/index';\n\n/** Weakmaps for attaching state to the editor. */\n\nconst SAVING = new WeakMap<Editor, boolean | undefined>();\n\nconst MERGING = new WeakMap<Editor, boolean | undefined>();\n\nconst SPLITTING_ONCE = new WeakMap<Editor, boolean | undefined>();\n\n/** `HistoryApi` contains helpers for history-enabled editors. */\nexport const HistoryApi = {\n  /** Check if a value is a `History` object. */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 ||\n        OperationApi.isOperationList(value.redos[0].operations)) &&\n      (value.undos.length === 0 ||\n        OperationApi.isOperationList(value.undos[0].operations))\n    );\n  },\n\n  /** Get the merge flag's current value. */\n  isMerging(editor: Editor): boolean | undefined {\n    return MERGING.get(editor);\n  },\n\n  /** Get the splitting once flag's current value. */\n  isSaving(editor: Editor): boolean | undefined {\n    return SAVING.get(editor);\n  },\n\n  isSplittingOnce(editor: Editor): boolean | undefined {\n    return SPLITTING_ONCE.get(editor);\n  },\n\n  /** Get the saving flag's current value. */\n  redo(editor: Editor): void {\n    editor.redo();\n  },\n\n  /** Redo to the previous saved state. */\n  setSplittingOnce(editor: Editor, value: boolean | undefined): void {\n    SPLITTING_ONCE.set(editor, value);\n  },\n\n  /** Undo to the previous saved state. */\n  undo(editor: Editor): void {\n    editor.undo();\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, These operations will\n   * be merged into the previous history.\n   */\n  withMerging(editor: Editor, fn: () => void): void {\n    const prev = editor.api.isMerging();\n    MERGING.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, ensuring that the\n   * first operation starts a new batch in the history. Subsequent operations\n   * will be merged as usual.\n   */\n  withNewBatch(editor: Editor, fn: () => void): void {\n    const prev = editor.api.isMerging();\n    MERGING.set(editor, true);\n    SPLITTING_ONCE.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n    SPLITTING_ONCE.delete(editor);\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n  withoutMerging(editor: Editor, fn: () => void): void {\n    const prev = editor.api.isMerging();\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n  withoutSaving(editor: Editor, fn: () => void): void {\n    const prev = editor.api.isSaving();\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  },\n};\n\nexport interface History {\n  /** Redos of the editor. */\n  redos: Batch[];\n\n  /** Undos of the editor. */\n  undos: Batch[];\n}\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\ninterface Batch {\n  operations: Operation[];\n  selectionBefore: TRange | null;\n}\n","export { withDOM } from 'slate-dom';\n\nexport { TRIPLE_CLICK } from 'slate-dom';\n\nexport {\n  type StringDiff,\n  type TextDiff,\n  applyStringDiff,\n  mergeStringDiffs,\n  normalizePoint,\n  normalizeRange,\n  normalizeStringDiff,\n  targetRange,\n  verifyDiffState,\n} from 'slate-dom';\n\nexport {\n  type DOMElement,\n  type DOMNode,\n  type DOMPoint,\n  type DOMRange,\n  type DOMSelection,\n  type DOMStaticRange,\n  type DOMText,\n  getActiveElement,\n  getDefaultView,\n  getSelection,\n  hasShadowRoot,\n  isAfter,\n  isBefore,\n  isDOMElement,\n  isDOMNode,\n  isDOMSelection,\n  isPlainTextOnlyPaste,\n  isTrackedMutation,\n  normalizeDOMPoint,\n} from 'slate-dom';\n\nexport {\n  CAN_USE_DOM,\n  HAS_BEFORE_INPUT_SUPPORT,\n  IS_ANDROID,\n  IS_CHROME,\n  IS_FIREFOX,\n  IS_FIREFOX_LEGACY,\n  IS_IOS,\n  IS_UC_MOBILE,\n  IS_WEBKIT,\n  IS_WECHATBROWSER,\n} from 'slate-dom';\n\nexport { isElementDecorationsEqual, isTextDecorationsEqual } from 'slate-dom';\n","import {\n  type Editor,\n  type LegacyEditorMethods,\n  type Operation,\n  OperationApi,\n  PathApi,\n} from '../interfaces/index';\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n */\nexport const withHistory = <T extends Editor>(editor: T) => {\n  const e = editor as Editor & LegacyEditorMethods;\n  const { apply } = e;\n  e.history = { redos: [], undos: [] };\n\n  e.redo = () => {\n    const { history } = e;\n    const { redos } = history;\n\n    if (redos.length > 0) {\n      const batch = redos.at(-1)!;\n\n      if (batch.selectionBefore) {\n        e.tf.setSelection(batch.selectionBefore);\n      }\n\n      e.tf.withoutSaving(() => {\n        e.tf.withoutNormalizing(() => {\n          for (const op of batch.operations) {\n            e.apply(op);\n          }\n        });\n      });\n\n      history.redos.pop();\n      e.writeHistory('undos', batch);\n    }\n  };\n\n  e.undo = () => {\n    const { history } = e;\n    const { undos } = history;\n\n    if (undos.length > 0) {\n      const batch = undos.at(-1)!;\n\n      e.tf.withoutSaving(() => {\n        e.tf.withoutNormalizing(() => {\n          const inverseOps = batch.operations\n            .map(OperationApi.inverse)\n            .reverse();\n\n          for (const op of inverseOps) {\n            e.apply(op);\n          }\n\n          if (batch.selectionBefore) {\n            e.tf.setSelection(batch.selectionBefore);\n          }\n        });\n      });\n\n      e.writeHistory('redos', batch);\n      history.undos.pop();\n    }\n  };\n\n  e.apply = (op: Operation) => {\n    const { history, operations } = e;\n    const { undos } = history;\n    const lastBatch = undos.at(-1);\n    const lastOp = lastBatch?.operations.at(-1);\n    let save = e.api.isSaving();\n    let merge = e.api.isMerging();\n\n    if (save == null) {\n      save = shouldSave(op, lastOp);\n    }\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length > 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp);\n        }\n      }\n      if (e.api.isSplittingOnce()) {\n        merge = false;\n        e.tf.setSplittingOnce(undefined);\n      }\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op);\n      } else {\n        const batch = {\n          operations: [op],\n          selectionBefore: e.selection,\n        };\n        e.writeHistory('undos', batch);\n      }\n\n      while (undos.length > 100) {\n        undos.shift();\n      }\n\n      history.redos = [];\n    }\n\n    apply(op);\n  };\n\n  e.writeHistory = (stack: 'redos' | 'undos', batch: any) => {\n    e.history[stack].push(batch);\n  };\n\n  return e as T;\n};\n\n/** Check whether to merge an operation into the previous operation. */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    PathApi.equals(op.path, prev.path)\n  ) {\n    return true;\n  }\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    PathApi.equals(op.path, prev.path)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/** Check whether an operation needs to be saved to the history. */\n\nconst shouldSave = (op: Operation, _: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n\n  return true;\n};\n"],"names":["path","last","path","path","parent","node","range","focus","point","DOMEditor","DOMEditor","DOMEditor","DOMEditor","node","DOMEditor","node","n","DOMEditor","at","DOMEditor","DOMEditor","DOMEditor","DOMEditor","range","DOMEditor","DOMEditor","DOMEditor","DOMEditor","DOMEditor","DOMEditor","DOMEditor","node","DOMEditor","point","DOMEditor","range","DOMEditor","DOMEditor","DOMEditor","start","end","above","e","point","point","castArray","path","block","n","match","node","match","first","last","node","path","focus","next","previous","at","path","point","e","start","end","n","after","node","path","pathRefs","point","pathRef","castArray","castArray","node","path","levels","first","last","n","node","path","marks","range","block","blocks","end","start","after","point","node","nodes","nodes","node","isElement","el","nodeType","canOverflow","overflow","skipOverflowHiddenElements","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","style","getComputedStyle","overflowY","overflowX","frame","ownerDocument","defaultView","frameElement","e","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","getParentElement","element","parent","parentElement","getRootNode","host","compute","target","options","_a","_b","_c","_d","document","scrollMode","block","inline","boundary","checkBoundary","node","TypeError","scrollingElement","documentElement","frames","cursor","push","body","viewportWidth","window","visualViewport","width","innerWidth","viewportHeight","height","innerHeight","scrollX","scrollY","targetHeight","targetWidth","top","targetTop","right","targetRight","bottom","targetBottom","left","targetLeft","getBoundingClientRect","marginTop","marginRight","marginBottom","marginLeft","computedStyle","parseFloat","scrollMarginTop","scrollMarginRight","scrollMarginBottom","scrollMarginLeft","targetBlock","targetInline","computations","index","length","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","scaleX","scaleY","Math","max","scrollLeft","scrollTop","min","getOptions","options","block","inline","Object","keys","length","scrollIntoView","target","isConnected","element","currentElement","parentNode","document","ShadowRoot","host","margins","computedStyle","window","getComputedStyle","top","parseFloat","scrollMarginTop","right","scrollMarginRight","bottom","scrollMarginBottom","left","scrollMarginLeft","behavior","compute","el","adjustedTop","adjustedLeft","scroll","path","e","range","nodes","node","node","point","point","node","block","nodes","point","point","node","path","match","start","path","n","parent","next","match","start","n","parent","previous","o","path","block","path","focus","range","start","end","castArray","marks","block","nodes","node","castArray","match","node","path","castArray","marks","nodes","path","castArray","end","start","n","after","node","path","pathRefs","point","r","fragment","nodes","node","path","n","marks","node","node","match","parent","n","end","pointRef","path","levels","node","path","marks","match","node","path","path","node","isPlainObject","isPlainObject","e","apply"],"mappings":"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O;QACT,OAAO,OAAO,GAAA,CAAI,KAAA,CAAS;YACzB,GAAI,OAAA;YACJ,OAAO;QACT,CAAC;IACH;IAEA,OAAO,OAAO,GAAA,CAAI,IAAA,CAAQ;QACxB,GAAG,OAAA;QACH,OAAO;QACP,MAAM;IACR,CAAC;AACH;;AC3BO,IAAM,SAAS,CACpB,QACA,YACG;IACH,OAAO;WACF,OAAO,GAAA,CAAI,KAAA,CAAS;YACrB,GAAG,OAAA;YACH,OAAO;QACT,CAAC;KACH;AACF;;ACbA,IAAM,oBAAoB,aAAA,GAAA,IAAI,IAAI;IAChC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,IAAM,aAAa,aAAA,GAAA,IAAI,IAAI;IACzB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAAA,WAAA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAEM,IAAM,yBAAyB,CAAC,QAAgB,eAAoB;IACzE,IAAI,CAAC,WAAY,CAAA;IAEjB,MAAMC,KAAI;IAEV,MAAM,mBAAmB,OAAO,OAAA,CAAQ,UAAU,EAAE,MAAA,CAClD,CAAC,KAAK,CAAC,KAAK,KAAK,CAAA,KAAM;QACrB,IAAI,kBAAkB,GAAA,CAAI,GAAG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","debugId":null}}]
}